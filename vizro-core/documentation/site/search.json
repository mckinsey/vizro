{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Vizro","text":"<p>Vizro is an open-source Python-based toolkit. You can use it to build data visualization apps quickly and easily, without needing advanced engineering or design expertise.</p> <ul> <li> <p> New to Vizro?</p> <p>Quickstart tutorial</p> <p>Explore Vizro tutorial</p> <p>Write your own actions tutorial</p> </li> <li> <p> Vizro features</p> <p>Fundamentals</p> <p>Components overview</p> <p>Visual formatting</p> <p>Extend and customize Vizro</p> </li> <li> <p> Gen AI assistance</p> <p> Vizro-MCP </p> <p>Vizro-AI (deprecated)</p> <p><code>llms.txt</code> (stable)</p> <p><code>llms-full.txt</code> (stable)</p> </li> <li> <p> Find out more</p> <p>FAQs</p> <p>Cheatsheet</p> </li> <li> <p> Get involved</p> <p>Contribute code</p> <p>Contribute to our docs</p> </li> </ul>","path":["Vizro"],"tags":[]},{"location":"API-reference/actions/","level":1,"title":"Actions","text":"<p>::: vizro.actions     options:       # Don't show underscore methods, function or output. AbstractAction is done separately below.       filters: [\"!^_\",\"!function\", \"!outputs\", \"!AbstractAction\"]</p>","path":["Actions"],"tags":[]},{"location":"API-reference/deprecations/","level":1,"title":"Deprecations and breaking changes","text":"<p>This page lists Vizro features that are now deprecated and forthcoming breaking changes for Vizro 0.2.0.</p>","path":["Deprecations and breaking changes"],"tags":[]},{"location":"API-reference/deprecations/#layout-model","level":2,"title":"<code>Layout</code> model","text":"<p>The [<code>Layout</code>][vizro.models.Layout] model has been renamed [<code>Grid</code>][vizro.models.Grid]. Replace your references to <code>Layout</code> with <code>Grid</code>.</p> <pre><code># Before:\nvm.Layout(grid=[[0, 1], [2, 3]])\n\n# After:\nvm.Grid(grid=[[0, 1], [2, 3]])\n</code></pre>","path":["Deprecations and breaking changes"],"tags":[]},{"location":"API-reference/deprecations/#action-model-inputs-argument","level":2,"title":"<code>Action</code> model <code>inputs</code> argument","text":"<p>The <code>inputs</code> argument of the [<code>Action</code> model][vizro.models.Action] is deprecated. Pass references to runtime inputs directly as arguments of <code>function</code>.</p> <pre><code># Before:\nvm.Action(function=my_action(), inputs=[\"dropdown.value\"], outputs=[\"text.children\"])\n\n# After:\nvm.Action(function=my_action(\"dropdown.value\"), outputs=[\"text.children\"])\n# In fact, just this would work and is preferred:\nvm.Action(function=my_action(\"dropdown\"), outputs=\"text\")\n</code></pre> <p>See the user guide on custom actions for more information.</p>","path":["Deprecations and breaking changes"],"tags":[]},{"location":"API-reference/deprecations/#static-argument-for-custom-action","level":2,"title":"Static argument for custom action","text":"<p>Passing a static argument to a custom action is deprecated. All arguments must instead be runtime inputs. For example, in Vizro 0.2.0, the following will no longer be possible:</p> <pre><code>@capture(\"action\")\ndef my_action(static_argument):\n    ...\n\nvm.Action(function=my_action(static_argument=1), ...)\n</code></pre> <p>Does this cause you a problem? Please let us know!</p>","path":["Deprecations and breaking changes"],"tags":[]},{"location":"API-reference/deprecations/#action-model-for-built-in-action","level":2,"title":"<code>Action</code> model for built-in action","text":"<p>Using the [<code>Action</code> model][vizro.models.Action] for built-in actions is deprecated. Call the action directly:</p> <pre><code># Before:\nvm.Action(function=va.export_data(file_format=\"xlsx\"))\n\n# After:\nva.export_data(file_format=\"xlsx\")\n</code></pre> <p>See the user guide on built-in actions for more information.</p>","path":["Deprecations and breaking changes"],"tags":[]},{"location":"API-reference/deprecations/#filter_interaction","level":2,"title":"<code>filter_interaction</code>","text":"<p><code>filter_interaction</code> is deprecated. Use the more powerful and flexible [<code>set_control</code>][vizro.actions.set_control].</p> <pre><code># Before:\ncomponents = [\n    vm.AgGrid(..., actions=va.filter_interaction(targets=[\"target_chart\"]),\n    vm.Graph(id=\"target_chart\", ...)\n]\n\n# After:\ncomponents = [\n    vm.AgGrid(..., actions=va.set_control(control=\"my_filter\", value=\"species\")),\n    vm.Graph(id=\"target_chart\", ...)\n]\n# You must now explicitly specify a Filter in controls:\ncontrols = [vm.Filter(id=\"my_filter\", targets=[\"target_chart\"], column=\"species\")]\n</code></pre> <p>See the user guide on how to interact with graphs and tables for more information.</p>","path":["Deprecations and breaking changes"],"tags":[]},{"location":"API-reference/figure-callables/","level":1,"title":"Figure functions","text":"","path":["Figure functions"],"tags":[]},{"location":"API-reference/figure-callables/#figure-functions","level":1,"title":"Figure functions","text":"<p>Using figure functions in pure Dash app</p> <p>Identical functions can also be used outside the Vizro framework in a pure Dash app by importing from the <code>vizro.figures.library</code> namespace: <pre><code>from vizro.figures.library import kpi_card, kpi_card_reference\n</code></pre></p> <p>::: vizro.figures     options:       show_source: true</p>","path":["Figure functions"],"tags":[]},{"location":"API-reference/kedro-integration/","level":1,"title":"Kedro integration","text":"","path":["Kedro integration"],"tags":[]},{"location":"API-reference/kedro-integration/#kedro-integration","level":1,"title":"Kedro integration","text":"<p>::: vizro.integrations.kedro     options:       show_source: false</p>","path":["Kedro integration"],"tags":[]},{"location":"API-reference/models/","level":1,"title":"Models","text":"<p>::: vizro.models     options:       filters: [\"!^_\",\"!build\",\"!model_post_init\"] # Don't show underscore methods, build method, and model_post_init</p> <p>::: vizro.models.types     options:       filters: [\"!^_\"]  # Don't show dunder methods as well as single underscore ones       merge_init_into_class: false</p>","path":["Models"],"tags":[]},{"location":"API-reference/table-callables/","level":1,"title":"Table functions","text":"","path":["Table functions"],"tags":[]},{"location":"API-reference/table-callables/#table-functions","level":1,"title":"Table functions","text":"<p>::: vizro.tables     options:       show_source: true</p>","path":["Table functions"],"tags":[]},{"location":"API-reference/vizro/","level":1,"title":"Vizro","text":"<p>::: vizro.Vizro     options:       docstring_options:         ignore_init_summary: true       merge_init_into_class: true       members: [build, run]</p>","path":["Vizro"],"tags":[]},{"location":"explanation/actions-explanation/","level":1,"title":"Actions","text":"<p>Actions control how your app responds to user input such as clicking a button or a point on a graph. Vizro provides built-in actions and also enables you to write your own custom actions.</p> <p>Vizro's actions are built on top of Dash callbacks, but you do not need to know anything about Dash to use them. This page explains more about how Vizro actions work and their similarities and differences compared to Dash callbacks.</p>","path":["Actions"],"tags":[]},{"location":"explanation/actions-explanation/#what-is-an-action","level":2,"title":"What is an action?","text":"<p>There are two aspects to every Vizro app:</p> <ul> <li>Layout. This controls what your app looks like, for example which components you would like to see on your pages and where to place them. Under the hood, this uses Dash layout.</li> <li>Interactivity. This controls how your app behaves in response to user input, for example what happens when someone clicks a button in your app. This uses actions, which under the hood use Dash callbacks.</li> </ul> <p>Vizro models such as <code>vm.Graph</code>, <code>vm.Filter</code>, <code>vm.Button</code> and <code>vm.Page</code> configure both the layout and interactivity. For example, the <code>vm.Filter</code> model configures both the layout and the interactivity of a filter. The <code>selector</code> argument configures which selector component (such as a dropdown or checklist) to render on screen. There's also an <code>actions</code> argument that configures what happens when a user changes the value of the selector. You generally don't set this <code>actions</code> argument because by default it is set to a filtering action that updates components on the page that depend on the column being filtered.</p> <p>Many [Vizro models][vizro.models] have an <code>actions</code> argument that can contain one or more actions. Each action is a Python function that is triggered when a user interacts with a component. This function can depend on inputs from the user's screen and update outputs on the user's screen.</p> <p>In Vizro, there are two types of action:</p> <ul> <li>Built-in actions. These cover many common dashboard operations such as downloading data and cross-filtering. These actions can be imported from <code>vizro.actions</code>.</li> <li>Custom actions. These are written by a dashboard developer to achieve behavior outside of Vizro's built-in actions and use the [<code>Action</code> model][vizro.models.Action].</li> </ul> <p>Note</p> <p>Do you have an idea for a built-in action? Submit a feature request!</p>","path":["Actions"],"tags":[]},{"location":"explanation/authors/","level":1,"title":"Authors","text":"","path":["Authors"],"tags":[]},{"location":"explanation/authors/#current-team-members","level":2,"title":"Current team members","text":"<p>Alexey Snigir, Antony Milne, Dan Dumitriu, Huong Li Nguyen, Jo Stichbury, Joseph Perkins, Lingyi Zhang, Maximilian Schulz, Nadija Graca, and Petar Pejovic</p>","path":["Authors"],"tags":[]},{"location":"explanation/authors/#previous-team-members-and-code-contributors","level":2,"title":"Previous team members and code contributors","text":"<p>Vizro and Vizro-AI have received contributions from the following on GitHub:</p> <p> </p> <p>Thanks also to these contributors:</p> <p>Annie Wachsmuth, ataraexia, Bo Xu, Denis Lebedev, Elena Fridman, Hamza Oza, Jenelle Yonkman, Jingjing Guo, Juan Luis Cano Rodríguez, Kee Wen Ng, Leon Nallamuthu, Nikolaos Tsaousis, Oleksandr Serdiuk, Prateek Bajaj, Qiuyi Chen, and Rashida Kanchwala.</p> <p>Many thanks to Sam Bourton and Kevin Staight for sponsorship, inspiration and guidance, and special appreciation to Wesley Leong, Jonas Kemper and team for origination and support (plus everyone else who helped to test, guide, support and encourage development).</p> <p>We stand on the shoulders of giants. Thanks to the following organizations for foundation and inspiration:</p> <ul> <li>Plotly</li> <li>Pydantic</li> </ul>","path":["Authors"],"tags":[]},{"location":"explanation/contributing/","level":1,"title":"Contributing","text":"<p>Contributions of all experience levels are welcome! There are many ways to contribute, and we appreciate any help: it doesn't have to be a pull request (PR) on our code. You can also report a bug, request a feature, or ask and answer community questions. Before making significant changes to Vizro code, you should first use GitHub issues to discuss your contribution.</p> <p>Our development follows a standard GitHub flow. To be merged, your PR must meet all the following requirements:</p> <ul> <li>two approving reviews (including a code owner)</li> <li>Continuous Integration (CI) checks pass</li> <li>code is up-to-date with <code>main</code></li> </ul> <p>If you are a first-time contributor with a new GitHub account then you may also need to wait for CI workflows to be approved.</p> <p>We aim to make the contribution process as easy as possible by having only one direct development dependency: Hatch. There are two ways to develop on Vizro:</p> <ul> <li>GitHub Codespaces. This is the recommended method if you are a new contributor. It is the quickest and easiest way to get started. All development can be done in your browser in a temporary environment; you do not need to set up anything on your computer. The Develop on GitHub Codespaces section has full instructions on how to do this.</li> <li>Local machine. If you are more experienced then you might prefer to develop on your own computer. The Develop locally section has full instructions on how to do this.</li> </ul> <p>Note</p> <p>For either method, Hatch is the only development dependency. You do not need to manually install Python or create any virtual environments to develop Vizro; all this will be handled for you behind the scenes by Hatch. We have also configured our codespace to pre-install Hatch. If you develop on GitHub Codespaces you don't need to install anything at all!</p>","path":["Contributing"],"tags":[]},{"location":"explanation/contributing/#develop-on-github-codespaces","level":2,"title":"Develop on GitHub Codespaces","text":"<p>There is no need to manually create a fork of the Vizro code if you use GitHub Codespaces. A fork is automatically created for you.</p> <p>To develop on GitHub Codespaces, follow the below steps:</p> <ol> <li>Create a codespace for our repository. Leave the settings on their defaults and click \"Create codespace\" to start your codespace. It should take 1-2 minutes to fully launch and automatically start an example dashboard on port 8050. In the rare event that the codespace fails to start correctly and enters recovery mode, you should rebuild the container or start a whole new codespace.</li> <li>Make changes to Vizro code in your codespace. See the GitHub Codespaces documentation on developing in a codespace for more information.</li> <li>Add your name to the list of contributors (source file <code>vizro-core/docs/pages/explanation/authors.md</code>).</li> <li>Create a pull request.</li> </ol>","path":["Contributing"],"tags":[]},{"location":"explanation/contributing/#develop-locally","level":2,"title":"Develop locally","text":"<ol> <li>Install Hatch. There are several ways to do this.</li> <li>Fork the Vizro repository and clone it to your local machine.</li> <li>Make changes to Vizro code in your fork.</li> <li>Add your name to the list of contributors (source file <code>vizro-core/docs/pages/explanation/authors.md</code>).</li> <li>Create a pull request.</li> </ol>","path":["Contributing"],"tags":[]},{"location":"explanation/contributing/#how-to-use-hatch","level":2,"title":"How to use Hatch","text":"<p>Regardless of whether you are developing locally or in a codespace, everything you need to develop on Vizro is provided by Hatch through the <code>hatch run</code> command. The first time you use this command it will install all the required dependencies, including Python.</p> <p>The Hatch commands you need most commonly are as follows. These must be executed with <code>vizro-core</code> as your current working directory:</p> <ul> <li><code>hatch run pypath</code> shows the path to the Python interpreter.</li> <li><code>hatch run example</code> runs an example dashboard on port 8050 that hot-reloads while you edit it. On GitHub Codespaces, this runs automatically on startup.</li> <li><code>hatch run lint</code> checks and fixes code quality and formatting. This is included in CI checks.</li> <li><code>hatch run changelog:add</code> generates a new changelog fragment. Changelog inclusion is checked by CI and required for all changes to source code.</li> <li><code>hatch run test-unit</code> runs the test suite. This is included in CI checks.</li> <li><code>hatch run docs:serve</code> builds and displays documentation that hot-reloads while you edit it. Documentation is also built automatically in your PR and can be previewed on Read The Docs.</li> <li><code>hatch run pip</code> provides a pip-compatible interface using uv. You should not need to use this much.</li> </ul> <p>To save yourself from repeatedly typing <code>hatch run</code> you might like to set up an alias:</p> <pre><code>alias hr=\"hatch run\"\n</code></pre> <p>This enables you to run, for example, <code>hr lint</code> instead of <code>hatch run lint</code>. On GitHub Codespaces, this alias is already set up for you.</p>","path":["Contributing"],"tags":[]},{"location":"explanation/contributing/#hatch-run-pypath","level":3,"title":"<code>hatch run pypath</code>","text":"<p><code>hatch run pypath</code> shows the path to the Python interpreter. This is useful for setting a Python interpreter in your IDE to navigate the codebase. For example, in GitHub Codespaces and VS Code:</p> <ul> <li>Run <code>hatch run pypath</code> and copy the output to your clipboard.</li> <li>Open the Command Palette (Ctrl+Shift+P).</li> <li>Run the \"Python: Select Interpreter\" command and select the \"Enter interpreter path...\" option.</li> <li>Paste the path.</li> </ul>","path":["Contributing"],"tags":[]},{"location":"explanation/contributing/#hatch-run-example","level":3,"title":"<code>hatch run example</code>","text":"<p><code>hatch run example</code> runs an example dashboard on port 8050 that hot-reloads while you edit it. On GitHub Codespaces, this runs automatically on startup and is labeled as <code>scratch_dev example</code>. On your local machine, you can access the dashboard by pointing your browser to http://127.0.0.1:8050.</p> <p>By default, this command runs the dashboard configured in <code>vizro-core/examples/scratch_dev/app.py</code>. This dashboard is used as a temporary \"scratch\" playground during development. Since it is opened automatically in GitHub Codespaces, it's the perfect place to show, or test out, a new feature you're developing. PR reviewers can then immediately see exactly what your changes do by opening a codespace on your branch.</p> <p>You can run any example in <code>vizro-core/examples</code> or its subdirectories by running <code>hatch run example &lt;example_path&gt;</code>, where <code>&lt;example_path&gt;</code> is the path to the directory containing the <code>app.py</code> file relative to <code>vizro-core/examples</code>. For example, <code>hatch run example dev</code> runs a dashboard located at <code>vizro-core/examples/dev/app.py</code>. This dashboard demonstrates a full set of Vizro features and is also hosted on Hugging Face.</p> <p>Examples are run with the following settings:</p> <ul> <li>Dash dev tools enabled. This includes hot reloading, so that any changes to the example app or Vizro source code should automatically show in your dashboard without needing refresh or restart anything.</li> <li>The environment variable <code>VIZRO_LOG_LEVEL = \"DEBUG\"</code> to show log messages of level <code>DEBUG</code> and above.</li> </ul>","path":["Contributing"],"tags":[]},{"location":"explanation/contributing/#hatch-run-lint","level":3,"title":"<code>hatch run lint</code>","text":"<p><code>hatch run lint</code> checks and fixes code quality and formatting. This is included in CI checks. All linting and associated dependencies are controlled by pre-commit hooks. We use the pre-commit.ci to automatically fix all the linting checks that we can when a PR is pushed. Other linting failures (such as <code>mypy</code>) need manual intervention from the developer.</p> <p>Note</p> <p>The first time you run <code>hatch run lint</code> it may take a couple of minutes, since pre-commit needs to setup linting environments. Further runs reuse these environments and are much faster.</p> <p><code>hatch run lint</code> runs the pre-commit hooks on all (not only staged) files. You can run an individual hook, for example <code>mypy</code>, on all files by running <code>hatch run lint mypy</code>.</p> <p>Our Hatch environment specifies <code>pre-commit</code> as a dependency but otherwise does not specify dependencies for linting tools. Instead, the versions of these are pinned in <code>.pre-commit-config.yaml</code>, and <code>pre-commit ci</code> raises a monthly PR to update them.</p>","path":["Contributing"],"tags":[]},{"location":"explanation/contributing/#hatch-run-changelogadd","level":3,"title":"<code>hatch run changelog:add</code>","text":"<p><code>hatch run changelog:add</code> generates a new changelog fragment. Changelog inclusion is checked by CI and required for all changes to source code.</p> <p>The format of our changelog is based on Keep a Changelog. We use scriv to build and maintain our changelog. When raising a PR, you must ensure that a changelog fragment has been created. This fragment is a small <code>.md</code> file describing your changes.</p> <p>Run <code>hatch run changelog:add</code> to create a changelog fragment and then uncomment the relevant section(s). If you are uncertain about what to add or whether to add anything at all, refer to Keep a Changelog. The rule of thumb is that if Vizro users would be affected in any way then the changes should be described in the changelog.</p> <p>Note</p> <p>Changes that do not affect source code do not need a changelog fragment. This simplifies modifications to documentation made directly on GitHub or within the github.dev, where no terminal is available to run <code>hatch changelog:add</code>. Any changes to source code require a changelog fragment to be generated. If your changes do not require a changelog entry then you still need to generate the fragment but can leave it all commented out.</p>","path":["Contributing"],"tags":[]},{"location":"explanation/contributing/#hatch-run-test-unit","level":3,"title":"<code>hatch run test-unit</code>","text":"<p><code>hatch run test-unit</code> runs the test suite. This is included in CI checks.</p> <p>Tests are handled using pytest and arguments are passed through to the underlying <code>pytest</code> command. For example, to rerun only failures from the last <code>pytest</code> invocation, you could run:</p> <pre><code>hatch run test-unit --last-failed\n</code></pre> <p>In CI, we test across multiple Python versions and also check for code coverage. If required, you can also run this locally. For example, to run unit tests with Python 3.13 and check for code coverage, you would run:</p> <pre><code>hatch run all.py3.13:test-unit-coverage\n</code></pre> <p>In addition to running unit tests with code coverage, CI also performs the following checks:</p> <ul> <li><code>hatch run test-integration</code> runs integration tests that include checking that the example apps in <code>vizro-core/examples</code> run.</li> <li><code>hatch run test-js</code> runs Javascript tests using jest. Arguments are passed through to the underlying <code>npx jest</code> command, for example <code>hatch run test-js --help</code>.</li> <li>QA tests. These are run on a separate private <code>vizro-qa</code> repository and not triggered by PRs coming from forks.</li> </ul>","path":["Contributing"],"tags":[]},{"location":"explanation/contributing/#hatch-run-docsserve","level":3,"title":"<code>hatch run docs:serve</code>","text":"<p><code>hatch run docs:serve</code> builds and displays documentation that hot-reloads while you edit it. Documentation is also built automatically in your PR and can be previewed on Read The Docs. To do this, scroll to the bottom of your PR where all the checks are listed and click the \"Details\" link next to the Read the Docs build.</p> <p>For more information on our documentation style, refer to our style guide.</p>","path":["Contributing"],"tags":[]},{"location":"explanation/contributing/#hatch-run-pip","level":3,"title":"<code>hatch run pip</code>","text":"<p><code>hatch run pip</code> provides a pip-compatible interface using uv. You should not need to use this often.</p> <p>Vizro's dependencies are described by the <code>dependencies</code> section in <code>vizro-core/pyproject.toml</code>. There is no need to manually install or update the dependencies in your environment; they will be handled automatically for you when you do <code>hatch run</code>. This means that there is usually no need to <code>pip install</code> anything.</p> <p>We have configured Hatch to use uv for rapid virtual environment creation, dependency resolution and installation.</p> <p>Note</p> <p>If you have installed unwanted dependencies in your Hatch environment then the simplest solution is to delete the environment (<code>hatch env remove</code> to remove one environment or <code>hatch env prune</code> to remove all environments). Your next <code>hatch run</code> command will recreate the environment and install all the dependencies it needs.</p> <p>If for some reason you do need to use <code>pip</code> then the correct way to do so is through <code>hatch run pip</code>. For example, you could run <code>hatch run pip show plotly</code>. This will use the version of uv that Hatch itself uses under the hood. If you already have uv installed globally then <code>uv pip show plotly</code> would also work.</p> <p>Warning</p> <p>You should not try to interact with Vizro dependencies using a global <code>pip</code>. For example, running <code>pip show plotly</code> without the <code>hatch run</code> prefix will not work correctly.</p>","path":["Contributing"],"tags":[]},{"location":"explanation/contributing/#code-of-conduct","level":2,"title":"Code of conduct","text":"<p>The Vizro team pledges to foster and maintain a friendly community. We enforce a Code of Conduct to ensure every Vizro contributor is welcomed and treated with respect.</p>","path":["Contributing"],"tags":[]},{"location":"explanation/documentation-style-guide/","level":1,"title":"Vizro documentation style guide","text":"<p>This is the style guide we apply to the Vizro documentation.</p> <p>We ask anyone kind enough to contribute documentation changes to follow this style for consistency and simplicity.</p> <p>What follows is a set of lightweight guidelines rather than rules. There are always edge cases and exceptions, and if it's not obvious what the style should be, consult the Microsoft style guide for an example of good practice. We also ensure inclusive terminology with the Google developer documentation style guide.</p>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#vizro-lexicon","level":2,"title":"Vizro lexicon","text":"<p>The names of our products and sites are:</p> <ul> <li>Vizro</li> <li>Vizro-MCP</li> <li>Vizro visual vocabulary dashboard</li> <li>Vizro-AI (mostly deprecated in favor of Vizro-MCP)</li> </ul> <p>We refer to other products using their preferred capitalization. For example:</p> <ul> <li>Dash and Pydantic are always capitalized, except where given as Python package names <code>dash</code> and <code>pydantic</code>.</li> <li>pandas DataFrame has a lowercase \"p\" and camelcase \"DataFrame\".</li> </ul> <p>Vizro components are named using lower case:</p> <p>Here is a guide to using containers...</p> <p>Use code font when referring to the component as a class or object:</p> <p>To add a <code>Container</code> to your page...</p> <p>Avoid referring to data using terms like \"dataset\" or \"connector\". Prefer to use just \"data\" or, where that does not feel natural, \"data source\".</p>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#bullets","level":2,"title":"Bullets","text":"<ul> <li>Capitalize the first word, and end the bullet with a period.</li> <li>Don't use numbered bullets except for a sequence of instructions, or where you have to refer back to one of them in the text (or a diagram).</li> </ul>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#call-out-boxes","level":2,"title":"Call out boxes","text":"<p>Keep the amount of text, and the number and variety of callouts used, to a minimum. There is a broad set available for use in the Vizro docs, but we limit usage to notes, warnings, details and examples:</p> <p>note</p> <p>For notable information.</p> <p>warning</p> <p>To indicate a potential gotcha.</p> See more details <p>A side note (used sparingly)</p> <p>example</p> <p>For example code.</p> <p>Callout boxes can be made collapsible: if you use them, add them to the page so they are initially collapsed.</p> Limit the use of collapsible callouts to secondary information only <p>Don't use expanded-on-load collapsibles like this one. If the callout contains important information and needs to be shown as expanded on page load, it should simply be non-collapsible.</p>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#capitalization","level":2,"title":"Capitalization","text":"<ul> <li>Only capitalize proper nouns such as the names of technology products, other tools and services.</li> <li>Don't capitalize cloud, internet, machine learning, or advanced analytics. Take a look at the Microsoft style guide if you're unsure.</li> <li>Follow sentence case, which capitalizes only the first word of a title/subtitle. We prefer \"An introduction to data visualization\" to \"An Introduction to Data Visualization\".</li> </ul>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#code-formatting","level":2,"title":"Code formatting","text":"<ul> <li>Mark code blocks with the appropriate language to enable syntax highlighting.</li> <li>We use a <code>bash</code> lexer for all codeblocks that represent the terminal, and we don't include the prompt.</li> <li>Use the code format for Python package names such as <code>pandas</code> or <code>pydantic</code>.</li> </ul>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#headings-and-subheadings","level":2,"title":"Headings and subheadings","text":"<p>Choosing a heading is sometimes the hardest part of the writing process. Take your time!</p> <p>Aim to avoid use of gerunds (verb+ing) where you can. So your page should be \"Get started\" rather than \"Getting started\" and \"Customize a layout\" rather than \"Customizing a layout\". Keep the title short and descriptive, ideally think about a reader who may be using a search engine to find an answer -- structure your title to give them the best chance of understanding what the page tells them.</p> <p>In Vizro, when you are working on a how-to guide, there are a few more guidelines to follow for consistency:</p> <ul> <li>Don't use \"how to\" in the file name: keep that as short as possible.</li> <li>The title (H1 header) should start with \"How to\".</li> <li>Don't use \"how to\" in the subsections that follow (H2 - H5) unless you consider the alternative to be confusing.</li> <li>Don't use gerund form in the subsections either.</li> </ul> <p>Example: In a page called \"Filters\" you would have the following:</p> <ul> <li>H1: \"How to use filters\"</li> <li>H2 subsection: \"Use a custom filter\" and not \"How to use a custom filter\" nor \"Using a custom filter\".</li> </ul>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#instructions","level":2,"title":"Instructions","text":"<p>Prefer to use imperatives to make instructions. For example:</p> <p>Complete the configuration steps</p> <p>You don't need to use the word \"please\" -- readers want less to read and don't think it's rude if you omit it.</p> <p>You can also use second person:</p> <p>You should complete the configuration steps.</p> <p>Don't use the passive tense:</p> <p>The configuration steps should be completed.</p> <p>What is passive tense?</p> <p>If you can add \"by zombies\" to the end of any sentence, it is passive.</p> <ul> <li>For example: \"The configuration steps should be completed.\" can also be read as: \"The configuration should be completed BY ZOMBIES\".</li> <li>Instead, you'd write this: \"You should complete the configuration steps\" or better still, \"Complete the configuration steps\".</li> </ul>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#language","level":2,"title":"Language","text":"<ul> <li>Use US English.</li> </ul>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#links","level":2,"title":"Links","text":"<ul> <li>Make hyperlink descriptions as descriptive as you can. This is a good description:</li> </ul> <p>Learn how to contribute to Vizro.</p> <p>This is less helpful:</p> <p>Learn how to contribute to Vizro.</p> <p>Don't write this:</p> <p>To learn how to contribute to Vizro, see here.</p>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#internal-cross-referencing","level":3,"title":"Internal cross-referencing","text":"<p>We use internal cross-references as follows:</p> <ul> <li>For each documentation page, if it helps the reader, we link to narrative documentation (non-API documentation) about each Vizro topic where it is first introduced.</li> <li>On any single page, we limit the repetition of links: do not re-link to the same page again unless there is good reason to do so (for example, linking to a specific sub-section to illustrate a point).</li> <li>Add links to relevant API documentation where it is useful for the reader, and consider how they will navigate from where they land in the API documentation back to the narrative content. Consider adding a link in the relevant docstring back to your page.</li> </ul>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#oxford-commas","level":2,"title":"Oxford commas","text":"<p>Use these in lists to avoid confusion. This is confusing:</p> <p>The ice cream comes in a range of flavors including banana and strawberry, mango and raspberry and blueberry.</p> <p>This is clearer:</p> <p>The ice cream comes in a range of flavors including banana and strawberry, mango and raspberry, and blueberry.</p>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#style","level":2,"title":"Style","text":"<p>Keep your sentences short and easy to read. Your tone of voice should be simple, friendly and functional.</p>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#simple","level":3,"title":"Simple","text":"<p>Simple is clear, concise and direct:</p> <p>We build new skills in your team.</p> <p>Simple is not vague, verbose or full of jargon:</p> <p>We leverage your existing organizational resources to synthesize novel competencies.</p>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#friendly","level":3,"title":"Friendly","text":"<p>Friendly is approachable and open, and it makes discussions flow:</p> <p>Vizro: Let’s make cool visualizations happen. Together.</p> <p>Friendly is not secretive, negative, vague or non-inclusive:</p> <p>Vizro is utilized to build tier one visualizations for your organization.</p>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#functional","level":3,"title":"Functional","text":"<p>Functional is compelling, positive, inspiring:</p> <p>200+ successful projects and counting.</p> <p>Functional is not try-hard, cliched or hyperbolic:</p> <p>We’re ultra-sucessful business-builders.</p>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/documentation-style-guide/#things-to-avoid","level":2,"title":"Things to avoid","text":"<ul> <li>Gerunds in headings. What are these? They are the \"-ing\" forms of verbs. If you find yourself writing \"Getting started\" in a heading, then consider \"Get started\" or \"How to get started\" instead. In fact, in general, it's better to avoid gerund-forms of verbs where you can.</li> <li>Plagiarism. Link to their text and credit them.</li> <li>Colloquialisms. Avoid them \"like the plague\" because they may not translate to other regions/languages.</li> <li>Technical terminology. This applies particularly to acronyms that do not pass the \"Google test\". If it is not possible to find their meaning from a simple Google search, don't use them, or explain them with a link or some text.</li> <li>Business speak. You can explain simply without using words like \"leverage\", \"utilize\" or \"facilitate\" and still sound clever.</li> </ul>","path":["Vizro documentation style guide"],"tags":[]},{"location":"explanation/faq/","level":1,"title":"FAQs","text":"<p>Here are some answers to frequently asked questions:</p> <ul> <li>Which browsers does Vizro support?</li> <li>What is the Vizro versioning policy?</li> <li>Where can I find example dashboards?</li> <li>How does Vizro work under the hood?</li> <li>Why should I use Vizro?</li> <li>How does Vizro differ from Dash or Streamlit?</li> <li>How does Vizro compare with Python packages and business intelligence (BI) tools?</li> <li>When would an alternative to Vizro be more suitable?</li> <li>What license is Vizro open sourced under?</li> <li>How can I report a bug?</li> <li>Where can I find the roadmap for Vizro?</li> <li>How can I request a feature?</li> <li>I still have a question. Where can I ask it?</li> </ul>","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#which-browsers-does-vizro-support","level":2,"title":"Which browsers does Vizro support?","text":"<p>Vizro supports the Chrome browser. Other browsers may work, but are not officially supported.</p>","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#what-is-the-vizro-versioning-policy","level":2,"title":"What is the Vizro versioning policy?","text":"<p>This project adheres to semantic versioning. We do not consider frontend changes (such as changing the appearance of a component) to be breaking changes.</p> <p>Note</p> <p>While being in version <code>0.x.x</code>, we may introduce breaking changes in minor versions.</p>","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#where-can-i-find-example-dashboards","level":2,"title":"Where can I find example dashboards?","text":"<p>For a gallery of examples showing Vizro in action, take a look at the Vizro HuggingFace collection, which includes complete code accessed for each example by selecting \"Files\" in the top right menu.</p> <p>We also maintain a separate, curated page of videos, blog posts, and examples of Vizro usage from our community.</p>","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#how-does-vizro-work-under-the-hood","level":2,"title":"How does Vizro work under the hood?","text":"<p>This documentation is designed mostly for users of Vizro, but if you're interested in how Vizro works, we recommend heading over to the auto-generated DeepWiki pages for insight into Vizro's architecture, dashboard model, page model, and more. These pages are created using generative AI by a third party outside of Vizro.</p>","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#why-should-i-use-vizro","level":2,"title":"Why should I use Vizro?","text":"<p>Vizro is a high-level framework built on top of Dash and Pydantic, which makes it easier to build advanced dashboards since it automates many of the otherwise complex and time-consuming tasks traditionally associated with designing, building and deploying front-end applications, from prototypes to production.</p>","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#you-can-build-beautiful-powerful-dashboards-quickly-easily","level":3,"title":"You can build beautiful &amp; powerful dashboards, quickly &amp; easily","text":"<p>Users can configure Vizro dashboards without needing to know advanced software development principles, nor how to build front-end applications.</p> See more details <p> less than 30 lines of configuration can create dashboards with multiple charts and filters </p> <ul> <li>Beautiful - inbuilt visual design best practices are applied automatically, so users can create beautiful dashboards without needing to know any HTML, CSS or design principles.</li> <li>Powerful - advanced functionality and interactions come out-of-the-box, by using just a few lines of simple configuration.</li> <li>Quick and easy - the simple configuration follows an intuitive \"grammar of dashboards\" which is quick to learn and easy to use. This removes most of the \"glue code\" that would otherwise need to be written. Thousands of lines of code are reduced to tens of lines of configuration. Users can configure Vizro dashboards without needing to know any advanced software development principles of how to build front-end applications.</li> </ul>","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#you-can-extend-and-customize-infinitely","level":3,"title":"You can extend and customize infinitely","text":"<p>Users benefit from the power of the Dash framework and the flexibility of React.</p> See more details <ul> <li>Dash - since Vizro is built on top of Dash, then users benefit from all the underlying power and customizations offered by the Dash framework, including the ability to use extension libraries related to Dash.</li> <li>React - since Dash enables JavaScript React components to be incorporated into Dash applications, Vizro users can create custom charts and UI components which offer the infinite flexibility of React.</li> <li>Vizro extensions - adding extensions such as user defined custom charts, components, actions and data connectors is intuitively incorporated into the configuration language of Vizro.</li> </ul>","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#you-can-rapidly-scale-from-prototypes-to-production-deployment","level":3,"title":"You can rapidly scale from prototypes to production deployment","text":"<p>Consistency and re-usability designed for scale.</p> See more details <ul> <li>Prototype rapidly - even complex dashboards can be created within minutes using Vizro, which enables prototype dashboards to be created and iterated on quickly and easily, with very low barrier to entry.</li> <li>Deploy easily - since Vizro is built on Dash which uses Flask, it is simple to deploy Vizro like any other Dash application, and use application servers such as Gunicorn to scale to multiple users.</li> <li>Scale - since Vizro offers standardization of visual design, application architecture and configuration language, it is easier to scale across multiple developers, projects and implementations in a consistent and reusable way.</li> </ul>","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#how-does-vizro-differ-from-dash-or-streamlit","level":2,"title":"How does Vizro differ from Dash or Streamlit?","text":"<p>Potential users sometimes request comparisons between Vizro and similar tools such as Dash and Streamlit. In many ways a direct comparison is not possible as these products tackle somewhat different use cases and their relative pros and cons change depending on the particular requirements of each different user.</p> <p>Any attempt at a high-level explanation must rely on an oversimplification that misses many important nuances. With the caveat that it's not possible to \"compare apples with pears\", and that any comparison will have a different conclusion for different users, an oversimplified view could be:</p> Streamlit is great for rapid prototyping <ul> <li>rapid prototyping - Streamlit's architecture allows you to write apps the same way you write plain Python scripts. To unlock this, Streamlit apps have a unique data flow: any time something must be updated on the screen, Streamlit reruns your entire Python script from top to bottom. [1] This turns data scripts into sharable web apps in minutes. [2] Adding a widget is the same as declaring a variable. (No need to write a backend, define routes, handle HTTP requests, connect a frontend, write HTML, CSS, JavaScript, etc. [3])</li> </ul> Dash is great for customization and scalability <ul> <li>customization - one of the great things about Dash is that it is built on top of React.js, a JavaScript library for building web components. Thousands of components have been built and released with open source licenses by the React community, any of which could be adapted into a Dash component. [4] Dash supports adding custom CSS [5] and HTML, callbacks for custom behavior, and many component libraries such as Dash Bootstrap components [6]</li> <li>scalability - based on Flask which is widely adopted by the Python community and deployed in production environments everywhere [7] Dash was designed to be a stateless framework. Stateless frameworks are more scalable and robust [8]</li> </ul> Vizro is great for combining rapid prototyping with customization and scalability <ul> <li>rapid prototyping - since Vizro is a high-level framework providing declarative configuration, it is quick and easy to create powerful interactive apps in minutes, without needing to write callbacks, HTML, CSS, or JavaScript. Key topics such as applying state management, application architecture, and testing are done automatically by Vizro.</li> <li>customization and scalability - since Vizro is built on top of Dash, then users benefit from all the underlying power of the Dash framework for customization and scalability</li> <li>beauty and robustness - since Vizro uses inbuilt visual design and software development best practices, it automatically generates dashboards which look beautiful and can go from prototype to production quickly and easily</li> </ul> <p>All are great entry points to the world of data apps. If you prefer a top-down scripting style, then Streamlit is a powerful approach. If you prefer full control and customization over callbacks and layouts, then Dash is a powerful approach. If you prefer a configuration approach with in-built best practices, and the potential for customization and scalability through Dash, then Vizro is a powerful approach.</p> <p>For a more detailed comparison, it may help to read introductory articles about Dash, Streamlit and Vizro, to see how each tool serves a distinct purpose.</p>","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#how-does-vizro-compare-with-python-packages-and-business-intelligence-bi-tools","level":2,"title":"How does Vizro compare with Python packages and business intelligence (BI) tools?","text":"<p>There are a number of Python packages and BI tools which offer support for visualization applications (such as Streamlit, Plotly/Dash, Tableau and PowerBI).</p> <p>Vizro is intended to support several niches between the benefits from those tools, rather than being in direct comparison with any single tool. Therefore, direct comparisons are often only partially suitable, given the many features offered across this landscape.</p> <p>However, in general, there are several areas of functionality where Vizro can be particularly useful, such as in providing a simple configuration to speed up the assembly of components, leveraging inbuilt visual design, application architecture, and coding standards, along with the ability to scale easily across multiple developers and implementations.</p> See more details Functionality Benefits In context of Python packages In context of BI tools Assembly system <ul><li>Configuration-driven assembly system of Vizro automatically builds user-friendly, higher-level dashboard concepts (such as a filter) from low-level individual components (for example, a dropdown component plus a filtering function).</li></ul> <ul><li>Removes the need for users to learn how to write the “glue code” which combines lower-level components.</li><li>Removes the time taken to write, test and optimize the “glue code” which combines lower-level components.</li><li>Reduces what can be 1000s of lines of code down to dozens of lines of configuration.</li></ul> Many Python packages still require a moderate understanding of the coding required to assemble higher-level dashboard concepts, which necessitates the creation of “glue code” to combine lower-level components.  Vizro primarily offers configuration to simplify that assembly of components offered by existing packages (currently leveraging Plotly/Dash), and so occupies a slightly different niche from libraries offering primarily the lower-level components themselves. It also removes the requirement from users to implement certain code standards for the assembled code themselves, and therefore saves time on often time consuming things such as writing unit tests and ensuring linting coverage. Many BI tools incorporate the assembly of higher-level concepts automatically from GUI (drop-and-drag) interfaces, and occupy a slightly different niche to the configuration driven assembly offered by Vizro. Inbuilt visual design decisions <ul><li>UX decisions such as placement of filters and orientation of charts in relation to other components on the screen.</li><li>Visual design decisions such as chart formatting and spacing between components.</li><li>Colors including text, backgrounds and chart contents.</li></ul> <ul><li>Ensures visual consistency within applications, and across applications built by the same user.</li><li>Speeds up development by removing the need to spend time on visual design decisions.</li><li>Removes the need for advanced expertise in visual design.</li><li>Ensures basic color accessibility for most likely color combinations.</li></ul> Many Python packages offer inbuilt color choices, and visual design choices for certain components.  Vizro applies that to a wide range of component combinations and complex user flows, offering a holistic and comprehensive approach to automatically enable beautiful visual design best practices, whilst allowing customization and flexibility. Many BI tools supply inbuilt color choices and visual design choices for certain components.  Vizro offers inbuilt visual design for components in addition to the ability to customize them in a flexible way where needed (for example through CSS), and automatic arrangement of components on the screen. Inbuilt application architecture decisions <ul><li>The architectural decisions required to connect components in advanced ways - such as combining connecting filters to charts with multi-screen navigation to allow drill-throughs between screens.</li></ul> <ul><li>Ensures structural consistency within applications, and across applications built by the same user.</li><li>Speeds up development by removing the need to spend time on architectural decisions or development.</li><li>Removes need for advanced expertise in application architecture.</li></ul> Many Python packages supply inbuilt application architecture choices for certain functionalities.  Vizro applies that to a wide range of component combinations and complex user flows, offering a holistic and comprehensive approach to the entire application architecture, whilst allowing customization and flexibility where relevant. Many BI tools apply proprietary application architecture by default.  Vizro enables the user to view and understand the application architecture by directly viewing the code. Declarative configuration, in multiple formats <ul><li>Configuration is declarative and can be written in Python or a configuration language such as YAML, JSON and TOML.</li></ul> <ul><li>The range of formats enables flexibility in implementations (and can be extended in future).</li><li> Formats such as YAML support programmatic construction of dashboards (for example being dynamically generated from a Kedro pipeline).</li><li>The focus on editing configuration directly, rather than via GUI or drop-and-drag interfaces, allows for ease of collaboration.</li></ul> Many Python packages give a mostly declarative configuration, with limited ability to leverage multiple formats such as Pydantic models and JSON.  Vizro simplifies this approach, and facilitates the extension of the assembly system to enable integration with other tools such as Kedro to programmatically and dynamically generate the relevant dashboard configurations in a streamlined way. Many BI tools solely use a GUI and/or drag-and-drop interface for defining dashboards, and leverage proprietary configuration formats.  Vizro enables the user to view and understand the configuration by viewing it directly, in addition to being able to edit it directly. Mostly tech agnostic “grammar of dashboards” <ul><li>The configuration follows a “grammar of dashboards” which is mostly generic and tech agnostic (rather than being specific to any Python package or coding language).</li></ul> <ul><li>Enables a more intuitive understanding of how to write the configuration.</li><li>Enables the configuration to apply to other Python packages or other coding languages in future. (NB: this would require an adjustment to the underlying assembly core code).</li></ul> Many Python packages supply an effective “grammar of charts” and Python specific declaration.  Vizro offers a “grammar of dashboards” with declaration which is largely tech agnostic and can be extended to non-Python languages. Many BI tools utilize an implicit internal “grammar of dashboards” which is specific to the proprietary language(s) on with which they are built.  Vizro offers an explicit configuration grammar and allows users to leverage a mostly tech agnostic approach (which can be extended in future). Inbuilt validation <ul><li>The ability to leverage Pydantic models automatically give meaningful feedback to users about configuration choices.</li></ul> <ul><li>Increases ease of use by guiding users, providing early validation and clear feedback throughout the configuration process.</li><li>This validation feedback can also be utilized by processes which construct the configuration programmatically, such as via a Kedro pipeline.</li></ul> Many Python packages supply individual components or non-Pydantic based models.  Vizro offers the advantages of Pydantic based models for many elements of the configuration process, which leverages the validation and guidance inherent in that process to facilitate implementation by users. Many BI tools have inbuilt guideline systems to ensure components are combined in a valid way, and give feedback to the manual user to help guide through that process.  Vizro utilizes a flexible system which can be extended to give feedback to programmatic generation of configuration. Modularity <ul><li>The standardization applied by Vizro (in terms of visual design, application architecture and coding standards) makes it possible to reuse configuration, charts, components and extensions such as custom actions, between implementations.</li></ul> <ul><li>Speeds up development by allowing reuse of existing implementations.</li><li>Facilitates collaboration between users by allowing knowledge to be encoded in modular ways.</li></ul> Many Python packages support modularity of components such as charts and controls.  Vizro supports modularity of groups of components (such as their implementation together as a dashboard screen), which can be easily transferred between implementations as configuration. Many BI tools supply extensions and plugins which support modularity of visualizations.  Vizro supports modularity of groups of components (such as their implementation together as a dashboard screen), which can be easily transferred between implementations as configuration. Flexibility <ul><li>The ability to utilize the low-code approach of configuration with the high-code approach of custom functions offers flexibility in implementation for both less technical and more technical users.</li></ul> <ul><li>The low-code configuration driven approach enables all users to create fairly flexible dashboards easily.</li><li>The high-code approach of using custom functions in a structured way gives more technical users with flexibility to extend functionality almost infinitely.</li></ul> Many Python packages offer some low-code and/or high-code approaches, which offer varying degrees of flexibility.  Vizro supports a holistic combination of low-code and high-code approaches which support less technical and more technical users individually while allowing them much flexibility in implementation according to their technical level. Many BI tools offer a no-code (or at least low-code) approach to creating charts and dashboards, along with varying forms of plugins to increase flexibility.  Vizro unlocks Python custom functions to be able to power this user driven flexibility in a technically advanced way, with a high degree of control and visibility over the code, whilst also supporting less technical users through low-code configuration. Scaling <ul><li>The consistency in visual design, application architecture and code standards, combined with the ease of collaboration between Python developers, allows scaling within and between projects by facilitating reuse, extension and programmatic updates of configurations.</li></ul> <ul><li>Sections of configuration can be reused and tailored easily, allowing implementations to scale across or between projects.</li><li>New joiners to a team can get up to speed quickly, allowing teams to scale in size.</li><li>Other teams can inherit configurations easily, allowing implementations to scale between teams.</li><li>Updates can be propagated to configurations from a central location, allowing adjustments and updates to scale easily across large implementations.</li><li>Inbuilt visual design decisions offer visual consistency.</li><li>Leveraging collaborative coding mechanisms such as Git enables almost any number of developers to collaborate effectively.</li></ul> Many Python packages benefit from the ability to propagate updates programmatically, while applying that to “glue code”.  Vizro makes it easy to scale by replicating the relatively small amount of configuration in 1 file between usages, rather than replicating a large amount of code across many files between usages.  Updating configuration programmatically from a central location is often easier than updating code. When sharing between users, it can be easier to inherit and understand configuration than the underlying code. The visual consistency makes it easier to scale within or between projects while maintaining visual coherence. Many BI tools allow scaling through GUI drag-and-drop interfaces (having some functionality for duplication or propagating changes) for single users.  Vizro makes it easy to leverage tools such as Git to enable almost any number of users to collaborate effectively, therefore allowing the number of developers on a single project to scale easily.  Since updates can be propagated programmatically easily from a central location, it allows scaling across almost any number of related implementations which can be kept up to date and aligned without the need to manually adjust each implementation when updates are required. Python first <ul><li>Leveraging Pydantic and Plotly/Dash give a Python first approach (whilst making use of a mostly tech agnostic configuration system).</li><li>(Since Plotly/Dash leverage React components, and allow them to be used as components, then JavaScript can also be used in a form that is effectively wrapped in Python).</li></ul> <ul><li>This empowers a wider group of practitioners that are already close to data analytics, since they are more likely to have existing skills in Python than JavaScript.</li><li>This offers the advantage of leveraging existing Python work spaces such as notebooks and IDEs.</li><li>Facilitates multi-developer collaboration via tools such as Git.</li></ul> Python packages are already Python focused.  Vizro is no different in this respect. By leveraging Plotly/Dash, Vizro is also able to benefit from the power and flexibility offered by JavaScript via React, whilst still presenting a format that is Python first to the user (by making use of the ability offered by Dash to effectively wrap those components into Python). Many BI tools do not offer direct or full integration with Python.  Vizro supports a Python first approach which leverages the power and flexibility of Python, and the open source community supporting that wide ranging functionality. Open source <ul><li>The use of an open source license, and the reliance on open source packages.</li><li>The provision of ongoing development and maintenance.</li></ul> <ul><li>There is no license fee required to utilize Vizro.</li><li>Ongoing development and maintenance increases the long term usability of the Vizro package, and viability of implementations.</li></ul> Many Python packages also use an open source license, and offer ongoing development and maintenance.  Vizro is no different in this respect. Many BI tools follow a license fee model and/or charge for ongoing development and maintenance.  Vizro requires no license fee, and offers ongoing development and support, which helps to remove some barriers to usage.","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#when-would-an-alternative-to-vizro-be-more-suitable","level":2,"title":"When would an alternative to Vizro be more suitable?","text":"<p>There are a number of cases where alternatives to Vizro may be more suitable, including:</p> <ul> <li> <p>where BI tools are already in heavy use and working well, and/or Python developers are not prevalent</p> </li> <li> <p>where development teams already contain designers and JavaScript (or equivalent) engineers with bandwidth to build bespoke applications (though Vizro can sometimes still be used effectively to rapidly prototype potential solutions)</p> </li> <li> <p>where Python developers are already very comfortable leveraging other Python packages</p> </li> </ul>","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#what-license-is-vizro-open-sourced-under","level":2,"title":"What license is Vizro open sourced under?","text":"<p>Vizro is open sourced under the Apache License, Version 2.0. We have a page of documentation if you want to contribute to Vizro.</p>","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#how-can-i-report-a-bug","level":2,"title":"How can I report a bug?","text":"<p>Head over to our GitHub issues and create a new bug report. We will try to reproduce the bug you've reported and follow up with the next steps.</p>","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#where-can-i-find-the-roadmap-for-vizro","level":2,"title":"Where can I find the roadmap for Vizro?","text":"<p>We keep the roadmap for Vizro on our GitHub repository.</p>","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#how-can-i-request-a-feature","level":2,"title":"How can I request a feature?","text":"<p>To raise a feature request, head to our GitHub issues and create a new feature request. The team will then try to understand the request in more detail, explore the feasibility and prioritize it in relation to the current roadmap. We will get back to you as soon as possible with an estimate of whether and when this feature could be released.</p>","path":["FAQs"],"tags":[]},{"location":"explanation/faq/#i-still-have-a-question-where-can-i-ask-it","level":2,"title":"I still have a question. Where can I ask it?","text":"<p>We are happy to receive general questions around Vizro. Take a look at our GitHub issues and create a new issue by clicking \"General question\".</p> <p>Several Vizro team members are active on the Plotly Community Forum. If you'd like to also ask your question there then create a topic in the Dash Python category and make it clear that your question concerns Vizro.</p>","path":["FAQs"],"tags":[]},{"location":"explanation/schema/","level":1,"title":"Vizro schema and grammar of dashboards","text":"<p>This page explains the Vizro JSON schema, which is our attempt to create a \"grammar of dashboards\", and the role of Pydantic.</p>","path":["Vizro schema and grammar of dashboards"],"tags":[]},{"location":"explanation/schema/#what-is-a-json-schema","level":2,"title":"What is a JSON schema?","text":"<p>This is a short introduction since there are many good articles to answer the question, \"What is a JSON schema?\".</p> <p>A JSON schema defines the rules, structure, and constraints that JSON data (a popular data format, used widely on the web) should follow. Use of a schema leaves minimal room for assumptions and makes it easier to predict the nature and behavior of JSON data.</p> <p>An example of a JSON schema would be:</p> <pre><code>{\n  \"properties\": {\n    \"A\": {\n      \"title\": \"A\",\n      \"type\": \"integer\"\n    },\n    \"B\": {\n      \"items\": {\n        \"type\": \"string\"\n      },\n      \"title\": \"B\",\n      \"type\": \"array\"\n    }\n  },\n  \"required\": [\n    \"A\",\n    \"B\"\n  ],\n  \"title\": \"Example\",\n  \"type\": \"object\"\n}\n</code></pre> <p>This schema tells us that whenever we receive JSON data, and want to check whether it is valid, the data needs to contain two fields - a field <code>A</code>, which must be a single integer, and a field <code>B</code>, which must be an array of strings. Both fields must be provided, as they are both required.</p> <p>In practice this means that data can be identified as valid or invalid:</p> validinvalid (<code>B</code> is not an array of strings)also invalid (required field <code>B</code> is missing) <pre><code>{\n  \"A\": 1,\n  \"B\": [\n    \"a\",\n    \"b\"\n  ]\n}\n</code></pre> <pre><code>{\n  \"A\": 1,\n  \"B\": [\n    \"a\",\n    3\n  ]\n}\n</code></pre> <pre><code>{\n  \"A\": 1\n}\n</code></pre>","path":["Vizro schema and grammar of dashboards"],"tags":[]},{"location":"explanation/schema/#what-is-the-vizro-json-schema","level":2,"title":"What is the Vizro JSON schema?","text":"<p>Similar to the above example, the Vizro framework also has a JSON schema. It can be found in our GitHub repository. It is more complicated than the simple schema above, but it generally follows the same principle.</p> <p>To get a feeling of what it generally looks like, we have provided a simplified schema below. Reading through it shows us for example that every dashboards needs to have a set of pages, which in turn must have components, but optionally can have controls.</p> Simplified Vizro JSON schema <pre><code>{\n  \"$defs\": {\n    \"Page\": {\n      \"properties\": {\n        \"title\": {\n          \"title\": \"Title\",\n          \"type\": \"string\"\n        },\n        \"components\": {\n          \"items\": {\n            \"enum\": [\n              \"Card\",\n              \"Button\",\n              \"Container\",\n              \"Graph\",\n              \"Table\",\n              \"AgGrid\"\n            ],\n            \"type\": \"string\"\n          },\n          \"title\": \"Components\",\n          \"type\": \"array\"\n        },\n        \"controls\": {\n          \"anyOf\": [\n            {\n              \"items\": {\n                \"enum\": [\n                  \"Filter\",\n                  \"Parameter\"\n                ],\n                \"type\": \"string\"\n              },\n              \"type\": \"array\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"title\": \"Controls\"\n        }\n      },\n      \"required\": [\n        \"title\",\n        \"components\"\n      ],\n      \"title\": \"Page\",\n      \"type\": \"object\"\n    }\n  },\n  \"properties\": {\n    \"title\": {\n      \"title\": \"Title\",\n      \"type\": \"string\"\n    },\n    \"pages\": {\n      \"items\": {\n        \"$ref\": \"#/$defs/Page\"\n      },\n      \"title\": \"Pages\",\n      \"type\": \"array\"\n    },\n    \"theme\": {\n      \"enum\": [\n        \"vizro_dark\",\n        \"vizro_light\"\n      ],\n      \"title\": \"Theme\",\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"title\",\n    \"pages\",\n    \"theme\"\n  ],\n  \"title\": \"Dashboard\",\n  \"type\": \"object\"\n}\n</code></pre> <p>You can thus configure a Vizro dashboard according to a set of constraints that are defined in the schema. The configuration language that you choose is secondary: it can be via Python, but also via JSON or YAML. This is shown in our showcase of configuration options.</p> This JSON...maps to this Dashboard... but would fail here (Dashboard title missing) <pre><code>{\n  \"pages\": [\n    {\n      \"components\": [\n        {\n          \"figure\": {\n            \"_target_\": \"scatter\",\n            \"color\": \"species\",\n            \"data_frame\": \"iris\",\n            \"x\": \"sepal_length\",\n            \"y\": \"petal_width\"\n          },\n          \"type\": \"graph\"\n        },\n        {\n          \"figure\": {\n            \"_target_\": \"histogram\",\n            \"color\": \"species\",\n            \"data_frame\": \"iris\",\n            \"x\": \"sepal_width\"\n          },\n          \"type\": \"graph\"\n        }\n      ],\n      \"controls\": [\n        {\n          \"column\": \"species\",\n          \"type\": \"filter\"\n        }\n      ],\n      \"title\": \"My first dashboard\"\n    }\n  ]\n}\n</code></pre> <p></p> <pre><code>{\n  \"pages\": [\n    {\n      \"components\": [\n        {\n          \"figure\": {\n            \"_target_\": \"scatter\",\n            \"color\": \"species\",\n            \"data_frame\": \"iris\",\n            \"x\": \"sepal_length\",\n            \"y\": \"petal_width\"\n          },\n          \"type\": \"graph\"\n        },\n        {\n          \"figure\": {\n            \"_target_\": \"histogram\",\n            \"color\": \"species\",\n            \"data_frame\": \"iris\",\n            \"x\": \"sepal_width\"\n          },\n          \"type\": \"graph\"\n        }\n      ],\n      \"controls\": [\n        {\n          \"column\": \"species\",\n          \"type\": \"filter\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <p>Note</p> <p>The Vizro schema is still incomplete. This means that it does not yet define everything that we consider to be core and supported functionality of Vizro. The most prominent example of an omission is the [<code>CapturedCallable</code>][vizro.models.types.CapturedCallable], which are the objects you insert into many models such as <code>vm.Graph</code>, <code>vm.Table</code> or <code>vm.Action</code>, often into the <code>figure</code> argument.</p> <p>This does not mean that it cannot be configured in JSON. In fact, in the configuration above, we have used the following JSON:</p> <pre><code>{\n  \"figure\": {\n    \"_target_\": \"histogram\",\n    \"color\": \"species\",\n    \"data_frame\": \"iris\",\n    \"x\": \"sepal_width\"\n  },\n  \"type\": \"graph\"\n}\n</code></pre> <p>It means that <code>figure</code> does not appear in the schema so, as such, it is not clearly defined as part of the Vizro framework, although it should be considered as such. We are working to complete the Vizro schema in the future.</p>","path":["Vizro schema and grammar of dashboards"],"tags":[]},{"location":"explanation/schema/#the-role-of-pydantic","level":2,"title":"The role of Pydantic","text":"<p>The Vizro framework is powered by Pydantic, which is the most widely used data validation library for Python. Pydantic acts as the glue that connects Vizro's JSON schema to its actual implementation - a React frontend served by a Flask backend, facilitated by Dash.</p> <p>One core advantage of Pydantic is that it can automatically produce a JSON schema from our models (such as <code>vm.Page</code> or <code>vm.Filter</code>). Pydantic also supports custom validation beyond the functionality of JSON schema.</p> <p>For our toy example above, instead of defining the JSON schema directly, we could produce it via Pydantic, using the following Python code:</p> <pre><code>import json\nimport pydantic\n\n\nclass Example(pydantic.BaseModel):\n    A: int\n    B: list[str]\n\n\nprint(json.dumps(Example.model_json_schema(), indent=2))\n</code></pre> <p>The above example shows that Pydantic makes it very easy to produce JSON schemas by using just Python classes and type annotations. The rest is taken care of by Pydantic.</p> <p>But Pydantic allows us to go beyond the usual constraints that a JSON schema allows. In our toy example above, with the help of Pydantic, we could define that all string elements in <code>B</code> need to start with either <code>a</code> or <code>b</code>.</p> <pre><code>import json\nimport pydantic\n\n\nclass Example(pydantic.BaseModel):\n    A: int\n    B: list[str]\n\n    @pydantic.field_validator(\"B\")\n    @classmethod\n    def validate_b_strings(cls, v: list[str]) -&gt; list[str]:\n        for string in v:\n            if not string.startswith((\"a\", \"b\")):\n                raise ValueError(\"All strings in B must start with either 'a' or 'b'\")\n        return v\n</code></pre> <p>This is a fairly random example, but it illustrates the power of custom validation for anyone using the Vizro framework. Most of the time when the user \"misconfigures\", the error message is clear and concise.</p> <p>In the toy example, this would have the following consequences:</p> Providing this JSON config...... would get rejected (<code>c</code> doesn't start with <code>a</code> or <code>b</code>) <pre><code>{\n  \"A\": 1,\n  \"B\": [\n    \"a\",\n    \"b\",\n    \"c\"\n  ]\n}\n</code></pre> <pre><code>pydantic_core._pydantic_core.ValidationError: 1 validation error for Example\nB\n  Value error, All strings in B must start with either 'a' or 'b' [type=value_error, input_value=['a', 'b', 'c'], input_type=list]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error\n</code></pre> <p>With the help of Pydantic, we were able to define a custom validation beyond the limits of JSON schema.</p>","path":["Vizro schema and grammar of dashboards"],"tags":[]},{"location":"explanation/schema/#the-grammar-of-dashboards","level":2,"title":"The grammar of dashboards","text":"<p>How does this all come together? One of the long-term goals of Vizro is to define a so-called grammar of dashboards. This means that we complete the Vizro schema and define a unified, implementation independent language to configure dashboards. Other notable \"grammars\" in the area of visualization are for example the Plotly Chart schema or the Vega-Lite grammar of interactive graphics.</p> <p>At the moment, the Vizro framework serves Dash apps — but this is not a necessary condition. In principle, the mapping of JSON to app could be realized using other technologies.</p>","path":["Vizro schema and grammar of dashboards"],"tags":[]},{"location":"explanation/schema/#the-role-of-extra","level":2,"title":"The role of <code>extra</code>","text":"<p>Some of our models, e.g. the <code>Container</code>, have an argument called <code>extra</code>. This argument enables the user to pass extra arguments directly to the underlying component of the model. In the case of the <code>Container</code>, this would be the <code>dbc.Container</code>.</p> <p>This is clearly implementation specific and, as such, the <code>extra</code> argument is (on purpose) excluded from the Vizro schema. The argument helps users to get the maximum flexibility quickly without having to go beyond the Vizro framework, but it should not be assumed to be a core part of Vizro. Using this argument may break your code in future releases of Vizro, although this is very unlikely in the foreseeable future.</p>","path":["Vizro schema and grammar of dashboards"],"tags":[]},{"location":"explanation/your-examples/","level":1,"title":"Examples from Vizro users","text":"<p>This page lists videos, blog posts, and examples of Vizro usage in repositories on GitHub. We've curated the list so it is a snapshot of the best projects and content that Vizro users have created.</p> <p>If you have something you'd like us to include on the list, or spot something that we should include, let us know:</p> <ul> <li>you can raise an issue on the Vizro repository,</li> <li>better still, you can make a PR to contribute to this page.</li> </ul> <p>Note</p> <p>The Vizro team and QuantumBlack, AI by McKinsey, do not take responsibility for third party content. In curating the list below, we may inspect or test an example at time of inclusion, but cannot guarantee the content thereafter.</p>","path":["Examples from Vizro users"],"tags":[]},{"location":"explanation/your-examples/#videos","level":2,"title":"Videos","text":"<ul> <li>From Charming Data on YouTube:<ul> <li>Build Python Data Apps with Vizro Dash.</li> <li>Introduction to Vizro Actions - Plotly Dash.</li> <li>Use Dash AG Grid within a Vizro app.</li> <li>Visual Vocabulary Dashboard showcasing charting options in Vizro and Plotly.</li> </ul> </li> </ul>","path":["Examples from Vizro users"],"tags":[]},{"location":"explanation/your-examples/#blog-posts","level":2,"title":"Blog posts","text":"<ul> <li>Introducing Vizro.</li> <li>Creating Custom Dashboards with Vizro: A Comprehensive Guide.</li> </ul> <ul> <li>I built a reusable dashboard read-the-docs traffic analytics using vizro.</li> </ul> <ul> <li>Visualizing data science insights.</li> </ul> <ul> <li>A low-code, attractive, sharable data dashboard: Illustrating my LinkedIn connections in 100 lines of Python.</li> </ul>","path":["Examples from Vizro users"],"tags":[]},{"location":"explanation/your-examples/#examples-on-github-or-pycafe","level":2,"title":"Examples on GitHub or PyCafe","text":"<ul> <li>Personal Vizro app demos by Vizro team member <code>huong-li-nguyen</code>.</li> <li>Proof of concept example by <code>viiviandias</code>.</li> <li>Amazon sales analysis by <code>Bottleneck44</code>.</li> <li>Insight-AI: Chart and business insight generation by <code>micky091</code> using vizro-ai</li> <li>Music trend analysis using Vizro by <code>KhushaliP</code></li> </ul>","path":["Examples from Vizro users"],"tags":[]},{"location":"tutorials/custom-actions-tutorial/","level":1,"title":"Write your own actions","text":"<p>Actions control how your app responds to user input such as clicking a button or a point on a graph. Vizro provides built-in actions and also enables you to write your own custom actions. In this tutorial you will learn how to write your own custom actions.</p> <p>Note</p> <p>This tutorial assumes a basic knowledge of Vizro. If you haven't already done so, you should get started with Vizro in the quickstart tutorial or work through a more in-depth tutorial.</p> <p>Vizro's actions are built on top of Dash callbacks, but you do not need to know anything about Dash callbacks to complete the tutorial. We also have an explanation of how Vizro actions work and their similarities and differences compared to Dash callbacks.</p> <p>This tutorial should take about an hour to finish. You will gradually build a single-page app of a simple form that uses custom actions to show the current time, date and weather in Washington, D.C. or Berlin. Here's the final app in action:</p> <p></p>","path":["Write your own actions"],"tags":[]},{"location":"tutorials/custom-actions-tutorial/#a-simple-action","level":2,"title":"A simple action","text":"<p>Let's start by making a very simple single-page app that tells us the current time when the user clicks on a button. We begin by configuring the layout: a button and a card with text in a flex layout.</p> <p>App layout</p> app.pyResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\n\npage = vm.Page(\n    title=\"My first action\",\n    layout=vm.Flex(),\n    components=[\n        vm.Button(),\n        vm.Card(text=\"Click the button\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <p></p> <p>We have specified that a button should be included in the page layout but haven't configured what should happen when it is clicked. Let's define an action for that and attach it to the button with the <code>actions</code> argument and the [<code>Action</code>][vizro.models.Action] model.</p> <p>A simple action</p> app.pyResult <pre><code>from datetime import datetime, timezone\n\nimport vizro.models as vm\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\n\n@capture(\"action\")  # (1)!\ndef update_card():  # (2)!\n    time_format = \"%H:%M:%S %Z\"\n    now = datetime.now(timezone.utc)\n    time = now.strftime(time_format)\n    return f\"🕰️ The time is {time}\"  # (3)!\n\n\npage = vm.Page(\n    title=\"My first action\",\n    layout=vm.Flex(),\n    components=[\n        vm.Button(\n            actions=vm.Action(  # (4)!\n                function=update_card(),\n                outputs=\"time_card\",\n            )\n        ),\n        vm.Card(id=\"time_card\", text=\"Click the button\"),  # (5)!\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>You can write a simple action using the <code>capture(\"action\")</code> decorator. This prepares a function to be used as a Vizro action.</li> <li>For now, the <code>update_card</code> function has no arguments.</li> <li>An action doesn't need to have outputs, but this one returns a string. An action can return values of any Python type that can be converted to JSON.</li> <li>We attach the action to the <code>vm.Button</code> model using the <code>actions</code> argument. We call the action function with <code>function=update_card()</code> (remember the <code>()</code>) and set the output to <code>\"time_card\"</code>.</li> <li>To use the <code>vm.Card</code> as an output, we supply <code>id=\"time_card\"</code> that matches onto the action's <code>outputs</code>. It does not matter that this component is defined after the <code>vm.Action</code> that uses it.</li> </ol> <p></p> <p>Congratulations on writing your first action! Before clicking the button, the card's text is \"Click the button\". When you click the button, the <code>update_card</code> action is triggered. This Python function executes on the server to find the current time in the UTC timezone and return a string \"The time is ...\". The resulting value is sent back to the user's screen and updates the text of the component with <code>id=\"time_card\"</code>. This is the action's output.</p> <p>As we cover increasingly complex actions, it can be very helpful to understand the actions using a flowchart similar to Dash dev tools' callback graph. We can visualize the above example as follows:</p> <pre><code>graph TD\n  submit_button == trigger ==&gt; update_card([update_card]) -- output --&gt; time_card</code></pre> <p>In this flowchart, the rectangular boxes refer to Vizro models that are used as a trigger and output for an action. The action function is shown in a round box, and we use a thick line for the trigger.</p>","path":["Write your own actions"],"tags":[]},{"location":"tutorials/custom-actions-tutorial/#runtime-input","level":2,"title":"Runtime input","text":"<p>Let's extend our action to depend on an input from the user's screen. As before, let's start by adding something to the layout and then handle the action. Here we create a small form by adding a [<code>Switch</code>][vizro.models.Switch] to the layout that lets the user specify whether they would like to use the 12- or 24-hour clock.</p> <p>Add <code>Switch</code> to layout</p> app.pyResult <pre><code>from datetime import datetime, timezone\n\nimport vizro.models as vm\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\n\n@capture(\"action\")\ndef update_card():\n    time_format = \"%H:%M:%S %Z\"\n    now = datetime.now(timezone.utc)\n    time = now.strftime(time_format)\n    return f\"🕰️ The time is {time}\"\n\n\nvm.Container.add_type(\"components\", vm.Switch)  # (1)!\n\npage = vm.Page(\n    title=\"My first action\",\n    layout=vm.Flex(),\n    components=[\n        vm.Container(  # (2)!\n            layout=vm.Flex(direction=\"row\"),\n            variant=\"outlined\",\n            components=[\n                vm.Switch(id=\"clock_switch\", title=\"24-hour clock\", value=True),\n                vm.Button(\n                    actions=vm.Action(\n                        function=update_card(),\n                        outputs=\"time_card\",\n                    ),\n                ),\n            ],\n        ),\n        vm.Card(id=\"time_card\", text=\"Click the button\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>Currently [<code>Switch</code>][vizro.models.Switch] is designed to be used as a control selector. In future, Vizro will have a dedicated <code>Form</code> model for the creation of forms. For now, we add them directly as <code>components</code> inside a [<code>Container</code>][vizro.models.Container]. For this to be a valid configuration we must first do <code>add_type</code> as for a custom component.</li> <li>We group the form inputs into a styled container to achieve some visual separation of the form inputs and outputs. This is purely stylistic and does not affect the operation of actions.</li> </ol> <p></p> <p>Now we need to connect <code>vm.Switch(id=\"clock_switch\")</code> to our <code>update_card</code> action. We add an argument <code>use_24_hour_clock</code> to the <code>update_card</code> function and configure the function call in <code>vm.Action</code> to use the <code>clock_switch</code> component as the input value of this argument.</p> <p>Connect <code>Switch</code> to <code>update_card</code></p> app.pyResult <pre><code>from datetime import datetime, timezone\n\nimport vizro.models as vm\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\n\n@capture(\"action\")\ndef update_card(use_24_hour_clock):   # (1)!\n     time_format = \"%H:%M:%S %Z\" if use_24_hour_clock else \"%I:%M:%S %p %Z\"   # (2)!\n     now = datetime.now(timezone.utc)\n     time = now.strftime(time_format)\n     return f\"🕰️ The time is {time}\"\n\n\nvm.Container.add_type(\"components\", vm.Switch)\n\npage = vm.Page(\n     title=\"My first action\",\n     layout=vm.Flex(),\n     components=[\n         vm.Container(\n             layout=vm.Flex(direction=\"row\"),\n             variant=\"outlined\",\n             components=[\n                 vm.Switch(id=\"clock_switch\", title=\"24-hour clock\", value=True),\n                 vm.Button(\n                     actions=vm.Action(\n                         function=update_card(use_24_hour_clock=\"clock_switch\"),  # (3)!\n                         outputs=\"time_card\",\n                     ),\n                 ),\n             ],\n         ),\n         vm.Card(id=\"time_card\", text=\"Click the button\"),\n     ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We add an argument <code>use_24_hour_clock</code> to <code>update_card</code>. This will receive a boolean value <code>True</code> or <code>False</code>.</li> <li><code>time_format</code> now depends on the value of <code>use_24_hour_clock</code>.</li> <li>The argument <code>use_24_hour_clock</code> is set at runtime to the value of the <code>clock_switch</code> component. This will be <code>True</code> or <code>False</code> depending on whether the switch is toggled on or off. Here we use a keyword argument but, just like a normal Python function call, we could also use a positional argument as <code>update_card(\"clock_switch\")</code>.</li> </ol> <p></p> <p>Have a go at toggling the switch and clicking the button. You should find that the format of the time shown changes between 12- and 24-hour clock. Note that toggling the <code>clock_switch</code> does not by itself trigger <code>update_card</code>. The switch is used as a runtime input but the action is triggered only by clicking the button. In fact, this is a key principle governing Vizro actions: an action can have any number of inputs and outputs but only one trigger.</p> <p>Let's look at what the actions flowchart looks like. We now have a new model with <code>id=\"clock_switch\"</code> that is used as runtime input to the <code>update_card</code> action. We indicate runtime inputs using a dotted line.</p> <pre><code>graph TD\n  subgraph screen_1[\" \"]\n    clock_switch\n    submit_button\n  end\n\n  clock_switch -. runtime input .-&gt; update_card -- output --&gt; time_card\n  submit_button == trigger ==&gt; update_card([update_card])</code></pre> <p>Action inputs and outputs can be used in multiple actions; there can be any number of actions that use the same <code>clock_switch</code>, <code>submit_button</code> and <code>time_card</code> as inputs or outputs.</p>","path":["Write your own actions"],"tags":[]},{"location":"tutorials/custom-actions-tutorial/#multiple-inputs-and-outputs","level":2,"title":"Multiple inputs and outputs","text":"<p>Let's extend our example to handle multiple inputs and outputs. We add another card to show the date and a [<code>RadioItems</code>][vizro.models.RadioItems] to allow the user to configure the date format.</p> <p>Multiple inputs and outputs</p> app.pyResult <pre><code>from datetime import datetime, timezone\n\nimport vizro.models as vm\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\n\n@capture(\"action\")\ndef update_cards(use_24_hour_clock, date_format):  # (1)!\n     time_format = \"%H:%M:%S %Z\" if use_24_hour_clock else \"%I:%M:%S %p %Z\"\n     date_format = \"%d/%m/%y\" if date_format == \"DD/MM/YY\" else \"%m/%d/%y\"\n     now = datetime.now(timezone.utc)\n     time = now.strftime(time_format)\n     date = now.strftime(date_format)\n     return f\"🕰️ The time is {time}\", f\"📅 The date is {date}\"  # (2)!\n\n\nvm.Container.add_type(\"components\", vm.Switch)\nvm.Container.add_type(\"components\", vm.RadioItems)\n\npage = vm.Page(\n     title=\"My first action\",\n     layout=vm.Flex(),\n     components=[\n         vm.Container(\n             layout=vm.Flex(direction=\"row\"),\n             variant=\"outlined\",\n             components=[\n                 vm.Switch(id=\"clock_switch\", title=\"24-hour clock\", value=True),\n                 vm.RadioItems(id=\"date_radio_items\", options=[\"DD/MM/YY\", \"MM/DD/YY\"]),\n                 vm.Button(\n                     actions=vm.Action(\n                         function=update_cards(use_24_hour_clock=\"clock_switch\", date_format=\"date_radio_items\"),   # (3)!\n                         outputs=[\"time_card\", \"date_card\"],   # (4)!\n                     ),\n                 ),\n             ],\n         ),\n         vm.Card(id=\"time_card\", text=\"Click the button\"),\n         vm.Card(id=\"date_card\", text=\"Click the button\"),\n     ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We rename the function <code>update_cards</code> with an <code>s</code> and an argument <code>date_format</code>. This will receive a string value <code>\"DD/MM/YY\"</code> or <code>\"MM/DD/YY\"</code>.</li> <li>We now return two strings.</li> <li>The new argument <code>date_format</code> is set by <code>vm.RadioItems(date_radio_items)</code>.</li> <li>There are now two outputs: <code>time_card</code> and <code>date_card</code>.</li> </ol> <p></p> <p>Here's the updated actions flowchart. We now have two inputs and two outputs that are updated simultaneously when the <code>update_cards</code> action is triggered:</p> <pre><code>graph TD\n  subgraph screen_1[\" \"]\n    clock_switch\n    date_radio_items\n    submit_button\n  end\n\n  subgraph screen_2[\" \"]\n    time_card\n    date_card\n  end\n\n  clock_switch &amp; date_radio_items -. runtime input .-&gt; update_cards -- output --&gt; time_card &amp; date_card\n  submit_button == trigger ==&gt; update_cards([update_cards])\n</code></pre> <p>The returned values are matched to the <code>outputs</code> in order. If your action has many outputs then it can be a good idea to instead return a dictionary where returned values are labeled by string keys. In this case, <code>outputs</code> should also be a dictionary with matching keys, and the order of entries does not matter:</p> <pre><code>@capture(\"action\")\ndef update_cards(use_24_hour_clock, date_format):\n    ...\n    return {\"time_output\": f\"🕰️ The time is {time}\", \"date_output\": f\"📅 The date is {date}\"}\n\n...\n\nvm.Action(\n   function=update_cards(use_24_hour_clock=\"clock_switch\", date_format=\"date_radio_items\"),\n   outputs={\"time_output\": \"time_card\", \"date_output\": \"date_card\"},  # (1)!\n)\n</code></pre> <ol> <li><code>outputs={\"date_output\": \"date_card\", \"time_output\": \"time_card\"}</code> would work exactly the same; the order of entries does not matter.</li> </ol>","path":["Write your own actions"],"tags":[]},{"location":"tutorials/custom-actions-tutorial/#actions-chains","level":2,"title":"Actions chains","text":"<p>Sometimes you need a single trigger to execute multiple actions. Vizro uses chains of actions to achieve this. There are two different ways to form an actions chain:</p> <ul> <li>Explicit actions chain. When you specify multiple actions as <code>actions=[action_1, action_2, ...]</code> then Vizro executes these actions in order, so that <code>action_2</code> executes only when <code>action_1</code> has completed.</li> <li>Implicit actions chain. When one action outputs a trigger of another action then the subsequent action is triggered automatically.</li> </ul> <p>Note</p> <p>In fact, the examples you have seen so far already contain action chains, just they have been chains with only one action in them. Behind the scenes, <code>actions=action</code> gets converted into <code>actions=[action]</code>, an action chains of length one.</p>","path":["Write your own actions"],"tags":[]},{"location":"tutorials/custom-actions-tutorial/#explicit-actions-chain","level":3,"title":"Explicit actions chain","text":"<p>Let's add some new functionality to our app that fetches the current weather in Berlin using the Open-Meteo weather API, which is free and does not require an API key. So far our actions have executed quick operations on the server. Making a request to an external API can be much slower. When the button is clicked, we perform the operation in two stages so that the user knows what is happening:</p> <ol> <li>Update cards on the screen to give the time and date, as before, but also give a temporary placeholder message to say that we're fetching the weather. This is done in the <code>update_cards</code> action.</li> <li>Request the Open-Meteo API and update the placeholder message to give the current temperature in Berlin. This is done in the <code>fetch_weather</code> action.</li> </ol> <p>We explicitly chain together these two actions when the button is clicked by specifying a list of <code>actions</code> as follows:</p> <pre><code>vm.Button(\n    actions=[\n        vm.Action(\n            function=update_cards(use_24_hour_clock=\"clock_switch\", date_format=\"date_radio_items\"),\n            outputs=[\"time_card\", \"date_card\", \"weather_card\"],\n        ),\n        vm.Action(function=fetch_weather(), outputs=\"weather_card\"),\n    ],\n)\n</code></pre> <p>The full code is shown below.</p> Explicit actions chain app.pyResult <pre><code>from datetime import datetime, timezone\n\nimport requests  # (1)!\nimport vizro.models as vm\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\n\n@capture(\"action\")\ndef update_cards(use_24_hour_clock, date_format):\n    time_format = \"%H:%M:%S %Z\" if use_24_hour_clock else \"%I:%M:%S %p %Z\"\n    date_format = \"%d/%m/%y\" if date_format == \"DD/MM/YY\" else \"%m/%d/%y\"\n    now = datetime.now(timezone.utc)\n    time = now.strftime(time_format)\n    date = now.strftime(date_format)\n    return f\"🕰️ The time is {time}\", f\"📅 The date is {date}\", \"Fetching current weather...\"  # (2)!\n\n\n@capture(\"action\")\ndef fetch_weather():  # (3)!\n    berlin_params = {\"latitude\": 52.5, \"longitude\": 13.4, \"current\": \"temperature_2m\"}\n    r = requests.get(\"https://api.open-meteo.com/v1/forecast\", params=berlin_params)\n    temperature = r.json()[\"current\"][\"temperature_2m\"]\n    return f\"The current temperature in Berlin is {temperature}°C\"\n\n\nvm.Container.add_type(\"components\", vm.Switch)\nvm.Container.add_type(\"components\", vm.RadioItems)\n\npage = vm.Page(\n    title=\"My first action\",\n    layout=vm.Flex(),\n    components=[\n        vm.Container(\n            layout=vm.Flex(direction=\"row\"),\n            variant=\"outlined\",\n            components=[\n                vm.Switch(id=\"clock_switch\", title=\"24-hour clock\", value=True),\n                vm.RadioItems(id=\"date_radio_items\", options=[\"DD/MM/YY\", \"MM/DD/YY\"]),\n                vm.Button(\n                    id=\"submit_button\",  # (4)!\n                    actions=[\n                        vm.Action(\n                            function=update_cards(use_24_hour_clock=\"clock_switch\", date_format=\"date_radio_items\"),\n                            outputs=[\"time_card\", \"date_card\", \"weather_card\"],\n                        ),\n                        vm.Action(function=fetch_weather(), outputs=\"weather_card\"),\n                    ],\n                ),\n            ],\n        ),\n        vm.Card(id=\"time_card\", text=\"Click the button\"),\n        vm.Card(id=\"date_card\", text=\"Click the button\"),\n        vm.Card(id=\"weather_card\", text=\"Click the button\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>Requests is a popular Python library for performing HTTP requests. It is a third party library but is a dependency of Dash and so should already be available without a <code>pip install</code>.</li> <li>This now return three strings. \"Fetching current weather...\" only shows on the screen briefly while the <code>fetch_weather</code> action is executing.</li> <li>We make a request to the Open-Meteo API to fetch the current temperature at the latitude and longitude of Berlin.</li> <li>We don't actually need to set <code>id=\"submit_button\"</code> yet but have added it in anticipation of the next section.</li> </ol> <p></p> <p>When you click the button, the <code>update_cards</code> action executes and sets the placeholder message \"Fetching current weather...\". When this action completes, the <code>fetch_weather</code> action executes to find the actual weather and update the message. The Open-Meteo API request generally completes very quickly and so \"Fetching current weather...\" will only flash on your screen very briefly. If you'd like to artificially slow down the <code>fetch_weather</code> action to see it more clearly then you can add <code>from time import sleep; sleep(3)</code> to the function body to add a delay of 3 seconds.</p> <p>The actions flowchart now has a new output <code>weather_card</code> and a new action <code>fetch_weather</code>. The trigger for this action is completion of the <code>update_cards</code> action. Note that both these actions share the same output <code>weather_card</code>. In Vizro, a model can be an input or output for any number of actions.</p> <pre><code>graph TD\n  subgraph screen_1[\" \"]\n    clock_switch\n    date_radio_items\n    submit_button\n  end\n\n  subgraph screen_2[\" \"]\n    time_card\n    date_card\n    weather_card\n  end\n\n  clock_switch &amp; date_radio_items -. runtime input .-&gt; update_cards -- output --&gt; time_card &amp; date_card &amp; weather_card\n  fetch_weather -- output --&gt; weather_card\n  submit_button == trigger ==&gt; update_cards\n  update_cards([update_cards]) == trigger ==&gt; fetch_weather([fetch_weather])</code></pre>","path":["Write your own actions"],"tags":[]},{"location":"tutorials/custom-actions-tutorial/#implicit-actions-chain","level":3,"title":"Implicit actions chain","text":"<p>Now we're going to re-work the example to demonstrate an implicit actions chain. Let's add a dropdown menu that allows the user to choose between seeing the weather in Washington, D.C. or in Berlin. When the user selects the city we also update the time and date shown to the format preferred by that location: for Washington, D.C., this is 12-hour clock and MM/DD/YY format; for Berlin, it is 24-hour clock and DD/MM/YY format.</p> <p>When the city is selected in the dropdown, we want to immediately update the cards without requiring the user to click <code>submit_button</code>. To achieve this, we write a new action <code>update_time_date_formats</code> triggered by the dropdown that outputs to <code>submit_button</code>.</p> <p>Implicit actions chain</p> app.pyResult <pre><code>from datetime import datetime, timezone\n\nimport requests\nimport vizro.models as vm\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\n\n@capture(\"action\")\ndef update_cards(use_24_hour_clock, date_format):\n    time_format = \"%H:%M:%S %Z\" if use_24_hour_clock else \"%I:%M:%S %p %Z\"\n    date_format = \"%d/%m/%y\" if date_format == \"DD/MM/YY\" else \"%m/%d/%y\"\n    now = datetime.now(timezone.utc)\n    time = now.strftime(time_format)\n    date = now.strftime(date_format)\n    return f\"🕰️ The time is {time}\", f\"📅 The date is {date}\", \"Fetching current weather...\"\n\n\n@capture(\"action\")\ndef fetch_weather(location):  # (1)!\n    berlin_params = {\"latitude\": 52.5, \"longitude\": 13.4, \"current\": \"temperature_2m\"}\n    washington_dc_params = {\"latitude\": 38.9, \"longitude\": -77.0, \"current\": \"temperature_2m\"}\n    params = berlin_params if location == \"Berlin\" else washington_dc_params\n    r = requests.get(\"https://api.open-meteo.com/v1/forecast\", params=params)\n    temperature = r.json()[\"current\"][\"temperature_2m\"]\n    return f\"🌡️ The current temperature in {location} is {temperature}°C\"\n\n\n@capture(\"action\")\ndef update_time_date_formats(location):  # (2)!\n    if location == \"Berlin\":\n        return True, \"DD/MM/YY\", 1  # (3)!\n    return False, \"MM/DD/YY\", 1\n\n\nvm.Container.add_type(\"components\", vm.Switch)\nvm.Container.add_type(\"components\", vm.RadioItems)\nvm.Container.add_type(\"components\", vm.Dropdown)\n\npage = vm.Page(\n    title=\"My first action\",\n    layout=vm.Flex(),\n    components=[\n        vm.Container(\n            layout=vm.Flex(direction=\"row\"),\n            variant=\"outlined\",\n            components=[\n                vm.Dropdown(\n                    id=\"location_dropdown\",\n                    options=[\"Berlin\", \"Washington, D.C.\"],\n                    multi=False,\n                    actions=vm.Action(\n                        function=update_time_date_formats(\"location_dropdown\"),\n                        outputs=[\"clock_switch\", \"date_radio_items\", \"submit_button\"],  # (4)!\n                    ),\n                    extra={\"style\": {\"min-width\": \"200px\"}},\n                ),\n                vm.Switch(id=\"clock_switch\", title=\"24-hour clock\", value=True),\n                vm.RadioItems(id=\"date_radio_items\", options=[\"DD/MM/YY\", \"MM/DD/YY\"]),\n                vm.Button(\n                    id=\"submit_button\",\n                    actions=[\n                        vm.Action(\n                            function=update_cards(use_24_hour_clock=\"clock_switch\", date_format=\"date_radio_items\"),\n                            outputs=[\"time_card\", \"date_card\", \"weather_card\"],\n                        ),\n                        vm.Action(function=fetch_weather(\"location_dropdown\"), outputs=\"weather_card\"),\n                    ],\n                ),\n            ],\n        ),\n        vm.Card(id=\"time_card\", text=\"Click the button\"),\n        vm.Card(id=\"date_card\", text=\"Click the button\"),\n        vm.Card(id=\"weather_card\", text=\"Click the button\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li><code>fetch_weather</code> has been updated to take in <code>location</code>. This chooses between Washington, D.C. and Berlin.</li> <li>When the location is Berlin, <code>update_time_date_formats</code> sets the app to use 24-hour clock and date format DD/MM/YY; otherwise, for Washington, D.C., we use 12-hour clock and date format MM/DD/YY.</li> <li>In both cases we return 1 to the third output, which is <code>vm.Button(id=\"submit_button\")</code>. This effectively tells Vizro that the button has been clicked 1 time in total. The choice of 1 is arbitrary and does not matter unless you need to keep track of the actual number of times the button has been clicked.</li> <li><code>update_time_date_formats</code> sets the <code>clock_switch</code> and <code>date_radio_items</code> form fields and also updates <code>submit_button</code>. This update of <code>submit_button</code> triggers the actions chain associated with the submit button.</li> </ol> <p></p> <p>Selecting a city in the dropdown triggers the <code>update_time_date_formats</code> action. When this action completes, Vizro automatically triggers the actions that would have been triggered by actually clicking <code>submit_button</code>. This forms an implicit connection between the <code>update_time_date_formats</code> action and the actions associated with <code>submit_button</code>.</p> <p>Hence when the location dropdown is updated, the following three actions are triggered in order:</p> <ol> <li><code>update_time_date_formats</code>: triggered by the location dropdown</li> <li><code>update_cards</code>: triggered implicitly by completion of <code>update_time_date_formats</code></li> <li><code>fetch_weather</code>: triggered explicitly by completion of <code>update_cards</code></li> </ol> <p>Our actions flowchart is starting to grow quite large now that there's three actions, but really all that's different is the new <code>update_time_date_formats</code> actions and its associated inputs, outputs and triggers. Try following the line of triggers denoted with thick arrows. The actions <code>[update_date, fetch_weather]</code> that are in an explicit chain are directly connected by a thick arrow. On the other hand, the implicit connection between <code>update_time_date_formats</code> and <code>update_cards</code> is not a direct connection but instead goes through the <code>submit_button</code> model. Note also that the <code>location_dropdown</code> model is used as a trigger and a runtime input simultaneously.</p> <pre><code>graph TD\n  subgraph screen_1[\" \"]\n    clock_switch\n    date_radio_items\n    submit_button\n  end\n\n  subgraph screen_2[\" \"]\n    time_card\n    date_card\n    weather_card\n  end\n\n  clock_switch &amp; date_radio_items -. runtime input .-&gt; update_cards -- output --&gt; time_card &amp; date_card &amp; weather_card\n  location_dropdown -. runtime input .-&gt; update_time_date_formats -- output --&gt; clock_switch &amp; date_radio_items &amp; submit_button\n\n  location_dropdown == trigger ==&gt; update_time_date_formats([update_time_date_formats])\n  submit_button == trigger ==&gt; update_cards\n  update_cards([update_cards]) == trigger ==&gt; fetch_weather([fetch_weather])\n\n  location_dropdown -. runtime input .-&gt; fetch_weather -- output --&gt; weather_card</code></pre> <p>An implicit action chain can only be formed by triggering the first action of an explicit chain (or a single action, if there is only one action in the chain). Here, <code>update_time_date_formats</code> triggers the first action <code>update_cards</code> in the chain <code>[update_cards, fetch_weather]</code>, which then triggers the chained action <code>fetch_weather</code>. It is not possible for an action to implicitly chain on to <code>fetch_weather</code> directly: there is no way for <code>fetch_weather</code> to run other than through the completion of <code>update_cards</code>.</p> <p>Tip</p> <p>When you're building more complicated chains of actions, it's often useful to start by sketching an actions flowchart and then work out how to configure the actions to achieve it.</p>","path":["Write your own actions"],"tags":[]},{"location":"tutorials/custom-actions-tutorial/#parallel-actions","level":2,"title":"Parallel actions","text":"<p>We are going to implement a few final enhancements to our example to improve the user experience. To make the app feel more responsive, we're going to remove the submit button and instead use <code>clock_switch</code> and <code>date_radio_items</code> as triggers themselves.</p> <p>The <code>update_cards</code> action currently uses both <code>clock_switch</code> and <code>date_radio_items</code> as inputs and returns both <code>time_card</code> and <code>date_card</code> as outputs. However, really <code>clock_switch</code> only affects <code>time_card</code>, and <code>date_radio_items</code> only affects <code>date_card</code>. Let's split <code>update_cards</code> into two independent actions to reflect this:</p> <ul> <li><code>update_time_card</code>, which updates only <code>time_card</code></li> <li><code>update_date_card</code>, which updates only <code>date_card</code></li> </ul> <p>As an additional enhancement we add <code>location_dropdown</code> as an input to these actions so that we can use the correct timezone for Washington, D.C. and Berlin.</p> Parallel actions app.pyResult <pre><code>from datetime import datetime\nfrom zoneinfo import ZoneInfo\n\nimport requests\nimport vizro.models as vm\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\n\n@capture(\"action\")\ndef update_time_card(use_24_hour_clock, location):\n    time_format = \"%H:%M:%S %Z\" if use_24_hour_clock else \"%I:%M:%S %p %Z\"\n    timezone_name = \"Europe/Berlin\" if location == \"Berlin\" else \"America/New_York\"\n    now = datetime.now(ZoneInfo(timezone_name))  # (1)!\n    time = now.strftime(time_format)\n    return f\"🕰️ The time is {time}\"\n\n\n@capture(\"action\")\ndef update_date_card(date_format, location):\n    date_format = \"%d/%m/%y\" if date_format == \"DD/MM/YY\" else \"%m/%d/%y\"\n    timezone_name = \"Europe/Berlin\" if location == \"Berlin\" else \"America/New_York\"\n    now = datetime.now(ZoneInfo(timezone_name))\n    date = now.strftime(date_format)\n    return f\"📅 The date is {date}\"\n\n\n@capture(\"action\")\ndef fetch_weather(location):\n    berlin_params = {\"latitude\": 52.5, \"longitude\": 13.4, \"current\": \"temperature_2m\"}\n    washington_dc_params = {\"latitude\": 38.9, \"longitude\": -77.0, \"current\": \"temperature_2m\"}\n    params = berlin_params if location == \"Berlin\" else washington_dc_params\n    r = requests.get(\"https://api.open-meteo.com/v1/forecast\", params=params)\n    temperature = r.json()[\"current\"][\"temperature_2m\"]\n    return f\"🌡️ The current temperature in {location} is {temperature}°C\"\n\n\n@capture(\"action\")\ndef update_time_date_formats(location):\n    if location == \"Berlin\":\n        return True, \"DD/MM/YY\", \"Fetching current weather...\"  # (2)!\n    return False, \"MM/DD/YY\", \"Fetching current weather...\"\n\n\nvm.Container.add_type(\"components\", vm.Switch)\nvm.Container.add_type(\"components\", vm.RadioItems)\nvm.Container.add_type(\"components\", vm.Dropdown)\n\npage = vm.Page(\n    title=\"My first action\",\n    layout=vm.Flex(),\n    components=[\n        vm.Container(\n            layout=vm.Flex(direction=\"row\"),\n            variant=\"outlined\",\n            components=[\n                vm.Dropdown(\n                    id=\"location_dropdown\",\n                    options=[\"Berlin\", \"Washington, D.C.\"],\n                    multi=False,\n                    actions=[\n                        vm.Action(\n                            function=update_time_date_formats(\"location_dropdown\"),\n                            outputs=[\"clock_switch\", \"date_radio_items\", \"weather_card\"],\n                        ),\n                        vm.Action(function=fetch_weather(\"location_dropdown\"), outputs=\"weather_card\"),\n                    ],\n                    extra={\"style\": {\"min-width\": \"200px\"}},\n                ),\n                vm.Switch(\n                    id=\"clock_switch\",\n                    title=\"24-hour clock\",\n                    value=True,\n                    actions=vm.Action(function=update_time_card(\"clock_switch\", \"location_dropdown\"), outputs=\"time_card\"),\n\n                ),\n                vm.RadioItems(\n                    id=\"date_radio_items\",\n                    options=[\"DD/MM/YY\", \"MM/DD/YY\"],\n                    actions=vm.Action(function=update_date_card(\"date_radio_items\", \"location_dropdown\"), outputs=\"date_card\"),\n                ),\n            ],\n        ),\n        vm.Card(id=\"time_card\", text=\"Click the button\"),\n        vm.Card(id=\"date_card\", text=\"Click the button\"),\n        vm.Card(id=\"weather_card\", text=\"Click the button\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li><code>update_time_card</code> and <code>update_date_card</code> are now timezone-sensitive. We use the <code>location</code> set by the dropdown to choose the appropriate timezone.</li> <li>Now that <code>submit_button</code> no longer exists, it is the responsibility of <code>update_time_date_formats</code> to update <code>weather_card</code> with the \"Fetching current weather...\" placeholder. This action is otherwise unchanged.</li> </ol> <p></p> <p>Play around with the app for a while to make sure you understand its behavior:</p> <ul> <li>When you click the switch, just the time card updates.</li> <li>When you click the radio items, just the date card updates.</li> <li>When you use the dropdown, the switch and radio items update, which in turns updates the time and date cards, and the weather is fetched after an initial placeholder message is shown.</li> </ul> <p>Now that you're familiar with the notation of an actions flowchart we're going to make a few simplifications so that it doesn't get too large to understand. We no longer show the runtime inputs at all, and we omit the labels from the lines showing outputs and triggers (still shown with thick lines).</p> <pre><code>graph TD\n  subgraph screen_1[\" \"]\n    clock_switch\n    date_radio_items\n  end\n\n  subgraph screen_2[\" \"]\n    time_card\n    date_card\n    weather_card\n  end\n\n  update_time_card --&gt; time_card\n  update_date_card --&gt; date_card\n  update_time_date_formats --&gt; weather_card &amp; clock_switch &amp; date_radio_items\n  fetch_weather --&gt; weather_card\n\n  location_dropdown ==&gt; update_time_date_formats([update_time_date_formats])\n  update_time_date_formats ==&gt; fetch_weather([fetch_weather])\n  clock_switch ==&gt; update_time_card([update_time_card])\n  date_radio_items ==&gt; update_date_card([update_date_card])\n</code></pre> <p>We still have an explicit actions chain <code>[update_time_date_formats, fetch_weather]</code>, since these are directly connected by a thick arrow. The connections between <code>update_time_date_formats</code> and the <code>update_time_card</code> and <code>update_date_card</code> actions are implicit since there is no direct connection; the lines go through intermediate models <code>clock_switch</code> and <code>date_radio_items</code> respectively.</p> <p>In terms of execution order, we know that <code>fetch_weather</code> can only execute once <code>update_time_date_formats</code> has completed since these are in an explicit actions chain. But when <code>update_time_date_formats</code> completes, as well as triggering <code>fetch_weather</code>, it also implicitly triggers <code>update_time_card</code> and <code>update_date_card</code> simultaneously. Looking at the flowchart, we can see that all three of these actions can run in parallel and, in general, will do so. Each action will update its outputs on screen as soon as it has completed.</p> Parallel execution is not guaranteed <p>The reason we say that the actions will in general run in parallel wherever possible is that, as explained in the Dash documentation, execution depends on the server environment. If you use the Flask development server, it is by default set to run multi-threaded and so actions can execute in parallel. In production, if you use gunicorn with multiple workers then multiple actions can run in parallel.</p> <p>However, if you work in PyCafe you will find that multiple actions cannot run in parallel. This is a known limitation of PyCafe. In this case, the three actions <code>fetch_weather</code>, <code>update_time_card</code> and <code>update_date_card</code> run serially, in an order that should not be relied upon. The same would happen if you ran the Flask development server with <code>threaded=False</code> or ran <code>gunicorn</code> with a single worker.</p>","path":["Write your own actions"],"tags":[]},{"location":"tutorials/custom-actions-tutorial/#handle-errors-and-debug","level":2,"title":"Handle errors and debug","text":"<p>So far we have just considered the \"happy path\" where all actions run as planned. Let's also look at what happens if an action does not complete successfully.</p> <p>For example, let's say that the HTTP request to Open-Meteo in <code>fetch_weather</code> fails, for example due to a network problem or an incorrect URL. If we forget to include the <code>http://</code> in the request URL then <code>requests</code> raises a Python exception <code>requests.exceptions.MissingSchema</code>:</p> <pre><code>@capture(\"action\")\ndef fetch_weather(location):\n    ...\n    r = requests.get(\"api.open-meteo.com/v1/forecast\", params=params)\n</code></pre> <p>Now when the <code>fetch_weather</code> action runs you will see an error message about <code>requests.exceptions.MissingSchema</code> in the logs of the terminal where you run <code>python app.py</code>. Once a Python exception has been raised in a Vizro action, execution of the action ceases immediately and no outputs of that action will be updated. To the dashboard user it will not be apparent that an error has occurred; their screen will simply not show an update. In this example, <code>weather_card</code> will be stuck showing the placeholder message \"Fetching current weather...\".</p> <p>For a better user experience, we can wrap the relevant code in <code>try/except</code> so that the placeholder message updates with a clear failure message in the case that the HTTP request fails. The full code is shown below.</p> Handle errors app.pyResult <pre><code>from datetime import datetime\nfrom zoneinfo import ZoneInfo\n\nimport requests\nimport vizro.models as vm\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\n\n@capture(\"action\")\ndef update_time_card(use_24_hour_clock, location):\n    time_format = \"%H:%M:%S %Z\" if use_24_hour_clock else \"%I:%M:%S %p %Z\"\n    timezone_name = \"Europe/Berlin\" if location == \"Berlin\" else \"America/New_York\"\n    now = datetime.now(ZoneInfo(timezone_name))\n    time = now.strftime(time_format)\n    return f\"🕰️ The time is {time}\"\n\n\n@capture(\"action\")\ndef update_date_card(date_format, location):\n    date_format = \"%d/%m/%y\" if date_format == \"DD/MM/YY\" else \"%m/%d/%y\"\n    timezone_name = \"Europe/Berlin\" if location == \"Berlin\" else \"America/New_York\"\n    now = datetime.now(ZoneInfo(timezone_name))\n    date = now.strftime(date_format)\n    return f\"📅 The date is {date}\"\n\n\n@capture(\"action\")\ndef fetch_weather(location):\n    berlin_params = {\"latitude\": 52.5, \"longitude\": 13.4, \"current\": \"temperature_2m\"}\n    washington_dc_params = {\"latitude\": 38.9, \"longitude\": -77.0, \"current\": \"temperature_2m\"}\n    params = berlin_params if location == \"Berlin\" else washington_dc_params\n    try:\n        r = requests.get(\"api.open-meteo.com/v1/forecast\", params=params)\n        temperature = r.json()[\"current\"][\"temperature_2m\"]  # (1)!\n    except:\n        return \"❗ Could not fetch weather\"\n    return f\"🌡️ The current temperature in {location} is {temperature}°C\"\n\n\n@capture(\"action\")\ndef update_time_date_formats(location):\n    if location == \"Berlin\":\n        return True, \"DD/MM/YY\", \"Fetching current weather...\"\n    return False, \"MM/DD/YY\", \"Fetching current weather...\"\n\n\nvm.Container.add_type(\"components\", vm.Switch)\nvm.Container.add_type(\"components\", vm.RadioItems)\nvm.Container.add_type(\"components\", vm.Dropdown)\n\npage = vm.Page(\n    title=\"My first action\",\n    layout=vm.Flex(),\n    components=[\n        vm.Container(\n            layout=vm.Flex(direction=\"row\"),\n            variant=\"outlined\",\n            components=[\n                vm.Dropdown(\n                    id=\"location_dropdown\",\n                    options=[\"Berlin\", \"Washington, D.C.\"],\n                    multi=False,\n                    actions=[\n                        vm.Action(\n                            function=update_time_date_formats(\"location_dropdown\"),\n                            outputs=[\"clock_switch\", \"date_radio_items\", \"weather_card\"],\n                        ),\n                        vm.Action(function=fetch_weather(\"location_dropdown\"), outputs=\"weather_card\"),\n                    ],\n                    extra={\"style\": {\"min-width\": \"200px\"}},\n                ),\n                vm.Switch(\n                    id=\"clock_switch\",\n                    title=\"24-hour clock\",\n                    value=True,\n                    actions=vm.Action(function=update_time_card(\"clock_switch\", \"location_dropdown\"), outputs=\"time_card\"),\n\n                ),\n                vm.RadioItems(\n                    id=\"date_radio_items\",\n                    options=[\"DD/MM/YY\", \"MM/DD/YY\"],\n                    actions=vm.Action(function=update_date_card(\"date_radio_items\", \"location_dropdown\"), outputs=\"date_card\"),\n                ),\n            ],\n        ),\n        vm.Card(id=\"time_card\", text=\"Click the button\"),\n        vm.Card(id=\"date_card\", text=\"Click the button\"),\n        vm.Card(id=\"weather_card\", text=\"Click the button\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>Fetching <code>temperature</code> from the response is another potential source of an exception, for example if the structure of the Open-Meteo response changes, so we also put this line inside the <code>try</code>.</li> </ol> <p></p> <p>If an action raises an uncaught exception then any actions that would be triggered by successful completion of the action, either in an explicit or implicit action chain, will also not execute. If you wish to deliberately cancel execution of an action then you can <code>raise dash.exceptions.PreventUpdate</code>. This will mean that none of the action's outputs are updated and no chained actions execute. For more fine-grained control, you can instead prevent update to only some of the outputs of an action by returning <code>dash.no_update</code>. In this case, only those chained actions that are triggered by outputs that did not update will be prevented from executing.</p> <p>Tip</p> <p>If you develop in debug mode with <code>run(debug=True)</code> then the exception and traceback are shown in your browser, which is usually more convenient.</p> <p>When developing your app, it can also be very useful to insert a breakpoint inside the code of an action. This enables you to pause execution of an action, inspect variables and understand what is happening. You can add breakpoints with most popular coding tools, for example VS Code.</p>","path":["Write your own actions"],"tags":[]},{"location":"tutorials/custom-actions-tutorial/#security","level":2,"title":"Security","text":"<p>When writing actions, you should always be careful when handling runtime input from untrusted users. When a Vizro action is triggered, there is an HTTP request sent from the user's browser to the server. In theory, this contains the values of the action's runtime inputs fetched from the user's screen. However, there are ways for a malicious user to artificially construct an HTTP request that sends arbitrary values to the server. You should never assume that the values of runtime inputs in your Python action function are restricted to those that you have configured to be shown on the user's screen.</p> <p>For example, our <code>vm.Dropdown(id=\"location_dropdown\")</code> has <code>options=[\"Berlin\", \"Washington, D.C.\"]</code>, which presents only those two location options on the user's screen. Let's look at one action which uses this as runtime input:</p> <pre><code>@capture(\"action\")\ndef update_time_card(use_24_hour_clock, location):\n    ...\n    timezone_name = \"Europe/Berlin\" if location == \"Berlin\" else \"America/New_York\"\n</code></pre> <p>We might expect the value of <code>location</code> to be either \"Berlin\" or \"Washington, D.C.\", as per the dropdown's available options, but we can never guarantee that this is the case. A malicious user can trigger <code>update_time_card</code> with any JSON-compatible value for <code>location</code>. The code written here has no security risk because if <code>location</code> is set to any value other than \"Berlin\" then the timezone is set to \"America/New_York\". This will be the case for both the expected trusted user input <code>location=\"Washington, D.C.\"</code> and arbitrary untrusted input such as <code>location=\"Paris\"</code> and <code>location=42</code>.</p> <p>However, imagine that we had a secret database of all the world's timezones that includes some classified locations not known to the general public. The <code>update_time_card</code> action looks up the timezone of the input <code>location</code> in the database:</p> <pre><code>SECRET_TIMEZONE_DATABASE = {\n    \"Berlin\": \"Europe/Berlin\",\n    \"Washington, D.C.\": \"America/New_York\",\n    \"Area 51\": \"America/Los_Angeles\",\n    \"Top secret bunker\": \"Europe/London\",\n}\n\n@capture(\"action\")\ndef update_time_card(use_24_hour_clock, location):\n    ...\n    timezone_name = SECRET_TIMEZONE_DATABASE[location]\n</code></pre> <p>Even though we have set <code>options=[\"Berlin\", \"Washington, D.C.\"]</code> in our <code>vm.Dropdown</code>, a malicious user could construct an HTTP request that sets <code>location=\"Top secret bunker\"</code>. There would be nothing to stop <code>update_time_card</code> running and exposing the time at the top secret bunker! You could protect against this by validating that the <code>location</code> value is indeed one of the expected values and raising an exception if not:</p> <pre><code>from dash.exceptions import PreventUpdate\n\n@capture(\"action\")\ndef update_time_card(use_24_hour_clock, location):\n    if location not in [\"Berlin\", \"Washington, D.C.\"]:\n        raise PreventUpdate\n    timezone_name = SECRET_TIMEZONE_DATABASE[location]\n</code></pre> <p>In many cases, untrusted user input does not pose a security risk. For example, if we looked up <code>SECRET_TIMEZONE_DATABASE[\"nonexistent key\"]</code> then Python would raise a <code>KeyError</code> exception, which would also cancel execution of the action and not update any information on the user's screen. However, there are certain scenarios, such as file system manipulation and SQL queries, where you should be particularly vigilant.</p>","path":["Write your own actions"],"tags":[]},{"location":"tutorials/custom-actions-tutorial/#key-principles-of-actions","level":2,"title":"Key principles of actions","text":"<p>Congratulations on completing the tutorial! You should now be able to write quite complex custom actions. To recap, let's summarize some of the key principles of how actions work.</p> <ul> <li>An action is a Python function that executes when it is triggered by a user interacting with a component on their screen.</li> <li>An action can have any number of inputs and outputs but only one trigger.</li> <li>Any number of actions can be chained together. There are two ways to chain actions:<ul> <li>Explicitly: when you set <code>actions=[action_1, action_2, ...]</code> then <code>action_2</code> only runs after <code>action_1</code> has completed.</li> <li>Implicitly: when one action outputs something that automatically triggers another action.</li> </ul> </li> <li>When multiple actions are triggered simultaneously, they usually execute in parallel.</li> <li>You can cancel execution of an action and subsequent chained actions by raising an exception.</li> <li>For security, you should always assume that inputs to your actions have been generated by an untrusted user.</li> </ul>","path":["Write your own actions"],"tags":[]},{"location":"tutorials/explore-components/","level":1,"title":"Explore Vizro","text":"<p>In this tutorial, you'll learn how to build an interactive dashboard with multiple pages, incorporating a wide range of Vizro's components. You can follow along using the written guide below or join in with the accompanying video tutorial.</p> <p>This tutorial should take about half an hour to finish, so grab a coffee or tea and let's dive in!</p> <p>Note</p> <p>If you're looking for a quick start to get up and running with Vizro, consider reviewing the quickstart tutorial before diving into this one.</p> <p>By the end of this tutorial, you will have learned how to:</p> <ul> <li>Explore most of Vizro's components.</li> <li>Use the Vizro visual vocabulary to guide your chart creation.</li> <li>Design custom charts with Plotly Express.</li> <li>Develop multiple pages for the dashboard.</li> <li>Customize the layout of the pages.</li> <li>Add interactivity using filters and parameters.</li> <li>Add a logo and title to the dashboard.</li> <li>Customize the dashboard navigation.</li> </ul> <p>This tutorial uses the tips dataset, which was collected by a waiter who recorded information about each tip he received over several months at a restaurant.</p> <p>Here is a preview of the dashboard you'll build:</p> <p></p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#1-install-vizro-or-run-on-pycafe","level":2,"title":"1. Install Vizro or run on PyCafe","text":"<p>There's no need to install Vizro locally because you can experiment with the complete code for the tutorial directly on PyCafe in your browser. We recommend starting with a blank Vizro project on PyCafe and copying the code snippets from this tutorial into it, to build it up from scratch and see how it fits together.</p> <p>For more information about working with Vizro on PyCafe, check out the PyCafe documentation.</p> If you prefer working in a Notebook or Python script <p>To work in a Notebook or locally using a Python script, you need to install Vizro.</p> <p>Paste the code from the tutorial into a Notebook cell, run the Notebook, and evaluate it.</p> <p>You will need to restart the kernel each time you run the code. Otherwise, you may encounter errors such as \"Components must uniquely map...\" because those components persist from the previous execution. As an alternative to restarting the kernel each time, you can add a cell containing <code>from vizro import Vizro; Vizro._reset()</code> to the top of your Notebook and re-run it each time you re-run your code. With this method, there is no need to restart the Jupyter kernel.</p> <p>If you prefer using Python scripts instead of Notebooks, follow these steps:</p> <ol> <li>Create a new script called <code>app.py</code>.</li> <li>Copy the code above into the script.</li> <li>Navigate to the directory where <code>app.py</code> file is located using your terminal.</li> <li>Run the script by executing the command <code>python app.py</code>.</li> </ol> <p>Once the script is running, open your web browser and navigate to <code>localhost:8050</code> to view the dashboard. To enable debug mode for hot reloading, add <code>debug=True</code> inside the run() method at the end of your <code>app.py</code> file:</p> <p><code>Vizro().build(dashboard).run(debug=True)</code></p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#2-understand-the-basics","level":2,"title":"2. Understand the basics","text":"<p>Before we dive in, let's quickly cover some basics:</p> <p>At the top level, you'll be creating a <code>Dashboard</code>. Here's what you can configure at the dashboard-level:</p> <ul> <li>Pages: You can add multiple pages; they are the building blocks of your dashboard.</li> <li>Navigation: You can customize navigation between those different pages.</li> <li>Title/Logo: You can add your own titles and logos.</li> </ul> <p>For each <code>Page</code>, you can also configure the following:</p> <ul> <li>Components: Add charts, tables, input/output interfaces, and more.</li> <li>Controls: Include filters and parameters.</li> <li>Layouts: Customize the placement of components within a page.</li> <li>Actions: Create interactions between components using actions.</li> </ul>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#3-create-a-first-page","level":2,"title":"3. Create a first page","text":"<p>In this section, you learn how to create a new <code>Page</code> and store it in a variable called <code>first_page</code>.</p> <p>A [<code>Page</code>][vizro.models.Page] model is the foundation of any Vizro dashboard. It uses a set of components to display content. For a comprehensive list of all Vizro components, refer to the components overview page.</p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#31-add-a-table","level":3,"title":"3.1. Add a table","text":"<p>To start, let's get an overview of the data by displaying it in a table using <code>AgGrid</code>. These steps create a page and add a table to it:</p> <ol> <li>Import the necessary packages and load the dataset.</li> <li>Create a [<code>Page</code>][vizro.models.Page] and set its <code>title</code> to <code>\"Data\"</code>.</li> <li>Add an [<code>AgGrid</code>][vizro.models.AgGrid] component to the <code>components</code> list.</li> <li>Use the [<code>dash_ag_grid</code>][vizro.tables.dash_ag_grid] function inside the <code>figure</code> argument of <code>AgGrid</code>.</li> <li>Provide details about the data source in the <code>footer</code> argument of <code>AgGrid</code>.</li> <li>Add the newly created page to the list of <code>pages</code> in the Dashboard[vizro.models.Dashboard] model.</li> </ol> <p>First Page</p> Code - DashboardResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\nfrom vizro.models.types import capture\nfrom vizro.figures import kpi_card\n\ntips = px.data.tips()\n\nfirst_page = vm.Page(\n    title=\"Data\",\n    components=[\n        vm.AgGrid(\n            figure=dash_ag_grid(tips),\n            footer=\"\"\"**Data Source:** Bryant, P. G. and Smith, M. (1995).\n            Practical Data Analysis: Case Studies in Business Statistics.\n            Homewood, IL: Richard D. Irwin Publishing.\"\"\",\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[first_page])\nVizro().build(dashboard).run()\n</code></pre> <p></p> <p>After running your code (either locally or on PyCafe), you can now view the dashboard (on <code>localhost:8050</code> if you ran it locally, or on the right part of the screen if you are using PyCafe).</p> <p>Take a moment to explore the data in the table. You can sort, filter, and search within the <code>AgGrid</code> columns to better understand the dataset.</p> <p>In the top-right corner of the dashboard, you'll notice a toggle to switch between dark and light themes. Try it out!</p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#32-add-an-export-data-button","level":3,"title":"3.2. Add an <code>export data</code> button","text":"<p>Next, you'll add a <code>Button</code> that lets users export the data currently shown in your dashboard.</p> <p>This is an example of an action. Vizro provides several built-in actions, and you can also write your own custom actions.</p> <p>These steps add an export data button:</p> <ol> <li>Add a [<code>Button</code>][vizro.models.Button] model to the <code>components</code> list and set <code>text=\"Export Data\"</code>.</li> <li>Use the <code>actions</code> argument of the <code>Button</code> to specify the built-in <code>export_data</code> action.</li> </ol> <p>Export Data Button</p> Snippet - ButtonCode - DashboardResult <pre><code>vm.Button(text=\"Export Data\", actions=va.export_data())\n</code></pre> <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\nfrom vizro.models.types import capture\nfrom vizro.figures import kpi_card\nimport vizro.actions as va\n\ntips = px.data.tips()\n\nfirst_page = vm.Page(\n    title=\"Data\",\n    components=[\n        vm.AgGrid(\n            figure=dash_ag_grid(tips),\n            footer=\"\"\"**Data Source:** Bryant, P. G. and Smith, M. (1995).\n            Practical Data Analysis: Case Studies in Business Statistics.\n            Homewood, IL: Richard D. Irwin Publishing.\"\"\",\n        ),\n        vm.Button(text=\"Export Data\", actions=va.export_data()),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[first_page])\nVizro().build(dashboard).run()\n</code></pre> <p></p> <p>Click on the Button and see what happens! 📂</p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#33-configure-the-layout","level":3,"title":"3.3. Configure the layout","text":"<p>Notice there is extra blank space below the button. In this step, you’ll learn how to improve the layout by arranging components more efficiently.</p> <p>Vizro supports two layouts: <code>Grid</code> and <code>Flex</code>. To understand the differences between them, check out our guide on layouts.</p> <p>By default, Vizro uses the <code>Grid</code> layout, which arranges components in the order they appear inside <code>components</code> and gives them equal space. However, in our case, we want the <code>Button</code> and <code>AgGrid</code> to only take up the space they need — not equal space.</p> <p>To achieve this, we'll switch to the <code>Flex</code> layout and set a <code>height</code> for the <code>AgGrid</code>, as the default is <code>400px</code> otherwise.</p> <ol> <li>In the <code>layout</code> argument of the <code>Page</code>, use the [<code>Flex</code>][vizro.models.Flex] layout model via <code>layout = vm.Flex()</code></li> <li>Specify <code>style= {\"height\": \"600px\"}</code> inside the <code>dash_ag_grid</code>, as it would otherwise default to <code>400px</code>.</li> </ol> <p>Use Flex layout</p> Snippet - flex layoutCode - DashboardResult <pre><code>layout = vm.Flex()\n</code></pre> <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\nfrom vizro.models.types import capture\nfrom vizro.figures import kpi_card\nimport vizro.actions as va\n\ntips = px.data.tips()\n\nfirst_page = vm.Page(\n    title=\"Data\",\n    layout=vm.Flex(),\n    components=[\n        vm.AgGrid(\n            figure=dash_ag_grid(tips, style= {\"height\": \"600px\"}),\n            footer=\"\"\"**Data Source:** Bryant, P. G. and Smith, M. (1995).\n            Practical Data Analysis: Case Studies in Business Statistics.\n            Homewood, IL: Richard D. Irwin Publishing.\"\"\",\n        ),\n        vm.Button(text=\"Export Data\", actions=va.export_data()),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[first_page])\nVizro().build(dashboard).run()\n</code></pre> <p></p> <p>Looks much better already! Great job - you've successfully created your first dashboard page!</p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#4-create-a-second-page","level":2,"title":"4. Create a second page","text":"","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#41-add-a-chart","level":3,"title":"4.1. Add a chart","text":"<p>Next, you'll learn how to add a second page to the dashboard that features charts and KPI (Key Performance Indicator) cards.</p> <p>Vizro uses [<code>Graph</code>][vizro.models.Graph] models and Plotly Express functions to create various types of charts. You can explore some of the available chart types and their code examples in the Vizro visual vocabulary.</p> <p>These steps add a histogram to the page:</p> <ol> <li>Create a second [<code>Page</code>][vizro.models.Page] and store it in a variable called <code>second_page</code>. Set its <code>title</code> to <code>\"Summary\"</code>.</li> <li>Add a [<code>Graph</code>][vizro.models.Graph] model to the <code>components</code> list.</li> <li>Inside the <code>figure</code> argument of the [<code>Graph</code>][vizro.models.Graph] model, use the code for the px.histogram from the visual vocabulary.</li> <li>Add the new page to the list of <code>pages</code> in the [<code>Dashboard</code>][vizro.models.Dashboard] model by calling <code>vm.Dashboard(pages=[first_page, second_page])</code>.</li> </ol> <p>Second Page</p> Snippet - Second PageCode - DashboardResult <pre><code>second_page = vm.Page(\n    title=\"Summary\",\n    components=[\n        vm.Graph(figure=px.histogram(tips, x=\"total_bill\")),\n        vm.Graph(figure=px.histogram(tips, x=\"tip\")),\n    ],\n)\ndashboard = vm.Dashboard(pages=[first_page, second_page])\n</code></pre> <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\nfrom vizro.models.types import capture\nfrom vizro.figures import kpi_card\nimport vizro.actions as va\n\ntips = px.data.tips()\n\nfirst_page = vm.Page(\n    title=\"Data\",\n    components=[\n        vm.AgGrid(\n            figure=dash_ag_grid(tips),\n            footer=\"\"\"**Data Source:** Bryant, P. G. and Smith, M. (1995).\n            Practical Data Analysis: Case Studies in Business Statistics.\n            Homewood, IL: Richard D. Irwin Publishing.\"\"\",\n        ),\n        vm.Button(text=\"Export Data\", actions=va.export_data()),\n    ],\n)\n\nsecond_page = vm.Page(\n    title=\"Summary\",\n    components=[\n        vm.Graph(figure=px.histogram(tips, x=\"total_bill\")),\n        vm.Graph(figure=px.histogram(tips, x=\"tip\")),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[first_page, second_page])\nVizro().build(dashboard).run()\n</code></pre> <p></p> <p>Notice that the charts are automatically stacked vertically in the order specified under <code>components</code>, each taking up equal space. This is the default behavior in Vizro, but you'll learn how to customize the layout later!</p> <p>Also, a page navigation menu has been added to the left side of the dashboard, enabling you to switch between the two pages we’ve created.</p> <p>You'll also notice that the left-side menu can be collapsed to provide more space for the dashboard content. Give it a try!</p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#42-add-kpi-cards","level":3,"title":"4.2. Add KPI cards","text":"<p>You can combine and arrange various types of <code>components</code> on a dashboard page. Refer to the components overview page for a comprehensive list of available components.</p> <p>These steps add two KPI cards to the second page:</p> <ol> <li>Add a [<code>Figure</code>][vizro.models.Figure] model to the list of <code>components</code>.</li> <li>Inside the <code>figure</code> argument of the <code>Figure</code>, use the [<code>kpi_card</code>][vizro.figures.kpi_card] function.</li> <li>Configure your <code>kpi_card</code> by setting the <code>value_column</code>, <code>agg_func</code>, <code>value_format</code>, and <code>title</code>. To learn more about configuring KPI cards, check out our guide to KPI cards.</li> <li>Repeat the above steps to add another KPI card to the page.</li> </ol> <p>Add KPI Cards</p> Snippet - KPI Card ISnippet - KPI Card IICode - dashboardResult <pre><code>vm.Figure(\n    figure=kpi_card(\n        data_frame=tips,\n        value_column=\"total_bill\",\n        agg_func=\"mean\",\n        value_format=\"${value:.2f}\",\n        title=\"Average Bill\",\n    )\n)\n</code></pre> <pre><code>vm.Figure(\n    figure=kpi_card(\n        data_frame=tips,\n        value_column=\"tip\",\n        agg_func=\"mean\",\n        value_format=\"${value:.2f}\",\n        title=\"Average Tips\"\n    )\n)\n</code></pre> <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\nfrom vizro.models.types import capture\nfrom vizro.figures import kpi_card\nimport vizro.actions as va\n\ntips = px.data.tips()\n\nfirst_page = vm.Page(\n    title=\"Data\",\n    components=[\n        vm.AgGrid(\n            figure=dash_ag_grid(tips),\n            footer=\"\"\"**Data Source:** Bryant, P. G. and Smith, M. (1995).\n            Practical Data Analysis: Case Studies in Business Statistics.\n            Homewood, IL: Richard D. Irwin Publishing.\"\"\",\n        ),\n        vm.Button(text=\"Export Data\", actions=va.export_data()),\n    ],\n)\n\nsecond_page = vm.Page(\n    title=\"Summary\",\n    components=[\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"total_bill\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Bill\",\n            )\n        ),\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"tip\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Tips\"\n            )\n        ),\n        vm.Graph(figure=px.histogram(tips, x=\"total_bill\")),\n        vm.Graph(figure=px.histogram(tips, x=\"tip\")),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[first_page, second_page])\nVizro().build(dashboard).run()\n</code></pre> <p></p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#43-add-tabs-to-switch-views","level":3,"title":"4.3. Add tabs to switch views","text":"<p>You may not want to display both histograms simultaneously and instead prefer to switch between views. You can achieve this by using the [<code>Tabs</code>][vizro.models.Tabs] model. For more details, refer to Vizro's tabs user guide.</p> <p>These steps place the two histograms in separate tabs:</p> <ol> <li>Add each [<code>Graph</code>][vizro.models.Graph] to the <code>components</code> of a [<code>Container</code>][vizro.models.Container].</li> <li>Set the <code>title</code> argument inside each <code>Container</code> to the desired tab name.</li> <li>Add the containers to the <code>tabs</code> list of the <code>Tabs</code> component.</li> <li>Add the <code>Tabs</code> component to the <code>components</code> of the <code>Page</code>.</li> </ol> <p>Add Tabs</p> Snippet - TabsCode - dashboardResult <pre><code>vm.Tabs(\n    tabs=[\n        vm.Container(\n            title=\"Total Bill ($)\",\n            components=[\n                vm.Graph(figure=px.histogram(tips, x=\"total_bill\")),\n            ],\n        ),\n        vm.Container(\n            title=\"Total Tips ($)\",\n            components=[\n                vm.Graph(figure=px.histogram(tips, x=\"tip\")),\n            ],\n        ),\n    ],\n)\n</code></pre> <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\nfrom vizro.models.types import capture\nfrom vizro.figures import kpi_card\nimport vizro.actions as va\n\ntips = px.data.tips()\n\nfirst_page = vm.Page(\n    title=\"Data\",\n    components=[\n        vm.AgGrid(\n            figure=dash_ag_grid(tips),\n            footer=\"\"\"**Data Source:** Bryant, P. G. and Smith, M. (1995).\n            Practical Data Analysis: Case Studies in Business Statistics.\n            Homewood, IL: Richard D. Irwin Publishing.\"\"\",\n        ),\n        vm.Button(text=\"Export Data\", actions=va.export_data()),\n    ],\n)\n\nsecond_page = vm.Page(\n    title=\"Summary\",\n    components=[\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"total_bill\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Bill\",\n            )\n        ),\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"tip\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Tips\"\n            )\n        ),\n        vm.Tabs(\n            tabs=[\n                vm.Container(\n                    title=\"Total Bill ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"total_bill\")),\n                    ],\n                ),\n                vm.Container(\n                    title=\"Total Tips ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"tip\")),\n                    ],\n                ),\n            ],\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[first_page, second_page])\nVizro().build(dashboard).run()\n</code></pre> <p></p> <p>Take a moment to switch between the tabs!</p> <p>As you explore the dashboard, you might notice that the current layout could use some adjustment. The histograms appear cramped, and the KPI cards have too much space. In the next section, you'll learn how to configure the layout and better arrange the components.</p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#44-configure-the-layout","level":3,"title":"4.4. Configure the layout","text":"<p>In this section, you'll customize the <code>Grid</code> layout to control the placement and size of components on the page.</p> <p>The following layout configuration is divided into four columns and four rows. The numbers in the grid correspond to the index of the components in the <code>components</code> list.</p> <ul> <li>The first KPI card (0) is positioned at the top, occupying the first cell in the first row.</li> <li>The second KPI card (1) is positioned to the right of the first KPI card.</li> <li>There are two empty cells to the right of the KPI cards (-1).</li> <li>The <code>Tabs</code> component (2) is placed below the KPI cards, spanning all cells across the remaining three rows.</li> </ul> <pre><code>grid = [[0, 1,-1,-1],\n        [2, 2, 2, 2],\n        [2, 2, 2, 2],\n        [2, 2, 2, 2]]\n</code></pre> <p>Run the code below to apply the layout to the dashboard page:</p> <p>Code - Layout</p> Snippet - LayoutCode - DashboardResult <pre><code>layout = vm.Grid(\n    grid=[[0, 1, -1, -1],\n          [2, 2, 2, 2],\n          [2, 2, 2, 2],\n          [2, 2, 2, 2]]\n)\n</code></pre> <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\nfrom vizro.models.types import capture\nfrom vizro.figures import kpi_card\nimport vizro.actions as va\n\ntips = px.data.tips()\n\nfirst_page = vm.Page(\n    title=\"Data\",\n    components=[\n        vm.AgGrid(\n            figure=dash_ag_grid(tips),\n            footer=\"\"\"**Data Source:** Bryant, P. G. and Smith, M (1995)\n            Practical Data Analysis: Case Studies in Business Statistics.\n            Homewood, IL: Richard D. Irwin Publishing.\"\"\",\n        ),\n        vm.Button(text=\"Export Data\", actions=va.export_data()),\n    ],\n)\n\nsecond_page = vm.Page(\n    title=\"Summary\",\n    layout=vm.Grid(grid=[[0, 1, -1, -1], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]]),\n    components=[\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"total_bill\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Bill\",\n            )\n        ),\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"tip\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Tips\"\n            )\n        ),\n        vm.Tabs(\n            tabs=[\n                vm.Container(\n                    title=\"Total Bill ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"total_bill\")),\n                    ],\n                ),\n                vm.Container(\n                    title=\"Total Tips ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"tip\")),\n                    ],\n                ),\n            ],\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[first_page, second_page])\nVizro().build(dashboard).run()\n</code></pre> <p></p> <p>Much better, don't you think? The layout now provides sufficient space for the charts!</p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#45-add-a-filter","level":3,"title":"4.5. Add a filter","text":"<p>You can use filters to interact with the dashboard by selecting specific data points to display.</p> <p>These steps add a filter to the dashboard:</p> <ol> <li>Add a [<code>Filter</code>][vizro.models.Filter] model to the <code>controls</code> list of the <code>Page</code>.</li> <li>Specify the column to be filtered using the <code>column</code> argument of the [Filter][vizro.models.Filter] model.</li> <li>Change the <code>selector</code> in one of the <code>Filters</code> to a [<code>Checklist</code>][vizro.models.Checklist]. For further customization, refer to the guide on <code>How to use selectors</code>.</li> </ol> <p>Add a filter</p> Snippet - FilterCode - DashboardResult <pre><code>controls = [vm.Filter(column=\"day\"), vm.Filter(column=\"time\", selector=vm.Checklist()), vm.Filter(column=\"size\")]\n</code></pre> <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\nfrom vizro.models.types import capture\nfrom vizro.figures import kpi_card\nimport vizro.actions as va\n\ntips = px.data.tips()\n\nfirst_page = vm.Page(\n    title=\"Data\",\n    components=[\n        vm.AgGrid(\n            figure=dash_ag_grid(tips),\n            footer=\"\"\"**Data Source:** Bryant, P. G. and Smith, M (1995)\n            Practical Data Analysis: Case Studies in Business Statistics.\n            Homewood, IL: Richard D. Irwin Publishing.\"\"\",\n        ),\n        vm.Button(text=\"Export Data\", actions=va.export_data()),\n    ],\n)\n\nsecond_page = vm.Page(\n    title=\"Summary\",\n    layout=vm.Grid(grid=[[0, 1, -1, -1], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]]),\n    components=[\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"total_bill\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Bill\",\n            )\n        ),\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"tip\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Tips\"\n            )\n        ),\n        vm.Tabs(\n            tabs=[\n                vm.Container(\n                    title=\"Total Bill ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"total_bill\")),\n                    ],\n                ),\n                vm.Container(\n                    title=\"Total Tips ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"tip\")),\n                    ],\n                ),\n            ],\n        )\n    ],\n    controls = [vm.Filter(column=\"day\"), vm.Filter(column=\"time\", selector=vm.Checklist()), vm.Filter(column=\"size\")]\n)\n\ndashboard = vm.Dashboard(pages=[first_page, second_page])\nVizro().build(dashboard).run()\n</code></pre> <p></p> <p>You'll see that a [<code>Dropdown</code>][vizro.models.Dropdown] is selected by default for categorical data, while a [<code>RangeSlider</code>][vizro.models.RangeSlider] is used for numerical data. Also, filters are applied to all components on the page.</p> <p>If you want to apply a filter to specific components only, check out How to use filters.</p> <p>Great work! You've just made a second dashboard page and learned how to:</p> <ol> <li>Add a chart to a page using the visual vocabulary</li> <li>Add KPI cards to display summary statistics</li> <li>Add tabs to switch views</li> <li>Arrange components by customizing the layout</li> <li>Add a filter to interact with the dashboard</li> </ol>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#5-create-a-third-page","level":2,"title":"5. Create a third page","text":"<p>Now that you've learned how to create pages, add components, and configure layouts, you'll create a third page for the dashboard. This will give you the opportunity to practice your skills alongside learning some new concepts!</p> <p>This page takes inspiration from the Vizro visual vocabulary. It will feature:</p> <ul> <li>a bar chart</li> <li>a violin chart</li> <li>a heatmap</li> </ul>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#51-add-multiple-charts","level":3,"title":"5.1. Add multiple charts","text":"<p>These steps should feel familiar, as they add three charts to the new page.</p> <ol> <li>Create a third [<code>Page</code>][vizro.models.Page] and store it in a variable called <code>third_page</code>. Set its <code>title</code> to \"Analysis\".</li> <li>Add three [<code>Graph</code>][vizro.models.Graph] models to the <code>components</code> of the <code>Page</code>.</li> <li>For each <code>Graph</code>, use the <code>figure</code> argument to provide one of the Plotly express functions:<ul> <li>px.violin (copy the code directly)</li> <li>px.bar (copy the code directly)</li> <li>px.density_heatmap (update the <code>data</code>, <code>x</code>, and <code>y</code> arguments to match the dataset)</li> </ul> </li> <li>Provide a <code>title</code> for each <code>Graph</code>.</li> <li>Add the new <code>Page</code> to the list of <code>pages</code> in the [<code>Dashboard</code>][vizro.models.Dashboard] model.</li> </ol> <p>Third page</p> Snippet - third pageCode - dashboardResult <pre><code>third_page = vm.Page(\n    title=\"Analysis\",\n    components=[\n        vm.Graph(\n            title=\"Where do we get more tips?\",\n            figure=px.bar(tips, y=\"tip\", x=\"day\"),\n        ),\n        vm.Graph(\n            title=\"Is the average driven by a few outliers?\",\n            figure=px.violin(tips, y=\"tip\", x=\"day\", color=\"day\", box=True),\n        ),\n        vm.Graph(\n            title=\"Which group size is more profitable?\",\n            figure=px.density_heatmap(tips, x=\"day\", y=\"size\", z=\"tip\", histfunc=\"avg\", text_auto=\"$.2f\"),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[first_page, second_page, third_page])\n</code></pre> <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\nfrom vizro.models.types import capture\nfrom vizro.figures import kpi_card\nimport vizro.actions as va\n\ntips = px.data.tips()\n\nfirst_page = vm.Page(\n    title=\"Data\",\n    components=[\n        vm.AgGrid(\n            figure=dash_ag_grid(tips),\n            footer=\"\"\"**Data Source:** Bryant, P. G. and Smith, M. (1995)\n            Practical Data Analysis: Case Studies in Business Statistics.\n            Homewood, IL: Richard D. Irwin Publishing.\"\"\",\n        ),\n        vm.Button(text=\"Export Data\", actions=va.export_data()),\n    ],\n)\n\nsecond_page = vm.Page(\n    title=\"Summary\",\n    layout=vm.Grid(grid=[[0, 1, -1, -1], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]]),\n    components=[\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"total_bill\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Bill\",\n            )\n        ),\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"tip\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Tips\",\n            )\n        ),\n        vm.Tabs(\n            tabs=[\n                vm.Container(\n                    title=\"Total Bill ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"total_bill\")),\n                    ],\n                ),\n                vm.Container(\n                    title=\"Total Tips ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"tip\")),\n                    ],\n                ),\n            ],\n        ),\n    ],\n    controls=[\n        vm.Filter(column=\"day\"),\n        vm.Filter(column=\"time\", selector=vm.Checklist()),\n        vm.Filter(column=\"size\"),\n    ],\n)\n\nthird_page = vm.Page(\n    title=\"Analysis\",\n    components=[\n        vm.Graph(\n            title=\"Where do we get more tips?\",\n            figure=px.bar(tips, y=\"tip\", x=\"day\"),\n        ),\n        vm.Graph(\n            title=\"Is the average driven by a few outliers?\",\n            figure=px.violin(tips, y=\"tip\", x=\"day\", color=\"day\", box=True),\n        ),\n        vm.Graph(\n            title=\"Which group size is more profitable?\",\n            figure=px.density_heatmap(tips, x=\"day\", y=\"size\", z=\"tip\", histfunc=\"avg\", text_auto=\"$.2f\"),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[first_page, second_page, third_page])\nVizro().build(dashboard).run()\n</code></pre> <p></p> <p>Depending on your screen size, you may notice that the third chart is not visible. This issue can occur with Plotly charts when there isn't enough space to display them properly. Let's revise the layout to allocate more space for the heatmap.</p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#52-configure-the-layout","level":3,"title":"5.2. Configure the layout","text":"<p>This step should also feel familiar by now. In the following new layout configuration, divide layout into two columns and two rows:</p> <ul> <li>The bar chart (0) and violin chart (1) are placed side by side in the first row.</li> <li>The heatmap (2) spans the entire second row.</li> </ul> <p>Remember, the index corresponds to the order in which the components are added to the <code>components</code> of the <code>Page</code>.</p> <pre><code>grid = [[0, 1],\n        [2, 2]]\n</code></pre> <p>Run the code below to apply the layout to the dashboard page:</p> <p>Code - Layout</p> Snippet - LayoutCode - dashboardResult <pre><code>layout=vm.Grid(grid=[[0, 1], [2, 2]]),\n</code></pre> <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\nfrom vizro.models.types import capture\nfrom vizro.figures import kpi_card\nimport vizro.actions as va\n\ntips = px.data.tips()\n\nfirst_page = vm.Page(\n    title=\"Data\",\n    components=[\n        vm.AgGrid(\n            figure=dash_ag_grid(tips),\n            footer=\"\"\"**Data Source:** Bryant, P. G. and Smith, M (1995)\n            Practical Data Analysis: Case Studies in Business Statistics.\n            Homewood, IL: Richard D. Irwin Publishing.\"\"\",\n        ),\n        vm.Button(text=\"Export Data\", actions=va.export_data()),\n    ],\n)\n\nsecond_page = vm.Page(\n    title=\"Summary\",\n    layout=vm.Grid(grid=[[0, 1, -1, -1], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]]),\n    components=[\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"total_bill\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Bill\",\n            )\n        ),\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"tip\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Tips\"\n            )\n        ),\n        vm.Tabs(\n            tabs=[\n                vm.Container(\n                    title=\"Total Bill ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"total_bill\")),\n                    ],\n                ),\n                vm.Container(\n                    title=\"Total Tips ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"tip\")),\n                    ],\n                ),\n            ],\n        )\n    ],\n    controls=[vm.Filter(column=\"day\"), vm.Filter(column=\"time\", selector=vm.Checklist()), vm.Filter(column=\"size\")]\n)\n\nthird_page = vm.Page(\n    title=\"Analysis\",\n    layout=vm.Grid(grid=[[0, 1], [2, 2]]),\n    components=[\n        vm.Graph(\n            title=\"Where do we get more tips?\",\n            figure=px.bar(tips, y=\"tip\", x=\"day\"),\n        ),\n        vm.Graph(\n            title=\"Is the average driven by a few outliers?\",\n            figure=px.violin(tips, y=\"tip\", x=\"day\", color=\"day\", box=True),\n        ),\n        vm.Graph(\n            title=\"Which group size is more profitable?\",\n            figure=px.density_heatmap(tips, x=\"day\", y=\"size\", z=\"tip\", histfunc=\"avg\", text_auto=\"$.2f\"),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[first_page, second_page, third_page])\nVizro().build(dashboard).run()\n</code></pre> <p></p> <p>Fantastic work! The heatmap looks great, doesn't it?</p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#53-add-a-parameter","level":3,"title":"5.3. Add a parameter","text":"<p>This section explains how you make the dashboard more interactive for the user by adding a parameter to dynamically change a component's argument.</p> <p>In this section, you learn how to switch the <code>x</code> and <code>color</code> arguments across all charts, enabling data analysis from different perspectives.</p> <p>These steps add a parameter to the dashboard:</p> <ol> <li>Add a [<code>Parameter</code>][vizro.models.Parameter] to the <code>controls</code> of the <code>Page</code>.</li> <li>Assign an <code>id</code> to each <code>Graph</code> that the [Parameter][vizro.models.Parameter] should target.</li> <li>Define the parameter's <code>targets</code> using the format <code>component-id.argument</code>.</li> <li>Set the <code>selector</code> of the [Parameter][vizro.models.Parameter] to a [<code>RadioItems</code>][vizro.models.RadioItems].</li> <li>Provide options for the <code>RadioItems</code> selector.</li> </ol> <p>Add a parameter</p> Snippet - parameterCode - dashboardResult <pre><code>controls=[\n    vm.Parameter(\n        targets=[\"violin.x\", \"violin.color\", \"heatmap.x\", \"bar.x\"],\n        selector=vm.RadioItems(\n            options=[\"day\", \"time\", \"sex\", \"smoker\", \"size\"], value=\"day\", title=\"Change x-axis inside charts:\"\n        ),\n    ),\n]\n</code></pre> <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\nfrom vizro.models.types import capture\nfrom vizro.figures import kpi_card\nimport vizro.actions as va\n\ntips = px.data.tips()\n\nfirst_page = vm.Page(\n    title=\"Data\",\n    components=[\n        vm.AgGrid(\n            figure=dash_ag_grid(tips),\n            footer=\"\"\"**Data Source:** Bryant, P. G. and Smith, M (1995)\n            Practical Data Analysis: Case Studies in Business Statistics.\n            Homewood, IL: Richard D. Irwin Publishing.\"\"\",\n        ),\n        vm.Button(text=\"Export Data\", actions=va.export_data()),\n    ],\n)\n\nsecond_page = vm.Page(\n    title=\"Summary\",\n    layout=vm.Grid(grid=[[0, 1, -1, -1], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]]),\n    components=[\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"total_bill\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Bill\",\n            )\n        ),\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"tip\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Tips\"\n            )\n        ),\n        vm.Tabs(\n            tabs=[\n                vm.Container(\n                    title=\"Total Bill ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"total_bill\")),\n                    ],\n                ),\n                vm.Container(\n                    title=\"Total Tips ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"tip\")),\n                    ],\n                ),\n            ],\n        )\n    ],\n    controls=[vm.Filter(column=\"day\"), vm.Filter(column=\"time\", selector=vm.Checklist()), vm.Filter(column=\"size\")]\n)\n\nthird_page = vm.Page(\n    title=\"Analysis\",\n    layout=vm.Grid(grid=[[0, 1], [2, 2]]),\n    components=[\n        vm.Graph(\n            id=\"bar\",\n            title=\"Where do we get more tips?\",\n            figure=px.bar(tips, y=\"tip\", x=\"day\"),\n        ),\n        vm.Graph(\n            id=\"violin\",\n            title=\"Is the average driven by a few outliers?\",\n            figure=px.violin(tips, y=\"tip\", x=\"day\", color=\"day\", box=True),\n        ),\n        vm.Graph(\n            id=\"heatmap\",\n            title=\"Which group size is more profitable?\",\n            figure=px.density_heatmap(tips, x=\"day\", y=\"size\", z=\"tip\", histfunc=\"avg\", text_auto=\"$.2f\"),\n        ),\n    ],\n    controls=[\n        vm.Parameter(\n            targets=[\"violin.x\", \"violin.color\", \"heatmap.x\", \"bar.x\"],\n            selector=vm.RadioItems(\n                options=[\"day\", \"time\", \"sex\", \"smoker\", \"size\"], value=\"day\", title=\"Change x-axis inside charts:\"\n            ),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[first_page, second_page, third_page])\nVizro().build(dashboard).run()\n</code></pre> <p></p> <p>Take a moment to interact with the parameter. Notice how the x-axis of all charts updates dynamically based on your selection.</p> <p>Isn't it amazing how effortlessly it is to shift the data analysis perspective now?</p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#54-add-a-custom-chart","level":3,"title":"5.4. Add a custom chart","text":"<p>You may notice that the <code>bar</code> chart has many inner lines. This happens because each line represents a unique data point when an unaggregated dataset is provided to <code>px.bar</code>. To avoid this, you can aggregate the data before plotting. However, the aggregation needs to be dynamic, based on the parameter you added in the previous step. The following steps create a custom chart:</p> <ol> <li>Create a function that takes the <code>data_frame</code> as input and returns a Plotly figure.</li> <li>Decorate the function with the <code>@capture(graph)</code> decorator.</li> <li>Inside the function, aggregate the data, provide a label for the chart, and update the bar width.</li> <li>Use this custom function in the <code>Graph</code> component instead of <code>px.bar</code>.</li> </ol> <p>For more information on when to create a custom chart, check out How to create custom charts.</p> <p>Add custom chart</p> Snippet - custom chartCode - dashboardResult <pre><code>@capture(\"graph\")\ndef bar_mean(data_frame, x, y):\n    df_agg = data_frame.groupby(x).agg({y: \"mean\"}).reset_index()\n    fig = px.bar(df_agg, x=x, y=y, labels={\"tip\": \"Average Tip ($)\"})\n    fig.update_traces(width=0.6)\n    return fig\n</code></pre> <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\nfrom vizro.models.types import capture\nfrom vizro.figures import kpi_card\nimport vizro.actions as va\n\ntips = px.data.tips()\n\n\n@capture(\"graph\")\ndef bar_mean(data_frame, x, y):\n    df_agg = data_frame.groupby(x).agg({y: \"mean\"}).reset_index()\n    fig = px.bar(df_agg, x=x, y=y, labels={\"tip\": \"Average Tip ($)\"})\n    fig.update_traces(width=0.6)\n    return fig\n\n\nfirst_page = vm.Page(\n    title=\"Data\",\n    components=[\n        vm.AgGrid(\n            figure=dash_ag_grid(tips),\n            footer=\"\"\"**Data Source:** Bryant, P. G. and Smith, M (1995)\n            Practical Data Analysis: Case Studies in Business Statistics.\n            Homewood, IL: Richard D. Irwin Publishing.\"\"\",\n        ),\n        vm.Button(text=\"Export Data\", actions=va.export_data()),\n    ],\n)\n\nsecond_page = vm.Page(\n    title=\"Summary\",\n    layout=vm.Grid(grid=[[0, 1, -1, -1], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]]),\n    components=[\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"total_bill\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Bill\",\n            )\n        ),\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"tip\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Tips\"\n            )\n        ),\n        vm.Tabs(\n            tabs=[\n                vm.Container(\n                    title=\"Total Bill ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"total_bill\")),\n                    ],\n                ),\n                vm.Container(\n                    title=\"Total Tips ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"tip\")),\n                    ],\n                ),\n            ],\n        )\n    ],\n    controls=[vm.Filter(column=\"day\"), vm.Filter(column=\"time\", selector=vm.Checklist()), vm.Filter(column=\"size\")]\n)\n\nthird_page = vm.Page(\n    title=\"Analysis\",\n    layout=vm.Grid(grid=[[0, 1], [2, 2]]),\n    components=[\n        vm.Graph(\n            id=\"bar\",\n            title=\"Where do we get more tips?\",\n            figure=bar_mean(tips, y=\"tip\", x=\"day\"),\n        ),\n        vm.Graph(\n            id=\"violin\",\n            title=\"Is the average driven by a few outliers?\",\n            figure=px.violin(tips, y=\"tip\", x=\"day\", color=\"day\", box=True),\n        ),\n        vm.Graph(\n            id=\"heatmap\",\n            title=\"Which group size is more profitable?\",\n            figure=px.density_heatmap(tips, x=\"day\", y=\"size\", z=\"tip\", histfunc=\"avg\", text_auto=\"$.2f\"),\n        ),\n    ],\n    controls=[\n        vm.Parameter(\n            targets=[\"violin.x\", \"violin.color\", \"heatmap.x\", \"bar.x\"],\n            selector=vm.RadioItems(\n                options=[\"day\", \"time\", \"sex\", \"smoker\", \"size\"], value=\"day\", title=\"Change x-axis inside charts:\"\n            ),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[first_page, second_page, third_page])\nVizro().build(dashboard).run()\n</code></pre> <p></p> <p>Fantastic job reaching this point!</p> <p>You've just completed the final dashboard page and learned how to:</p> <ol> <li>Add multiple charts</li> <li>Customize a layout</li> <li>Add a parameter to interact with the charts</li> <li>Add a custom chart to the dashboard</li> </ol>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#6-finishing-touches","level":2,"title":"6. Finishing touches","text":"<p>Now that you've created all the dashboard pages, let's add a title and logo, and customize the navigation.</p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#61-add-a-title-and-logo","level":3,"title":"6.1. Add a title and logo","text":"<p>The following steps add a title and logo to the dashboard:</p> <ol> <li>Set the <code>title</code> attribute of the Dashboard[vizro.models.Dashboard] model to \"Tips Analysis Dashboard\".</li> <li>Download the <code>logo</code> from this link and save it in a folder named <code>assets</code>.</li> <li>Place the <code>assets</code> folder in the same directory as your <code>app.py/app.ipynb</code> file.</li> </ol> <p>Your directory structure should look like this:</p> Example folder structure<pre><code>├── app.py\n├── assets\n│   ├── logo.svg\n</code></pre> <p>Add a dashboard title and logo</p> Snippet - dashboard titleCode - dashboardResult <pre><code>dashboard = vm.Dashboard(pages=[first_page, second_page, third_page], title=\"Tips Analysis Dashboard\")\n</code></pre> <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\nfrom vizro.models.types import capture\nfrom vizro.figures import kpi_card\nimport vizro.actions as va\n\ntips = px.data.tips()\n\n\n@capture(\"graph\")\ndef bar_mean(data_frame, x, y):\n    df_agg = data_frame.groupby(x).agg({y: \"mean\"}).reset_index()\n    fig = px.bar(df_agg, x=x, y=y, labels={\"tip\": \"Average Tip ($)\"})\n    fig.update_traces(width=0.6)\n    return fig\n\n\nfirst_page = vm.Page(\n    title=\"Data\",\n    components=[\n        vm.AgGrid(\n            figure=dash_ag_grid(tips),\n            footer=\"\"\"**Data Source:** Bryant, P. G. and Smith, M (1995)\n            Practical Data Analysis: Case Studies in Business Statistics.\n            Homewood, IL: Richard D. Irwin Publishing.\"\"\",\n        ),\n        vm.Button(text=\"Export Data\", actions=va.export_data()),\n    ],\n)\n\nsecond_page = vm.Page(\n    title=\"Summary\",\n    layout=vm.Grid(grid=[[0, 1, -1, -1], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]]),\n    components=[\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"total_bill\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Bill\",\n            )\n        ),\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"tip\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Tips\"\n            )\n        ),\n        vm.Tabs(\n            tabs=[\n                vm.Container(\n                    title=\"Total Bill ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"total_bill\")),\n                    ],\n                ),\n                vm.Container(\n                    title=\"Total Tips ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"tip\")),\n                    ],\n                ),\n            ],\n        )\n    ],\n    controls=[vm.Filter(column=\"day\"), vm.Filter(column=\"time\", selector=vm.Checklist()), vm.Filter(column=\"size\")]\n)\n\nthird_page = vm.Page(\n    title=\"Analysis\",\n    layout=vm.Grid(grid=[[0, 1], [2, 2]]),\n    components=[\n        vm.Graph(\n            id=\"bar\",\n            title=\"Where do we get more tips?\",\n            figure=bar_mean(tips, y=\"tip\", x=\"day\"),\n        ),\n        vm.Graph(\n            id=\"violin\",\n            title=\"Is the average driven by a few outliers?\",\n            figure=px.violin(tips, y=\"tip\", x=\"day\", color=\"day\", box=True),\n        ),\n        vm.Graph(\n            id=\"heatmap\",\n            title=\"Which group size is more profitable?\",\n            figure=px.density_heatmap(tips, x=\"day\", y=\"size\", z=\"tip\", histfunc=\"avg\", text_auto=\"$.2f\"),\n        ),\n    ],\n    controls=[\n        vm.Parameter(\n            targets=[\"violin.x\", \"violin.color\", \"heatmap.x\", \"bar.x\"],\n            selector=vm.RadioItems(\n                options=[\"day\", \"time\", \"sex\", \"smoker\", \"size\"], value=\"day\", title=\"Change x-axis inside charts:\"\n            ),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[first_page, second_page, third_page], title=\"Tips Analysis Dashboard\")\nVizro().build(dashboard).run()\n</code></pre> <p></p> <p>You should see the logo in the top-left corner of your dashboard header, with the title displayed next to it. If you can't see the logo, make sure the image is called <code>logo</code> and is stored in the <code>assets</code> folder. For more details on supported image formats, refer to the guide on how to add a logo.</p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#62-customize-the-navigation","level":3,"title":"6.2. Customize the navigation","text":"<p>By default, a navigation panel on the left side enables users to switch between the pages. In this section, you'll learn how to customize it by using a navigation bar with icons instead.</p> <p>The navigation bar will have two icons: one for the \"Data\" page and another for the \"Summary\" and \"Analysis\" pages.</p> <p>The following steps create a navigation bar:</p> <ol> <li>Set the <code>navigation</code> attribute of the Dashboard[vizro.models.Dashboard] model to a [Navigation][vizro.models.Navigation] object.</li> <li>Assign a [NavBar][vizro.models.NavBar] object to the <code>nav_selector</code> attribute of the <code>Navigation</code>.</li> <li>Populate the <code>items</code> of the [NavBar][vizro.models.NavBar] object with a list of [NavLink][vizro.models.NavLink] objects.</li> <li>Customize each [NavLink][vizro.models.NavLink] object by setting its <code>label</code>, <code>pages</code>, and <code>icon</code> attributes.<ul> <li>The <code>label</code> controls the text displayed in the tooltip when hovering over the navigation icon.</li> <li>The <code>pages</code> controls the pages included in the accordion navigation for that icon.</li> <li>The <code>icon</code> sets the icon to display using the Material Design Icons library.</li> </ul> </li> </ol> <p>Customize navigation</p> Snippet - navigationCode - dashboardResult <pre><code>navigation=vm.Navigation(\n    nav_selector=vm.NavBar(\n        items=[\n            vm.NavLink(label=\"Data\", pages=[\"Data\"], icon=\"Database\"),\n            vm.NavLink(label=\"Charts\", pages=[\"Summary\", \"Analysis\"], icon=\"Bar Chart\"),\n        ]\n    )\n)\n</code></pre> <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\nfrom vizro.models.types import capture\nfrom vizro.figures import kpi_card\nimport vizro.actions as va\n\ntips = px.data.tips()\n\n\n@capture(\"graph\")\ndef bar_mean(data_frame, x, y):\n    df_agg = data_frame.groupby(x).agg({y: \"mean\"}).reset_index()\n    fig = px.bar(df_agg, x=x, y=y, labels={\"tip\": \"Average Tip ($)\"})\n    fig.update_traces(width=0.6)\n    return fig\n\n\nfirst_page = vm.Page(\n    title=\"Data\",\n    components=[\n        vm.AgGrid(\n            figure=dash_ag_grid(tips),\n            footer=\"\"\"**Data Source:** Bryant, P. G. and Smith, M (1995)\n            Practical Data Analysis: Case Studies in Business Statistics.\n            Homewood, IL: Richard D. Irwin Publishing.\"\"\",\n        ),\n        vm.Button(text=\"Export Data\", actions=va.export_data()),\n    ],\n)\n\nsecond_page = vm.Page(\n    title=\"Summary\",\n    layout=vm.Grid(grid=[[0, 1, -1, -1], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]]),\n    components=[\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"total_bill\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Bill\",\n            )\n        ),\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"tip\",\n                agg_func=\"mean\",\n                value_format=\"${value:.2f}\",\n                title=\"Average Tips\"\n            )\n        ),\n        vm.Tabs(\n            tabs=[\n                vm.Container(\n                    title=\"Total Bill ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"total_bill\")),\n                    ],\n                ),\n                vm.Container(\n                    title=\"Total Tips ($)\",\n                    components=[\n                        vm.Graph(figure=px.histogram(tips, x=\"tip\")),\n                    ],\n                ),\n            ],\n        )\n    ],\n    controls=[vm.Filter(column=\"day\"), vm.Filter(column=\"time\", selector=vm.Checklist()), vm.Filter(column=\"size\")]\n)\n\nthird_page = vm.Page(\n    title=\"Analysis\",\n    layout=vm.Grid(grid=[[0, 1], [2, 2]]),\n    components=[\n        vm.Graph(\n            id=\"bar\",\n            title=\"Where do we get more tips?\",\n            figure=bar_mean(tips, y=\"tip\", x=\"day\"),\n        ),\n        vm.Graph(\n            id=\"violin\",\n            title=\"Is the average driven by a few outliers?\",\n            figure=px.violin(tips, y=\"tip\", x=\"day\", color=\"day\", box=True),\n        ),\n        vm.Graph(\n            id=\"heatmap\",\n            title=\"Which group size is more profitable?\",\n            figure=px.density_heatmap(tips, x=\"day\", y=\"size\", z=\"tip\", histfunc=\"avg\", text_auto=\"$.2f\"),\n        ),\n    ],\n    controls=[\n        vm.Parameter(\n            targets=[\"violin.x\", \"violin.color\", \"heatmap.x\", \"bar.x\"],\n            selector=vm.RadioItems(\n                options=[\"day\", \"time\", \"sex\", \"smoker\", \"size\"], value=\"day\", title=\"Change x-axis inside charts:\"\n            ),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(\n    pages=[first_page, second_page, third_page],\n    title=\"Tips Analysis Dashboard\",\n    navigation=vm.Navigation(\n        nav_selector=vm.NavBar(\n            items=[\n                vm.NavLink(label=\"Data\", pages=[\"Data\"], icon=\"Database\"),\n                vm.NavLink(label=\"Charts\", pages=[\"Summary\", \"Analysis\"], icon=\"Bar Chart\"),\n            ]\n        )\n    ),\n)\nVizro().build(dashboard).run()\n</code></pre> <p></p> <p>Take a moment to explore the navigation bar! Hover over the icons to view the tooltip text, and click on them to navigate between the pages.</p> <p>Congratulations on completing this tutorial!</p> <p>You now have the skills to configure layouts, and add components and interactivity to Vizro dashboards across multiple navigable pages.</p>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/explore-components/#7-find-out-more","level":2,"title":"7. Find out more","text":"<p>After completing the tutorial, you have a solid understanding of the main elements of Vizro and how to bring them together to create dynamic and interactive data visualizations.</p> <p>You can find out more about Vizro's components by reading the components overview page. To gain more in-depth knowledge about the usage and configuration details of individual controls, check out the guides dedicated to Filters, Parameters, and Selectors.</p> <p>If you'd like to understand more about different ways to configure the navigation of your dashboard, head to Navigation.</p> <p>Vizro doesn't end here; we've only covered the key features, but there's still much more to explore! You can learn:</p> <ul> <li>How to use other built-in actions such as cross-filters</li> <li>How to extend and customize Vizro dashboards by creating your own:<ul> <li>custom components.</li> <li>custom actions.</li> <li>custom tables.</li> <li>custom charts.</li> <li>custom figures.</li> </ul> </li> <li>How to add custom styling using static assets such as custom CSS or JavaScript files.</li> <li>How to customize your data connection</li> <li>How to create dashboards from <code>yaml</code>, <code>dict</code> or <code>json</code> following the dashboard guide.</li> <li>How to deploy your dashboard</li> <li>How to use gen AI to assist in chart and dashboard creation.<ul> <li>Vizro-MCP helps you build charts and dashboards that adhere to the Vizro design template. It is the easiest way to use a generative AI (gen AI) application to help you work with Vizro.</li> <li>Vizro-AI is also available as a means of building Vizro charts and dashboards with gen AI. You will need some technical knowledge, and an API key to use with a large language model (LLM).</li> </ul> </li> </ul>","path":["Explore Vizro"],"tags":[]},{"location":"tutorials/quickstart-tutorial/","level":1,"title":"Quickstart tutorial","text":"<p>There is no setup needed for your first dashboard, so you can get started with Vizro quickly, thanks to PyCafe.</p> <p>Click on the Run and edit this code in Py.Cafe link below to live-edit the dashboard.</p> <p>First dashboard</p> app.pyResult <pre><code>import vizro.plotly.express as px\nfrom vizro import Vizro\nimport vizro.models as vm\n\ndf = px.data.iris()\n\npage = vm.Page(\n    title=\"My first dashboard\",\n    components=[\n        vm.Graph(figure=px.scatter(df, x=\"sepal_length\", y=\"petal_width\", color=\"species\")),\n        vm.Graph(figure=px.histogram(df, x=\"sepal_width\", color=\"species\")),\n    ],\n    controls=[\n        vm.Filter(column=\"species\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <p></p>","path":["Quickstart tutorial"],"tags":[]},{"location":"tutorials/quickstart-tutorial/#can-i-break-this-code","level":2,"title":"Can I break this code?","text":"<p>When you click the link to \"Run and edit this code in Py.Cafe\" the dashboard starts running inside your browser. Any changes you make are local and you don't need to worry about breaking the code for others. Nobody else sees the changes you make unless you publish your copy of the project as your own Vizro PyCafe project.</p>","path":["Quickstart tutorial"],"tags":[]},{"location":"tutorials/quickstart-tutorial/#how-can-i-make-my-own-dashboards","level":2,"title":"How can I make my own dashboards?","text":"<p>You can use PyCafe to experiment with your own Vizro dashboards by dropping code onto a new project. Check out the PyCafe documentation for more information.</p> <p>We make all our examples available. Throughout our documentation, follow the \"Run and edit this code in Py.Cafe\" link below a code snippet to open and interact with it.</p> <p>You can also generative AI (gen AI) to help you create dashboards:</p> <ul> <li>Vizro-MCP helps you build charts and dashboards that adhere to the Vizro design template. Vizro-MCP is the easiest way to use a gen AI application to help you work with Vizro.</li> </ul> <p></p> <ul> <li>Vizro-AI is also available as a means of building Vizro charts and dashboards with gen AI. You will need some technical knowledge, and an API key to use with an large language model (LLM).</li> </ul>","path":["Quickstart tutorial"],"tags":[]},{"location":"tutorials/quickstart-tutorial/#where-next","level":2,"title":"Where next?","text":"<p>You are now ready to explore Vizro further by working through the \"Explore Vizro\" tutorial or by consulting the how-to guides.</p>","path":["Quickstart tutorial"],"tags":[]},{"location":"user-guides/actions/","level":1,"title":"How to use actions","text":"<p>Actions control how your app responds to user input such as clicking a button or a point on a graph. If an action is not built into Vizro then you can write your own custom action. In these guides we show how to use built-in actions across a range of areas:</p> <ul> <li>Handle data, for example to export data.</li> <li>Graph and table interactions, for example to cross-filter.</li> </ul> <p>A complete list of built-in actions in given in the [API documentation][vizro.actions]. We also have an in-depth tutorial on writing your own action and an explanation of how Vizro actions work.</p> <p>Note</p> <p>Do you have an idea for a built-in action? Submit a feature request!</p>","path":["How to use actions"],"tags":[]},{"location":"user-guides/actions/#general-principles","level":2,"title":"General principles","text":"<p>Many [Vizro models][vizro.models] have an <code>actions</code> argument that can contain one or more actions. Each action is a Python function that is triggered by a user interaction.</p> <p>To use an action:</p> <ol> <li>add <code>import vizro.actions as va</code> to your imports</li> <li>call the relevant action in the <code>actions</code> argument of the model that triggers the action</li> </ol> <p>You can also execute multiple actions with a single trigger.</p> <p>Some actions are typically triggered by certain components, for example <code>export_data</code> is usually triggered by clicking a button. However, many actions can be triggered by any component, for example:</p> <ul> <li>you can trigger a chart and filter interaction by clicking on a <code>card</code>. There's an illustration of this in the trigger an action with a card example.</li> </ul> <p>Note</p> <p>Unlike custom actions, built-in actions do not use the [<code>Action</code>][vizro.models.Action] model.</p>","path":["How to use actions"],"tags":[]},{"location":"user-guides/actions/#trigger-an-action-with-a-button","level":2,"title":"Trigger an action with a button","text":"<p>Here is an example action that uses the <code>export_data</code> action when a button is clicked.</p> <p>Action triggered by button</p> app.pyapp.yamlResult <pre><code>import vizro.actions as va\nimport vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\ndf = px.data.iris()\n\npage = vm.Page(\n    title=\"Action triggered by a button\",\n    components=[\n        vm.Graph(figure=px.histogram(df, x=\"sepal_length\")),\n        vm.Button(text=\"Export data\", actions=va.export_data()),\n    ],\n    controls=[vm.Filter(column=\"species\")],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - type: graph\n        figure:\n          _target_: histogram\n          x: sepal_length\n      - type: button\n        text: Export data\n        actions:\n          - type: export_data\n  - controls:\n      - type: filter\n        column: species\n    layout:\n      type: flex\n    title: Action triggered by a button\n</code></pre> <p></p> <p>When you click the \"Export data\" button, the data for all graphs, tables and figures on the page is downloaded. In this example, this will produce a csv file for the graph's source data <code>px.data.iris()</code>.</p> <p>Tip</p> <p>If you have many buttons that trigger actions then you might like to give them icons. You can even have icon-only buttons with no text.</p>","path":["How to use actions"],"tags":[]},{"location":"user-guides/actions/#trigger-an-action-with-a-graph","level":2,"title":"Trigger an action with a graph","text":"<p>Here is an example that performs a cross-filter between a graph and a table. When you click on a box in the graph, the table is cross-filtered to show data for only one sex.</p> <p>Cross-filter from graph to table</p> app.pyapp.yamlResult <pre><code>import vizro.actions as va\nimport vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\n\ntips = px.data.tips()\n\npage = vm.Page(\n    title=\"Cross-filter from graph to table\",\n    components=[\n        vm.Graph(\n            title=\"Click on a box to use that box's sex to filter table\",\n            figure=px.box(tips, x=\"tip\", y=\"sex\"),\n            actions=va.set_control(control=\"sex_filter\", value=\"y\"),\n        ),\n        vm.AgGrid(id=\"tips_table\", figure=dash_ag_grid(tips)),  # (1)!\n    ],\n    controls=[vm.Filter(id=\"sex_filter\", column=\"sex\", targets=[\"tips_table\"])],  # (2)!\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We give the <code>vm.AgGrid</code> an <code>id</code> so that it can be targeted explicitly by <code>vm.Filter(id=\"sex_filter\")</code>.</li> <li>We give the <code>vm.Filter</code> an <code>id</code> so that it can be set explicitly by <code>va.set_control</code>.</li> </ol> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - actions:\n          - control: sex_filter\n            type: set_control\n            value: y\n        figure:\n          _target_: box\n          data_frame: tips\n          x: tip\n          y: sex\n        title: Click on a box to use that box's sex to filter table\n        type: graph\n      - figure:\n          _target_: dash_ag_grid\n          data_frame: tips\n        id: tips_table\n        type: ag_grid\n    controls:\n      - column: sex\n        id: sex_filter\n        targets:\n          - tips_table\n        type: filter\n    title: Cross-filter from graph to table\n</code></pre> <p></p>","path":["How to use actions"],"tags":[]},{"location":"user-guides/actions/#multiple-actions","level":2,"title":"Multiple actions","text":"<p>When you specify multiple actions as <code>actions=[action_1, action_2, ...]</code> then Vizro chains these actions in order, so that <code>action_2</code> executes only when <code>action_1</code> has completed. You can freely mix built-in actions and custom actions in an actions chain. For more details on how actions chains execute, see our tutorial on custom actions.</p> <p>Here is an example actions chain that uses a custom <code>action_function</code> action and the built-in <code>export_data</code> action:</p> <pre><code>import vizro.actions as va\nimport vizro.models as vm\n\nactions = [\n    va.export_data(),\n    vm.Action(\n        function=action_function(\"input_id_1\", \"input_id_2\"),\n        outputs=\"output_id\",\n    ),\n]\n</code></pre>","path":["How to use actions"],"tags":[]},{"location":"user-guides/assets/","level":1,"title":"How to add static assets","text":"<p>This guide shows you how to add static assets to your dashboard. Static assets are images that you would like to show in your dashboard, or custom CSS and JS files with which you would like to enhance/change the appearance of your dashboard.</p> <p>To add images, custom CSS or JS files, create a folder named <code>assets</code> in the root of your app directory and insert your files. Assets included in that folder are automatically served after serving Vizro's static files via the <code>external_stylesheets</code> and <code>external_scripts</code> arguments of Dash. The user's <code>assets</code> folder thus always takes precedence.</p> Example folder structure<pre><code>├── app.py\n└── assets\n    ├── css\n    │   └── **/*.css\n    ├── images\n    │   ├── icons\n    │   │   └── collections.svg\n    │   ├── app.svg\n    │   └── logo.svg\n    └── favicon.ico\n</code></pre>","path":["How to add static assets"],"tags":[]},{"location":"user-guides/assets/#change-the-favicon","level":2,"title":"Change the favicon","text":"<p>To change the default favicon (website icon appearing in the browser tab), add a file named <code>favicon.ico</code> to your <code>assets</code> folder. For more information, see the Dash documentation.</p>","path":["How to add static assets"],"tags":[]},{"location":"user-guides/assets/#add-a-logo-image","level":2,"title":"Add a logo image","text":"","path":["How to add static assets"],"tags":[]},{"location":"user-guides/assets/#single-logo","level":3,"title":"Single logo","text":"<p>If an image named <code>logo.&lt;extension&gt;</code> is present in the assets folder, Vizro automatically incorporates the logo in the top-left corner of the dashboard. By default, clicking the logo redirects to the homepage.</p> <p>Supported image extensions: <code>apng</code>, <code>avif</code>, <code>gif</code>, <code>jpeg</code>, <code>jpg</code>, <code>png</code>, <code>svg</code>, and <code>webp</code></p>","path":["How to add static assets"],"tags":[]},{"location":"user-guides/assets/#theme-specific-logos","level":3,"title":"Theme-specific logos","text":"<p>You can also supply two images named <code>logo_dark.&lt;extension&gt;</code> and <code>logo_light.&lt;extension&gt;</code> to switch logos based on the theme (dark or light).</p> <p>Note that both <code>logo_light.&lt;extension&gt;</code> and <code>logo_dark.&lt;extension&gt;</code> must be supplied together, unless a single <code>logo.&lt;extension&gt;</code> is supplied for both light and dark themes. That is, the valid configurations are as follows:</p> <ul> <li>Single logo: Supply only <code>logo.&lt;extension&gt;</code>, which is used for dark and light themes. Do not include light and dark theme logos.</li> <li>Theme logos: Supply both <code>logo_light.&lt;extension&gt;</code> and <code>logo_dark.&lt;extension&gt;</code> for light/dark themes. Do not include <code>logo.&lt;extension&gt;</code>.</li> <li>No logo: No logo images supplied.</li> </ul> <p> </p>","path":["How to add static assets"],"tags":[]},{"location":"user-guides/assets/#change-the-assets-folder-path","level":2,"title":"Change the <code>assets</code> folder path","text":"<p>If you do not want to place your <code>assets</code> folder in the root directory of your app, you can specify an alternative path through the <code>assets_folder</code> argument of the [<code>Vizro</code>][vizro.Vizro] class.</p> <pre><code>Vizro(assets_folder=\"path/to/assets/folder\").build(dashboard).run()\n</code></pre>","path":["How to add static assets"],"tags":[]},{"location":"user-guides/assets/#include-a-meta-tags-image","level":2,"title":"Include a meta tags image","text":"<p>Vizro automatically adds meta tags to display a preview card when your app is shared on social media and chat clients. To include an image in the preview, place an image file in the assets folder named <code>app.&lt;extension&gt;</code> or <code>logo.&lt;extension&gt;</code>. Vizro searches the assets folder and uses the first one it finds.</p> <p>Image types of <code>apng</code>, <code>avif</code>, <code>gif</code>, <code>jpeg</code>, <code>jpg</code>, <code>png</code>, <code>svg</code>, and <code>webp</code> are supported.</p>","path":["How to add static assets"],"tags":[]},{"location":"user-guides/assets/#order-of-serving-css-files","level":2,"title":"Order of serving CSS files","text":"<p>CSS properties will be applied with the last served file taking precedence. The order of serving is:</p> <ol> <li>Dash built-in stylesheets</li> <li>Vizro built-in stylesheets</li> <li>User assets folder stylesheets</li> </ol> <p>Within each of these categories, individual files are served in alphanumeric order.</p>","path":["How to add static assets"],"tags":[]},{"location":"user-guides/assets/#alternative-styling-approaches","level":2,"title":"Alternative styling approaches","text":"<p>While the <code>assets</code> folder is perfect for adding your own files and overriding specific styles via custom CSS, you may also want to completely replace Vizro's default Bootstrap theme with a different one. For comprehensive theme changes, you can use the <code>external_stylesheets</code> argument to load third-party Bootstrap themes that will replace Vizro's default styling entirely.</p> <p>For detailed instructions on how to implement Bootstrap themes, see our guide on themes.</p>","path":["How to add static assets"],"tags":[]},{"location":"user-guides/button/","level":1,"title":"How to use buttons","text":"<p>This guide shows you how to use buttons to interact with your data in the dashboard.</p> <p>The Button component is commonly used for dashboard interactions such as form submissions, navigation links, and other action triggers. It is based on the underlying Dash component <code>dbc.Button</code>.</p> <p>To add a [<code>Button</code>][vizro.models.Button], insert it into the <code>components</code> argument of the [<code>Page</code>][vizro.models.Page] model.</p>","path":["How to use buttons"],"tags":[]},{"location":"user-guides/button/#customize-button-text","level":2,"title":"Customize button text","text":"<p>You can configure the <code>text</code> argument to alter the display text of the [<code>Button</code>][vizro.models.Button].</p> <p>Customize text</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"Button with text\",\n    components=[vm.Button(text=\"I'm a button!\")],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - type: button\n        text: I'm a button!\n    title: Button with text\n</code></pre> <p></p>","path":["How to use buttons"],"tags":[]},{"location":"user-guides/button/#create-a-link-button","level":2,"title":"Create a link button","text":"<p>To navigate to a different page using a button with an anchor tag, assign an absolute or relative URL to the <code>Button.href</code>.</p> <pre><code>import vizro.models as vm\n\nvm.Button(text=\"Leave us a star! ⭐\", href=\"https://github.com/mckinsey/vizro\")\n</code></pre>","path":["How to use buttons"],"tags":[]},{"location":"user-guides/button/#trigger-an-action","level":2,"title":"Trigger an action","text":"<p>You can use the [<code>Button</code>][vizro.models.Button] to trigger actions. These actions could be built-in or custom. Use the <code>Button.actions</code> argument to configure the action that executes when the button is clicked.</p> <p>The example below shows how to configure a button that exports the filtered data from a target chart using the <code>export_data</code> action.</p> <p>If your app includes several action buttons, consider adding icons. You can also use icon-only buttons without text, but keep in mind that these work best when the icon is universally recognizable (for example, a download arrow for exports). For less common actions, you should include text on your button to make it clear what it does.</p> <p>Button with action</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nimport vizro.actions as va\n\ndf = px.data.iris()\n\npage = vm.Page(\n    title=\"My first page\",\n    layout=vm.Flex(),  # (1)!\n    components=[\n        vm.Graph(\n            figure=px.scatter(\n                df,\n                x=\"sepal_width\",\n                y=\"sepal_length\",\n                color=\"species\",\n                size=\"petal_length\",\n            ),\n        ),\n        vm.Button(\n            text=\"Export data\",\n            actions=va.export_data(),\n        ),\n    ]\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We use a <code>Flex</code> layout to make sure the <code>Graph</code> and <code>Button</code> only occupy as much space as they need, rather than being distributed evenly.</li> </ol> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: scatter\n          x: sepal_width\n          y: sepal_length\n          color: species\n          size: petal_length\n          data_frame: iris\n        type: graph\n      - type: button\n        text: Export data\n        id: export_data\n        actions:\n          - type: export_data\n    layout:\n      type: flex\n    title: My first page\n</code></pre> <p></p>","path":["How to use buttons"],"tags":[]},{"location":"user-guides/button/#use-as-a-control","level":2,"title":"Use as a control","text":"<p>The [<code>Button</code>][vizro.models.Button] component is currently reserved to be used inside the main panel (right-side) of the dashboard. However, there might be use cases where one would like to place the <code>Button</code> inside the control panel (left-side) with the other controls.</p> <p>In this case, follow the user-guide outlined for creating custom components and manually add the <code>Button</code> as a valid type to the <code>controls</code> argument by running the following lines before your dashboard configurations:</p> <pre><code>from vizro import Vizro\nimport vizro.models as vm\n\nvm.Page.add_type(\"controls\", vm.Button)\n\n# Add dashboard configurations below\n...\n</code></pre>","path":["How to use buttons"],"tags":[]},{"location":"user-guides/button/#styled-buttons","level":2,"title":"Styled buttons","text":"<p>There are three predefined button styles that can be customized using the <code>variant</code> argument. If no <code>variant</code> is specified, the default style applied is <code>variant=\"filled\"</code>.</p> <p>Button with different styles</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"Buttons with different styles\",\n    layout=vm.Flex(direction=\"row\"),  # (1)!\n    components=[\n        vm.Button(text=\"filled\"),\n        vm.Button(text=\"outlined\", variant=\"outlined\"),\n        vm.Button(text=\"plain\", variant=\"plain\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We use a <code>Flex</code> layout with <code>direction=\"row\"</code> to ensure the <code>Button</code> components are placed side by side and only take up as much space as needed.</li> </ol> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - title: Buttons with different styles\n    layout:\n      direction: row\n      type: flex\n    components:\n      - type: button\n        text: filled\n      - type: button\n        text: outlined\n        variant: outlined\n      - type: button\n        text: plain\n        variant: plain\n</code></pre> <p></p>","path":["How to use buttons"],"tags":[]},{"location":"user-guides/button/#add-a-tooltip","level":2,"title":"Add a tooltip","text":"<p>The <code>description</code> argument enables you to add helpful context to your button by displaying an info icon next to its text. Hovering over the icon shows a tooltip with your chosen text.</p> <p>You can provide Markdown text as a string to use the default info icon or a [<code>Tooltip</code>][vizro.models.Tooltip] model to use any icon from the Google Material Icons library.</p> <p>Button with a tooltip</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"Buttons with tooltip\",\n    components=[\n        vm.Button(\n            text=\"Click me!\",\n            description=\"Once you click this button, the process will start.\",\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code>pages:\n  - title: Buttons with tooltip\n    components:\n      - type: button\n        text: Click me!\n        description: Once you click this button, the process will start.\n</code></pre> <p></p>","path":["How to use buttons"],"tags":[]},{"location":"user-guides/button/#add-an-icon","level":2,"title":"Add an icon","text":"<p>The <code>icon</code> argument enables you to add an icon to your button, using any icon from the Google Material Icons library.</p> <p>You can use it alongside the <code>text</code> argument, or on its own to create a circular icon-only button.</p> <p>Button with an icon</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"Buttons with an icon\",\n    layout=vm.Flex(),\n    components=[\n        vm.Button(\n            icon=\"Download\",\n            description=\"Download the data!\",\n            variant=\"outlined\",\n        ),\n        vm.Graph(\n            figure=px.scatter(\n                iris,\n                x=\"sepal_width\",\n                y=\"sepal_length\",\n                color=\"species\",\n                size=\"petal_length\",\n            ),\n        ),\n        vm.Button(\n            text=\"View Data Source\",\n            href=\"https://www.kaggle.com/datasets/uciml/iris\",\n            icon=\"Link\",\n            variant=\"outlined\",\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code>pages:\n  - title: Buttons with an icon\n    components:\n      - type: button\n        icon: Download\n        description: Download the data!\n        actions:\n          - type: export_data\n      - figure:\n          _target_: scatter\n          x: sepal_width\n          y: sepal_length\n          color: species\n          size: petal_length\n          data_frame: iris\n        type: graph\n      - type: button\n        text: Visit link to learn more!\n        href: https://www.kaggle.com/datasets/uciml/iris\n        icon: Link\n        variant: outlined\n</code></pre> <p></p>","path":["How to use buttons"],"tags":[]},{"location":"user-guides/button/#the-extra-argument","level":2,"title":"The <code>extra</code> argument","text":"<p>The <code>Button</code> is based on the underlying Dash component <code>dbc.Button</code>. Using the <code>extra</code> argument you can pass more arguments to <code>dbc.Button</code> in order to alter it beyond the chosen defaults.</p> <p>Warning</p> <p>Using <code>extra</code> is a quick and flexible way to alter a component beyond what Vizro offers. However, it is not a part of the official Vizro schema and the underlying implementation details may change. If you want to guarantee that your apps keep running, we recommend that you pin your Vizro version.</p> <p>An example use would be to create an outlined success button. For this, you can use <code>extra={\"color\": \"success\", \"outline\": True}</code>. This would be a shortcut to using custom CSS in the assets folder as explained in our guide on CSS.</p> <p>Button with custom style</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"Button with custom style\",\n    components=[\n        vm.Button(\n            text=\"Success button\",\n            extra={\"color\": \"success\", \"outline\": True},\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code>pages:\n  - title: Button with custom style\n    components:\n      - type: button\n        text: Success button\n        extra:\n          color: success\n          outline: true\n</code></pre> <p></p>","path":["How to use buttons"],"tags":[]},{"location":"user-guides/card/","level":1,"title":"How to use cards","text":"<p>This guide shows you how to use cards in your dashboard.</p> <p>Card and Text components</p> <p>The <code>Card</code> component and <code>Text</code> component both enable you to add text to your page using Markdown syntax through the underlying Dash component <code>dcc.Markdown</code>.</p> <p>You should use <code>Text</code> to display plain Markdown text without any extra styling like borders or background, for example to add an introductory paragraph to your page.</p> <p>You should use <code>Card</code> to display Markdown text that needs attention drawn to it. Generally, this would be relatively short portions of text. Unlike <code>Text</code>, a <code>Card</code> can also be used for navigation.</p> <p>You can add a [<code>Card</code>][vizro.models.Card] to your dashboard by inserting the [<code>Card</code>][vizro.models.Card] into the <code>components</code> argument of the [<code>Page</code>][vizro.models.Page] or [<code>Container</code>][vizro.models.Container] models.</p> <p>Card</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"Card\",\n    layout=vm.Flex(),  # (1)!\n    components=[\n        vm.Card(\n            text=\"\"\"\n                ### Card Title\n                Commodi repudiandae consequuntur voluptatum.\n            \"\"\",\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We use a <code>Flex</code> layout to ensure the <code>Card</code> only occupies the vertical space it needs. Without this, it would default to filling the entire available space.</li> </ol> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          Commodi repudiandae consequuntur voluptatum.\n        title: Card Title\n        type: card\n    layout:\n      type: flex\n    title: Card\n</code></pre> <p></p>","path":["How to use cards"],"tags":[]},{"location":"user-guides/card/#customize-card-text","level":2,"title":"Customize card text","text":"<p>The [<code>Card</code>][vizro.models.Card] uses the <code>dcc.Markdown</code> component from Dash as its underlying text component. For more details on customizing the Markdown text, refer to the <code>dcc.Markdown</code> component documentation. Based on examples from Dash, the [<code>Card</code>][vizro.models.Card] model supports the following:</p> <ul> <li>Headers</li> <li>Emphasis</li> <li>Lists</li> <li>Block Quotes</li> <li>Images</li> <li>Links</li> </ul> <p>Card using markdown</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"Customizing Text\",  # (1)!\n    components=[\n        vm.Card(\n            text=\"\"\"\n                # Header level 1 &lt;h1&gt;\n\n                ## Header level 2 &lt;h2&gt;\n\n                ### Header level 3 &lt;h3&gt;\n\n                #### Header level 4 &lt;h4&gt;\n            \"\"\",\n        ),\n        vm.Card(\n            text=\"\"\"\n                 ### Paragraphs\n                 Commodi repudiandae consequuntur voluptatum laborum numquam blanditiis harum quisquam eius sed odit.\n\n                 Fugiat iusto fuga praesentium option, eaque rerum! Provident similique accusantium nemo autem.\n\n                 Obcaecati tenetur iure eius earum ut molestias architecto voluptate aliquam nihil, eveniet aliquid.\n\n                 Culpa officia aut! Impedit sit sunt quaerat, odit, tenetur error, harum nesciunt ipsum debitis quas.\n            \"\"\",\n        ),\n        vm.Card(\n            text=\"\"\"\n                ### Block Quotes\n\n                &gt;\n                &gt; A block quote is a long quotation, indented to create a separate block of text.\n                &gt;\n            \"\"\",\n        ),\n        vm.Card(\n            text=\"\"\"\n                ### Lists\n\n                * Item A\n                    * Sub Item 1\n                    * Sub Item 2\n                * Item B\n            \"\"\",\n        ),\n        vm.Card(\n            text=\"\"\"\n                ### Emphasis\n\n                This word will be *italic*\n\n                This word will be **bold**\n\n                This word will be _**bold and italic**_\n            \"\"\",\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>Note that we don't explicitly define a <code>layout</code> here, so it defaults to the [<code>Grid</code>][vizro.models.Grid] model. This layout automatically arranges all components to fit on a single page, giving each one equal space. As a result, all <code>Card</code> components are evenly sized and fill the entire screen.</li> </ol> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          # Header level 1 &lt;h1&gt;\n\n          ## Header level 2 &lt;h2&gt;\n\n          ### Header level 3 &lt;h3&gt;\n\n          #### Header level 4 &lt;h4&gt;\n        type: card\n      - text: |\n          Commodi repudiandae consequuntur voluptatum laborum numquam blanditiis harum quisquam eius sed odit.\n\n          Fugiat iusto fuga praesentium option, eaque rerum! Provident similique accusantium nemo autem.\n\n          Obcaecati tenetur iure eius earum ut molestias architecto voluptate aliquam nihil, eveniet aliquid.\n\n          Culpa officia aut! Impedit sit sunt quaerat, odit, tenetur error, harum nesciunt ipsum debitis quas.\n        title: Paragraphs\n        type: card\n      - text: |\n          &gt;\n          &gt; A block quote is a long quotation, indented to create a separate block of text.\n          &gt;\n        title: Block Quotes\n        type: card\n      - text: |\n          * Item A\n            * Sub Item 1\n            * Sub Item 2\n          * Item B\n        title: Lists\n        type: card\n      - text: |\n          This word will be *italic*\n\n          This word will be **bold**\n\n          This word will be _**bold and italic**_\n        title: Emphasis\n        type: card\n    title: Customizing Text\n</code></pre> <p></p>","path":["How to use cards"],"tags":[]},{"location":"user-guides/card/#add-header-and-footer","level":2,"title":"Add header and footer","text":"<p>You can now add a header and footer to your [<code>Card</code>][vizro.models.Card] by using the <code>header</code> and <code>footer</code> arguments. Both fields support Markdown text, so you can easily include text, links, and inline formatting.</p> <p>Card with header and footer</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"Card with header and footer\",\n    components=[\n        vm.Card(\n            text=\"Commodi repudiandae consequuntur voluptatum.\",\n            header=\"Lorem ipsum header\",\n            footer=\"Lorem ipsum footer\",\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          Commodi repudiandae consequuntur voluptatum.\n        header: Lorem ipsum header\n        footer: Lorem ipsum footer\n        type: card\n    title: Card with header and footer\n</code></pre> <p></p>","path":["How to use cards"],"tags":[]},{"location":"user-guides/card/#place-an-image-on-a-card","level":2,"title":"Place an image on a card","text":"<p>Images can be added to the <code>text</code> parameter by using the standard markdown syntax:</p> <p><code>![Image ALT text](Image URL)</code></p> <p>An image ALT text offers a description to your image and serves as a text placeholder or to improve the accessibility of your app. Providing an image ALT text is optional.</p> <ol> <li>To use a relative Image URL, place an image of your choice into your <code>assets</code> folder first</li> <li>Use markdown to render your image by using one of the following syntax:<ul> <li>Relative Image URL: <code>![Image ALT text](/path/to/image.png)</code></li> <li>Absolute Image URL: <code>![Image ALT text](https://XXXXXX)</code></li> </ul> </li> </ol> <p>Card with image</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n     title=\"Placing Images\",\n     components=[\n         vm.Card(\n             text=\"\"\"\n             ### My card with image!\n\n             ![continent](assets/images/continents/africa.svg)\n\n              Commodi repudiandae consequuntur voluptatum laborum numquam blanditiis harum quisquam eius sed odit.\n\n              Fugiat iusto fuga praesentium option, eaque rerum! Provident similique accusantium nemo autem.\n\n              Obcaecati tenetur iure eius earum ut molestias architecto voluptate aliquam nihil, eveniet aliquid.\n         \"\"\",\n         ),\n     ],\n )\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <p>Run and edit this code in PyCafe</p> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          ![continent](assets/images/continents/africa.svg)\n\n          Commodi repudiandae consequuntur voluptatum laborum numquam blanditiis harum quisquam eius sed odit.\n\n          Fugiat iusto fuga praesentium option, eaque rerum! Provident similique accusantium nemo autem.\n\n          Obcaecati tenetur iure eius earum ut molestias architecto voluptate aliquam nihil, eveniet aliquid.\n        title: My card with image!\n        type: card\n    title: Placing Images\n</code></pre> <p></p> <p>Note</p> <p>Note that inserting images using HTML is by default turned off by the <code>dcc.Markdown</code> to prevent users being exposed to cross-site scripting attacks. If you need to turn it on, a custom component would have to be created.</p> <p>You might notice that the image is quite large. You'll find out how to style images in terms of their position and size in the next section.</p>","path":["How to use cards"],"tags":[]},{"location":"user-guides/card/#change-image-dimensions","level":2,"title":"Change image dimensions","text":"<p>To change the size or position of the image, add a URL hash to your image like this:</p> <p><code>![Image ALT text](Image URL#my-image)</code></p> <p>Note the added URL hash <code>#my-image</code>. Now create a CSS file placed in your <code>assets</code> folder and give an attribute selector to select images with that matching URL hash.</p> <p>Card with styled image</p> images.cssapp.pyapp.yamlResult <pre><code>img[src*=\"#my-image\"] {\n    width: 120px;\n    height: 120px;\n}\n</code></pre> <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"Styling Images\",\n    layout=vm.Flex(),  # (1)!\n    components=[\n       vm.Card(\n             text=\"\"\"\n             ### My card with image!\n\n             ![](assets/images/continents/europe.svg#my-image)\n\n              Commodi repudiandae consequuntur voluptatum laborum numquam blanditiis harum quisquam eius sed odit.\n\n              Fugiat iusto fuga praesentium option, eaque rerum! Provident similique accusantium nemo autem.\n\n              Obcaecati tenetur iure eius earum ut molestias architecto voluptate aliquam nihil, eveniet aliquid.\n         \"\"\"\n       ),\n    ]\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We use a <code>Flex</code> layout to ensure the <code>Card</code> only occupies the vertical space it needs. Without this, it would default to filling the entire available space.</li> </ol> <p>Run and edit this code in PyCafe</p> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          ![](assets/images/continents/europe.svg#my-image)\n\n          Commodi repudiandae consequuntur voluptatum laborum numquam blanditiis harum quisquam eius sed odit.\n\n          Fugiat iusto fuga praesentium option, eaque rerum! Provident similique accusantium nemo autem.\n\n          Obcaecati tenetur iure eius earum ut molestias architecto voluptate aliquam nihil, eveniet aliquid.\n        title: My card with image!\n        type: card\n    layout:\n      type: flex\n    title: Styling Images\n</code></pre> <p></p> <p>Use the following URL hashes in your image path to apply Vizro's default styling.</p>","path":["How to use cards"],"tags":[]},{"location":"user-guides/card/#float-an-image-inside-the-card","level":2,"title":"Float an image inside the card","text":"<p>To float an image for example to the right of the text, use the <code>src</code> attribute as a CSS selector. Follow these steps:</p> <ol> <li>Add a hash (#) to the image URL, e.g., <code>![](assets/images/continents/europe.svg#my-image)</code></li> <li>Target that hash in your custom CSS file <code>img[src*=\"#my-image\"] { float: right; }</code></li> </ol> <p>Card with floating image</p> images.cssapp.pyapp.yamlResult <pre><code>img[src*=\"#my-image\"] {\n    width: 120px;\n    height: 120px;\n    float: right;\n}\n</code></pre> <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n     title=\"Floating Images\",\n     layout=vm.Flex(),  # (1)!\n     components=[\n         vm.Card(\n             text=\"\"\"\n             ### My card with floating image!\n\n             ![](assets/images/continents/europe.svg#my-image)\n\n             Commodi repudiandae consequuntur voluptatum laborum numquam blanditiis harum quisquam eius sed odit.\n\n             Fugiat iusto fuga praesentium option, eaque rerum! Provident similique accusantium nemo autem.\n\n             Obcaecati tenetur iure eius earum ut molestias architecto voluptate aliquam nihil, eveniet aliquid.\n\n             Culpa officia aut! Impedit sit sunt quaerat, odit, tenetur error, harum nesciunt ipsum debitis quas.\n\n             Obcaecati tenetur iure eius earum ut molestias architecto voluptate aliquam nihil, eveniet aliquid.\n\n             Culpa officia aut! Impedit sit sunt quaerat, odit, tenetur error, harum nesciunt ipsum debitis quas.\n         \"\"\",\n         ),\n     ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We use a <code>Flex</code> layout to ensure the <code>Card</code> only occupies the vertical space it needs. Without this, it would default to filling the entire available space.</li> </ol> <p>Run and edit this code in PyCafe</p> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          ![](assets/images/continents/europe.svg#my-image)\n\n          Commodi repudiandae consequuntur voluptatum laborum numquam blanditiis harum quisquam eius sed odit.\n\n          Fugiat iusto fuga praesentium option, eaque rerum! Provident similique accusantium nemo autem.\n\n          Obcaecati tenetur iure eius earum ut molestias architecto voluptate aliquam nihil, eveniet aliquid.\n\n          Culpa officia aut! Impedit sit sunt quaerat, odit, tenetur error, harum nesciunt ipsum debitis quas.\n\n          Obcaecati tenetur iure eius earum ut molestias architecto voluptate aliquam nihil, eveniet aliquid.\n\n          Culpa officia aut! Impedit sit sunt quaerat, odit, tenetur error, harum nesciunt ipsum debitis quas.\n        title: My card with floating image!\n        type: card\n    layout:\n      type: flex\n    title: Floating Images\n</code></pre> <p></p>","path":["How to use cards"],"tags":[]},{"location":"user-guides/card/#make-an-icon-responsive-to-theme-switch","level":2,"title":"Make an icon responsive to theme switch","text":"<p>To make an icon responsive to theme switching, override its <code>filter</code> CSS property.</p> <p>In this example, we use the <code>--fill-icon-image-card</code> CSS variable from the <code>vizro-bootstrap</code> CSS file. It uses the <code>invert()</code> function to flip the icon's color during a theme switch.</p> <p>This approach works if your icon initially has a white fill color. If not, modify the SVG code by adding <code>fill=\"white\"</code>.</p> <pre><code>img[src*=\"#my-image\"] {\n    filter: var(--fill-icon-image-card);\n}\n</code></pre> <p>Responsive icon</p> <p></p>","path":["How to use cards"],"tags":[]},{"location":"user-guides/card/#create-a-navigation-card","level":2,"title":"Create a navigation card","text":"<p>This section describes how to use the [<code>Card</code>][vizro.models.Card] component to create a navigation card, enabling users to navigate to another page by clicking on the card area.</p> <p>For a button-style link navigation component, see the separate guide on creating a link button. To configure the navigation panel on the left hand side of the screen, refer to the separate guide on navigation.</p> <p>To create a navigation card:</p> <ol> <li>Insert the [<code>Card</code>][vizro.models.Card] into the <code>components</code> argument of the [<code>Page</code>][vizro.models.Page].</li> <li>Pass your Markdown text to the <code>Card.text</code>.</li> <li>Pass a relative or absolute URL to the <code>Card.href</code>.</li> </ol> <p>Navigation Card</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\niris = px.data.iris()\n\npage_1 = vm.Page(\n    title=\"Homepage\",\n    components=[\n        vm.Card(\n            text=\"\"\"\n            ### Filters and parameters\n\n            Leads to the first page on click.\n            \"\"\",\n            href=\"/filters-and-parameters\",\n        ),\n        vm.Card(\n            text=\"\"\"\n            ### Google - External Link\n\n            Leads to an external link on click.\n            \"\"\",\n            href=\"https://google.com\",\n        ),\n    ],\n)\n\npage_2 = vm.Page(\n    title=\"Filters and parameters\",\n    components=[\n        vm.Graph(figure=px.scatter(iris, x=\"sepal_length\", y=\"petal_width\", color=\"sepal_width\")),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page_1, page_2])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          ### Filters and parameters\n\n          Leads to the first page on click\n        href: /filters-and-parameters\n        type: card\n      - text: |\n          ### Google - External Link\n\n          Leads to an external link on click.\n        href: https://google.com\n        type: card\n    title: Homepage\n  - components:\n      - figure:\n          _target_: scatter\n          color: sepal_width\n          data_frame: iris\n          x: sepal_length\n          y: petal_width\n        type: graph\n    title: Filters and parameters\n</code></pre> <p></p> <p>If you now click on the card area, you should automatically be redirected to the relevant <code>href</code>.</p> <p>Note</p> <p>When using the [<code>Card</code>][vizro.models.Card], keep the following in mind:</p> <ul> <li>If the href given is a relative URL, it should match the <code>path</code> of the [<code>Page</code>][vizro.models.Page] that the [<code>Card</code>][vizro.models.Card] should navigate to.</li> <li>If the href given is an absolute link, it should start with <code>https://</code> or an equivalent protocol.</li> </ul>","path":["How to use cards"],"tags":[]},{"location":"user-guides/card/#create-a-kpi-card","level":2,"title":"Create a KPI card","text":"<p>To create a KPI card, use the existing KPI card functions from <code>vizro.figures</code>. Unlike the static text card <code>vm.Card</code>, a KPI card must be created using a figure function, which enables the text content of the KPI to change based on input from controls.</p> <p>For detailed examples on how to create a KPI card, refer to the figure user guide on KPI cards.</p>","path":["How to use cards"],"tags":[]},{"location":"user-guides/card/#add-a-tooltip","level":2,"title":"Add a tooltip","text":"<p>Use the <code>description</code> argument to add helpful context to your <code>Card</code>. This displays an info icon in the top-right corner, and hovering over it reveals a tooltip with your chosen text.</p> <p>You can provide Markdown text to the <code>description</code> argument to use the default info icon, or pass a [<code>Tooltip</code>][vizro.models.Tooltip] model to customize the icon using any symbol from the Google Material Icons library.</p> <p>Card with a tooltip</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"Card with a tooltip\",\n    components=[\n        vm.Card(\n            text=\"Commodi repudiandae consequuntur voluptatum.\",\n            header=\"Lorem ipsum\",\n            description=\"Lorem Ipsum is simply dummy text of the printing and typesetting industry. \"\n                        \"Lorem Ipsum has been the industry's standard dummy text ever since the 1500s.\",\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          Commodi repudiandae consequuntur voluptatum.\n        header: Lorem ipsum\n        description: |\n          Lorem Ipsum is simply dummy text of the printing and typesetting industry.\n\n          Lorem Ipsum has been the industry's standard dummy text ever since the 1500s\n        type: card\n    title: Card with a tooltip\n</code></pre> <p></p>","path":["How to use cards"],"tags":[]},{"location":"user-guides/card/#trigger-an-action-with-a-card","level":2,"title":"Trigger an action with a card","text":"<p>The example below shows how to use the [set_control action][vizro.actions.set_control] to filter another Graph or Table when a [<code>Card</code>][vizro.models.Card] is clicked.</p> <p>Action triggered by card</p> app.pyapp.yamlResult <pre><code>import vizro.actions as va\nimport vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\ndf = px.data.iris()\n\npage = vm.Page(\n    title=\"Action triggered by a card\",\n    components=[\n        vm.Card(text=\"Filter: Setosa\", actions=va.set_control(control=\"filter-id-1\", value=\"setosa\")),\n        vm.Card(text=\"Filter: Virginica\", actions=va.set_control(control=\"filter-id-1\", value=\"virginica\")),\n        vm.Card(text=\"Filter: Versicolor\", actions=va.set_control(control=\"filter-id-1\", value=\"versicolor\")),\n        vm.Graph(figure=px.scatter(df, x=\"sepal_width\", y=\"sepal_length\", color=\"species\")),\n    ],\n    controls=[vm.Filter(id=\"filter-id-1\", column=\"species\")],\n    layout=vm.Grid(grid=[[0, 1, 2], [3, 3, 3], [3, 3, 3]])\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - type: card\n        text: Filter: Setosa\n        actions:\n          - type: set_control\n            value: setosa\n      - type: card\n        text: Filter: Viriginica\n        actions:\n          - type: set_control\n            value: virginica\n      - type: card\n        text: Filter: Versicolor\n        actions:\n          - type: set_control\n            value: versicolor\n      - type: graph\n        figure:\n          _target_: scatter\n          x: sepal_width\n          y: sepal_length\n          color: species\n      - type: button\n        text: Export data\n        actions:\n          - type: export_data\n    controls:\n      - type: filter\n        id: filter-id-1\n        column: species\n    layout:\n      - type: grid\n        grid: [[0, 1, 2], [3, 3, 3], [3, 3, 3]]\n    title: Action triggered by a card\n</code></pre> <p></p>","path":["How to use cards"],"tags":[]},{"location":"user-guides/card/#the-extra-argument","level":2,"title":"The <code>extra</code> argument","text":"<p>The <code>Card</code> is based on the underlying Dash component <code>dbc.Card</code>. Using the <code>extra</code> argument you can pass extra arguments to <code>dbc.Card</code> in order to alter it beyond the chosen defaults.</p> <p>Note</p> <p>Using <code>extra</code> is a quick and flexible way to alter a component beyond what Vizro offers. However, it is not a part of the official Vizro schema and the underlying implementation details may change. If you want to guarantee that your apps keep running, we recommend that you pin your Vizro version.</p> <p>An example use would be to specify a fixed <code>Card</code> height and width. For this, you can use <code>extra={\"style\": {\"height\": \"100px\", \"width\": \"200px\"}}</code>. This would be a shortcut to using custom CSS in the assets folder as explained in our guide on CSS.</p> <p>Card with limited height</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n     title=\"Card with fixed dimensions\",\n     components=[\n         vm.Card(\n             text=\"This card has fixed dimensions 200x100.\",\n             extra={\"style\": {\"height\": \"100px\", \"width\": \"200px\"}},\n         ),\n     ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code>pages:\n  - title: Card with fixed dimensions\n    components:\n      - type: card\n        text: This card has fixed dimensions 200x100.\n        extra:\n          style:\n            height: 100px\n            width: 200px\n</code></pre> <p></p>","path":["How to use cards"],"tags":[]},{"location":"user-guides/components/","level":1,"title":"Components","text":"<p>The [<code>Page</code>][vizro.models.Page] model accepts the <code>components</code> argument, where you can enter any of the components listed below to fill your dashboard with visuals.</p> <ul> <li> <p> Graph</p> <p>Visualize data with any Plotly chart.</p> <p> View user guide</p> </li> <li> <p> Table</p> <p>Visualize tabular data.</p> <p> View user guide</p> </li> <li> <p> Figure</p> <p>Make any Dash component reactive.</p> <p> View user guide</p> </li> <li> <p> Card</p> <p>Call out text or display KPIs.</p> <p> View user guide</p> </li> <li> <p> Button</p> <p>Navigate to different URLs or trigger an action.</p> <p> View user guide</p> </li> <li> <p> Text</p> <p>Display plain text, add images, links and more.</p> <p> View user guide</p> </li> <li> <p> Container</p> <p>Group components into sections and subsections.</p> <p> View user guide</p> </li> <li> <p> Tab</p> <p>Group containers and navigate between them.</p> <p> View user guide</p> </li> </ul>","path":["Components"],"tags":[]},{"location":"user-guides/container/","level":1,"title":"How to use containers","text":"<p>This guide shows you how to use containers to group your components into sections and subsections within the page.</p> <p>A Container[vizro.models.Container] complements a [Page][vizro.models.Page]: both models share nearly identical arguments. While <code>Page.layout</code> provides a method for structuring the overall page layout, a <code>Container</code> offers more detailed control within a particular section of the page. The <code>Container</code> is based on the underlying Dash component <code>dbc.Container</code>.</p> <p>Unlike <code>Page</code>, the <code>Container</code> model offers additional visual customization options:</p> <ul> <li><code>variant</code>: Enables you to select a visual style for the container, making it stand out from the rest of the page content.</li> <li><code>collapsed</code>: Enables collapsible behavior. You can define whether the container's contents are initially shown or hidden.</li> </ul> <p>Displaying multiple containers inside Tabs</p> <p>An alternative way to display multiple containers on one page is to place them inside Tabs.</p> <p>Tabs organize and separate groups of related content in a dashboard, letting users switch between different sections or views. They are a way of putting multiple containers into the same screen space, and letting the user switch between them.</p> <p></p>","path":["How to use containers"],"tags":[]},{"location":"user-guides/container/#when-to-use-containers","level":2,"title":"When to use containers","text":"<p>In general, any arbitrarily granular layout can already be achieved by using <code>Page.layout</code> alone, which is our recommended approach if you want to arrange components on a page with consistent row and/or column spacing.</p> <p>Both <code>Page.layout</code> and <code>Container.layout</code> now accept either a [<code>Grid</code>][vizro.models.Grid] (default) or a [<code>Flex</code>][vizro.models.Flex] layout model, giving you full flexibility when arranging components.</p> <ul> <li><code>Page.layout</code> defines the overall layout of the page using either <code>Grid</code> or <code>Flex</code>.</li> <li><code>Container.layout</code> allows you to insert a nested <code>Grid</code> or <code>Flex</code> layout within the page layout, offering more granular control by breaking the page into independently arranged sublayouts.</li> </ul> <p>Here are a few cases where you might want to use a <code>Container</code> instead of <code>Page.layout</code>:</p> <ul> <li>Split up your sections into subsections to organize components together</li> <li>Add a title to your section</li> <li>Different row and column spacing between sections</li> <li>Apply a background color or borders to visually distinguish your content</li> <li>Make your content collapsible</li> <li>Apply controls to selected sections</li> </ul>","path":["How to use containers"],"tags":[]},{"location":"user-guides/container/#basic-containers","level":2,"title":"Basic containers","text":"<p>To add a [<code>Container</code>][vizro.models.Container] to your page, do the following:</p> <ol> <li>Insert the <code>Container</code> into the <code>components</code> argument of the [<code>Page</code>][vizro.models.Page]</li> <li>Configure your <code>components</code>, read the overview page for various options</li> <li>(optional) Set a <code>title</code> for your <code>Container</code></li> <li>(optional) Configure your <code>layout</code>, see the guide on layouts</li> <li>(optional) Configure container specific <code>controls</code></li> </ol> <p>Container</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"Containers\",\n    components=[  # (1)!\n        vm.Container(\n            title=\"Container I\",\n            layout=vm.Grid(grid=[[0, 1]]),  # (2)!\n            components=[\n                vm.Graph(\n                    figure=px.scatter(\n                        iris,\n                        x=\"sepal_length\",\n                        y=\"petal_width\",\n                        color=\"species\",\n                        title=\"Container I - Scatter\"\n                    )\n                ),\n                vm.Graph(\n                    figure=px.bar(\n                        iris,\n                        x=\"sepal_length\",\n                        y=\"sepal_width\",\n                        color=\"species\",\n                        title=\"Container I - Bar\"\n                    )\n                ),\n            ],\n        ),\n        vm.Container(\n            title=\"Container II\",\n            components=[\n                vm.Graph(\n                    figure=px.scatter(\n                        iris,\n                        x=\"sepal_width\",\n                        y=\"sepal_length\",\n                        color=\"species\",\n                        marginal_y=\"violin\",\n                        marginal_x=\"box\",\n                        title=\"Container II - Scatter\",\n                    )\n                ),\n            ],\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>Note that the <code>Page.layout</code> argument is not specified here and will therefore defaults to <code>[[0], [1]]</code>, meaning the containers will be vertically stacked down the page in one column.</li> <li>Horizontally stack the components side-by-side inside this <code>Container</code> in one row.</li> </ol> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - components:\n          - figure:\n              _target_: scatter\n              data_frame: iris\n              x: sepal_length\n              y: petal_width\n              color: species\n              title: Container I - Scatter\n            type: graph\n          - figure:\n              _target_: bar\n              data_frame: iris\n              x: sepal_length\n              y: petal_width\n              color: species\n              title: Container I - Bar\n            type: graph\n        layout:\n          grid: [[0, 1]]\n          type: grid\n        type: container\n        title: Container I\n      - components:\n          - figure:\n              _target_: scatter\n              data_frame: iris\n              x: sepal_width\n              y: sepal_length\n              color: species\n              marginal_y: violin\n              marginal_x: box\n              title: Container II - Scatter\n            type: graph\n        type: container\n        title: Container II\n    title: Containers\n</code></pre> <p></p> <p>Note that an almost identical layout can also be achieved using solely the <code>Page.layout</code> by configuring the <code>Page.layout</code> as <code>vm.Grid(grid = [[0, 1], [2, 2]])</code>.</p>","path":["How to use containers"],"tags":[]},{"location":"user-guides/container/#nested-containers","level":2,"title":"Nested containers","text":"<p>Containers can be nested, providing a hierarchical structure for organizing components. This nesting capability enables users to create more complex layouts and manage related components at any level of granularity.</p> <p>To create nested containers, add a <code>Container</code> to the <code>components</code> argument of another <code>Container</code>.</p> Example<pre><code>vm.Container(\n    title=\"Parent Container\",\n    components=[\n        vm.Container(\n            title=\"Child Container\",\n            components=[vm.Button()],\n        )\n    ],\n)\n</code></pre>","path":["How to use containers"],"tags":[]},{"location":"user-guides/container/#styled-containers","level":2,"title":"Styled containers","text":"<p>To make the <code>Container</code> stand out as a distinct section in your dashboard, you can select from the predefined styles available in its <code>variant</code> argument. This can be set to <code>\"plain\"</code> (the default), <code>\"filled\"</code> or <code>\"outlined\"</code>.</p> <p>Container with different styles</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"Containers with different styles\",\n    layout=vm.Grid(grid=[[0, 1]]),\n    components=[\n        vm.Container(\n            title=\"Container with background color\",\n            components=[vm.Graph(figure=px.scatter(iris, x=\"sepal_width\", y=\"sepal_length\", color=\"species\"))],\n            variant=\"filled\",\n        ),\n        vm.Container(\n            title=\"Container with borders\",\n            components=[vm.Graph(figure=px.box(iris, x=\"species\", y=\"sepal_length\", color=\"species\"))],\n            variant=\"outlined\",\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - title: Containers with different styles\n    layout:\n      grid: [[0, 1]]\n      type: grid\n    components:\n      - type: container\n        title: Container with background color\n        components:\n          - type: graph\n            figure:\n              _target_: scatter\n              data_frame: iris\n              x: sepal_width\n              y: sepal_length\n              color: species\n        variant: filled\n      - type: container\n        title: Container with borders\n        components:\n          - type: graph\n            figure:\n              _target_: box\n              data_frame: iris\n              x: species\n              y: sepal_length\n              color: species\n        variant: outlined\n</code></pre> <p></p> <p>If you want to style your <code>Container</code> beyond the styling options available inside <code>variant</code>, please refer to our user guide on overwriting CSS for selected components.</p>","path":["How to use containers"],"tags":[]},{"location":"user-guides/container/#collapsible-containers","level":2,"title":"Collapsible containers","text":"<p>To make a Container collapsible, use the <code>collapsed</code> argument:</p> <ul> <li>Set <code>collapsed=True</code> to have the container start in a collapsed (hidden) state.</li> <li>Set <code>collapsed=False</code> to have it expanded (visible) by default.</li> </ul> <p>Once defined, dashboard users can toggle the container’s visibility interactively.</p> <p>By default, a collapsible container is styled with <code>variant=\"outlined\"</code> to make its border visible.</p> <p>Collapsible containers are supported in both <code>Grid</code> and <code>Flex</code> layouts. However, we recommend using them within a <code>Flex</code> layout for optimal behavior, as <code>Flex</code> is better suited to dynamic sizing and more efficient use of space when content is shown or hidden.</p> <p>Collapsible container inside <code>Flex</code></p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"Collapsible containers\",\n    layout=vm.Flex(),  # (1)!\n    components=[\n        vm.Container(\n            title=\"Initially collapsed container\",\n            components=[vm.Graph(figure=px.scatter(iris, x=\"sepal_width\", y=\"sepal_length\", color=\"species\"))],\n            collapsed=True,\n        ),\n        vm.Container(\n            title=\"Initially expanded container\",\n            components=[vm.Graph(figure=px.box(iris, x=\"species\", y=\"sepal_length\", color=\"species\"))],\n            collapsed=False,\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We use a <code>Flex</code> layout to make sure the <code>Container</code> only occupy as much space as they need, regardless of their collapsed state.</li> </ol> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - title: Collapsible containers\n    layout:\n      type: flex\n    components:\n      - type: container\n        title: Initially collapsed container\n        components:\n          - type: graph\n            figure:\n              _target_: scatter\n              data_frame: iris\n              x: sepal_width\n              y: sepal_length\n              color: species\n        collapsed: true\n      - type: container\n        title: Initially expanded container\n        components:\n          - type: graph\n            figure:\n              _target_: box\n              data_frame: iris\n              x: species\n              y: sepal_length\n              color: species\n        collapsed: false\n</code></pre> <p></p> <p>Collapsible containers can be used in <code>Grid</code> layout as well.</p> <p>Collapsible container inside <code>Grid</code></p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"Collapsible containers\",\n    layout=vm.Grid(grid=[[0, 1]]),\n    components=[\n        vm.Container(\n            title=\"Initially collapsed container\",\n            components=[vm.Graph(figure=px.scatter(iris, x=\"sepal_width\", y=\"sepal_length\", color=\"species\"))],\n            collapsed=True,\n        ),\n        vm.Container(\n            title=\"Initially expanded container\",\n            components=[vm.Graph(figure=px.box(iris, x=\"species\", y=\"sepal_length\", color=\"species\"))],\n            collapsed=False,\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - title: Collapsible containers\n    layout:\n      grid: [[0, 1]]\n      type: grid\n    components:\n      - type: container\n        title: Initially collapsed container\n        components:\n          - type: graph\n            figure:\n              _target_: scatter\n              data_frame: iris\n              x: sepal_width\n              y: sepal_length\n              color: species\n        collapsed: true\n      - type: container\n        title: Initially expanded container\n        components:\n          - type: graph\n            figure:\n              _target_: box\n              data_frame: iris\n              x: species\n              y: sepal_length\n              color: species\n        collapsed: false\n</code></pre> <p></p>","path":["How to use containers"],"tags":[]},{"location":"user-guides/container/#add-a-tooltip","level":2,"title":"Add a tooltip","text":"<p>The <code>description</code> argument enables you to add helpful context to your container by displaying an info icon next to its title. Hovering over the icon shows a tooltip with your chosen text.</p> <p>You can provide Markdown text as a string to use the default info icon or a [<code>Tooltip</code>][vizro.models.Tooltip] model to use any icon from the Google Material Icons library.</p> <p>Container with tooltip</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"Container with tooltip\",\n    layout=vm.Grid(grid=[[0, 1]]),\n    components=[\n        vm.Container(\n            title=\"Container with tooltip\",\n            components=[vm.Graph(figure=px.scatter(iris, x=\"sepal_width\", y=\"sepal_length\", color=\"species\"))],\n            description=\"\"\"\n                The Iris dataset includes measurements of 150 iris flowers across three types: Setosa, Versicolor, and Virginica.\n\n                While all samples are labeled by type, they can appear similar when looking at just some features—making it a useful dataset for exploring patterns and challenges in classification.\n            \"\"\",\n        ),\n        vm.Container(\n            title=\"Container title\",\n            components=[vm.Graph(figure=px.box(iris, x=\"species\", y=\"sepal_length\", color=\"species\"))],\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - title: Container with tooltip\n    layout:\n      grid: [[0, 1]]\n      type: grid\n    components:\n      - type: container\n        title: Container with tooltip\n        components:\n          - type: graph\n            figure:\n              _target_: scatter\n              data_frame: iris\n              x: sepal_width\n              y: sepal_length\n              color: species\n        collapsed: true\n        description: |\n          The Iris dataset includes measurements of 150 iris flowers across three types: Setosa, Versicolor, and Virginica.\n\n          While all samples are labeled by type, they can appear similar when looking at just some features—making it a useful dataset for exploring patterns and challenges in classification.\n      - type: container\n        title: Container title\n        components:\n          - type: graph\n            figure:\n              _target_: box\n              data_frame: iris\n              x: species\n              y: sepal_length\n              color: species\n        collapsed: false\n</code></pre> <p></p>","path":["How to use containers"],"tags":[]},{"location":"user-guides/container/#add-controls-to-container","level":2,"title":"Add controls to container","text":"<p>The <code>Container</code> has a <code>controls</code> argument where you can define container-specific controls such as filters and parameters. This groups together controls with their target components for better interaction. Controls can only target components inside their own container.</p> <p>Here are a few cases where you might want to use <code>controls</code> within a <code>Container</code>:</p> <ul> <li>displaying multiple datasets on the same page</li> <li>isolating container-specific data without affecting the rest of the page</li> <li>providing detailed views that don't influence page-level data</li> </ul> <p>Container with controls</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\niris = px.data.iris()\ngapminder = px.data.gapminder()\n\npage = vm.Page(\n    title=\"Containers with controls\",\n    layout=vm.Grid(grid=[[0, 1]]),\n    components=[\n        vm.Container(\n            title=\"Container with gapminder data\",\n            components=[vm.Graph(id=\"bar_chart\", figure=px.bar(gapminder, x=\"country\", y=\"gdpPercap\"))],\n            controls=[vm.Filter(column=\"continent\", selector=vm.RadioItems())],\n        ),\n        vm.Container(\n            title=\"Container with iris data\",\n            components=[vm.Graph(figure=px.box(iris, x=\"species\", y=\"sepal_length\", color=\"species\"))],\n            controls=[vm.Filter(column=\"species\", selector=vm.Checklist())],\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - title: Containers with controls\n    layout:\n      grid: [[0, 1]]\n      type: grid\n    components:\n      - type: container\n        title: Container with gapminder data\n        components:\n          - type: graph\n            figure:\n              _target_: bar\n              data_frame: gapminder\n              x: country\n              y: gdpPercap\n        controls:\n          - column: continent\n            selector:\n              type: radioitems\n            type: filter\n      - type: container\n        title: Container with iris data\n        components:\n          - type: graph\n            figure:\n              _target_: box\n              data_frame: iris\n              x: species\n              y: sepal_length\n              color: species\n        controls:\n          - column: species\n            selector:\n              type: checklist\n            type: filter\n</code></pre> <p></p> <p>Container styles</p> <p>When you have multiple adjacent containers with controls, consider using styled containers to make the separations between sections of your page clear. Containers with controls also work with collapsible containers and inside nested containers.</p>","path":["How to use containers"],"tags":[]},{"location":"user-guides/container/#the-extra-argument","level":2,"title":"The <code>extra</code> argument","text":"<p>The <code>Container</code> is based on the underlying Dash component <code>dbc.Container</code>. Using the <code>extra</code> argument you can pass extra arguments to <code>dbc.Container</code> in order to alter it beyond the chosen defaults.</p> <p>Note</p> <p>Using <code>extra</code> is a quick and flexible way to alter a component beyond what Vizro offers. However, it is not a part of the official Vizro schema and the underlying implementation details may change. If you want to guarantee that your apps keep running, we recommend that you pin your Vizro version.</p> <p>For examples of how to use the <code>extra</code> argument, see an example in the documentation of <code>Card</code>.</p>","path":["How to use containers"],"tags":[]},{"location":"user-guides/controls/","level":1,"title":"Controls","text":"<p>Vizro supports controls to perform common business intelligence (BI) operations. This guide gives an overview of the different ways you can configure controls.</p> <p>The following components are reactive to controls:</p> <ul> <li>built-in graphs and custom graphs</li> <li>built-in tables and custom tables</li> <li>built-in figures and custom figures</li> </ul> <p>It is possible to add controls to a page or container. Both the [<code>Page</code> model][vizro.models.Page] and the [<code>Container</code> model][vizro.models.Container] have an optional <code>controls</code> argument where you can configure any number of controls.</p> <p>Vizro has two types of control:</p> <ul> <li> <p>Filter controls the data of reactive components. It filters the <code>data_frame</code> of the <code>figure</code> function of a target component model such as [<code>Graph</code>][vizro.models.Graph].</p> </li> <li> <p>Parameter controls the configuration of a reactive component. It sets any argument other than <code>data_frame</code> in the <code>figure</code> function of the target component model such as [<code>Graph</code>][vizro.models.Graph]. It can also be used to set dynamic data parameters.</p> </li> </ul> <p>All controls have an argument <code>selector</code> that configures the visual interface for the control, for example a checklist or a range slider. The same selectors are available for all controls.</p>","path":["Controls"],"tags":[]},{"location":"user-guides/controls/#set-a-control","level":2,"title":"Set a control","text":"<p>When the dashboard is running there are two ways for a user to set a control:</p> <ul> <li>Direct user interaction with the underlying selector. For example, the user selects values from a checklist.</li> <li>User interaction with a graph or table via the [<code>set_control</code> action][vizro.actions.set_control]. This enables functionality such as cross-filtering and cross-highlighting. To achieve a visually cleaner dashboard you might like to hide the control's underlying selector by setting the control's argument <code>visible=False</code>.</li> </ul> <p>Tip</p> <p>The state of any control that has <code>show_in_url=True</code> is included when you share the URL of your app.</p>","path":["Controls"],"tags":[]},{"location":"user-guides/controls/#reset-controls","level":2,"title":"Reset controls","text":"<p>You can reset all controls on the page to their original values with the \"Reset controls\" button at the bottom of the control panel on the left side of the page. This applies to all controls on the page, regardless of whether they are visible. When all controls on a page have <code>visible=False</code> and hence no control panel is shown, the \"Reset controls\" button appears next to the theme switch on the top right of the page.</p>","path":["Controls"],"tags":[]},{"location":"user-guides/custom-actions/","level":1,"title":"How to create custom actions","text":"<p>Actions control how your app responds to user input such as clicking a button or a point on a graph. If an action is not available in Vizro's built-in actions then you can create a custom action. In this guide we show how to do this.</p> <p>We also have an in-depth tutorial on creating an action and an explanation of how Vizro actions work.</p> <p>Note</p> <p>Do you have an idea for a built-in action? Submit a feature request!</p>","path":["How to create custom actions"],"tags":[]},{"location":"user-guides/custom-actions/#general-principles","level":2,"title":"General principles","text":"<p>Many [Vizro models][vizro.models] have an <code>actions</code> argument that can contain one or more actions. Each action is a Python function that is triggered by a user interaction. The function can optionally have any number of inputs and outputs that refer to a Vizro model <code>id</code>.</p> <p>To define your own action:</p> <ol> <li> <p>write a Python function and decorate it with <code>@capture(\"action\")</code>:</p> <pre><code>from vizro.models.types import capture\n\n\n@capture(\"action\")\ndef action_function(input_1, input_2):\n    ...\n    return \"My string value, potentially dependent on input_1 and input_2\"\n</code></pre> </li> <li> <p>attach it to the <code>actions</code> argument of a Vizro model using [<code>Action</code>][vizro.models.Action]:</p> <ol> <li>call it using the <code>function</code> argument</li> <li>if your action has one or more inputs then specify them as function arguments</li> <li>if your action has one or more outputs then specify them as <code>outputs</code></li> </ol> <pre><code>import vizro.models as vm\n\nactions = vm.Action(\n    function=action_function(input_1=\"input_id_1\", input_2=\"input_id_2\"),  # (1)!\n    outputs=\"output_id_1\",  # (2)!\n)\n</code></pre> <ol> <li>When the dashboard is running, the action's <code>input_1</code> will be set to the runtime value of the Vizro model with <code>id=\"input_id_1\"</code> and similarly for <code>input_2</code>.</li> <li>When the dashboard is running, the action's output \"My string value...\" will set the value of the Vizro model with <code>id=\"output_id_1\"</code>.</li> </ol> </li> </ol> <p>You can also execute multiple actions with a single trigger.</p> <p>Warning</p> <p>You should never assume that the values of inputs in your action function are restricted to those that show on the user's screen. A malicious user can execute your action functions with arbitrary inputs. In the tutorial, we discuss in more detail how to write secure actions.</p>","path":["How to create custom actions"],"tags":[]},{"location":"user-guides/custom-actions/#trigger-an-action-with-a-button","level":2,"title":"Trigger an action with a button","text":"<p>Here is an example action that gives the current time when a button is clicked.</p> <pre><code>from datetime import datetime\nfrom vizro.models.types import capture\n\n\n@capture(\"action\")\ndef current_time_text():  # (1)!\n    time = datetime.now()\n    return f\"The time is {time}\"  # (2)!\n</code></pre> <ol> <li>The function has no input arguments.</li> <li>The function returns a single value.</li> </ol> <p>To attach the action to a button model, we use it inside the <code>actions</code> argument as follows:</p> <pre><code>vm.Button(\n    actions=vm.Action(\n        function=current_time_text(),  # (1)!\n        outputs=\"time_text\",  # (2)!\n    ),\n)\n</code></pre> <ol> <li>Call the action function with <code>function=current_time_text()</code> (remember the <code>()</code>).</li> <li>The returned value \"The time is ...\" will update the component <code>id=\"time_text\"</code> (not yet defined).</li> </ol> <p>Here is the full example code that includes the output component <code>vm.Time(id=\"time_text\")</code>.</p> <p>Trigger an action with a button</p> app.pyapp.yamlResult <pre><code>from datetime import datetime\n\nimport vizro.models as vm\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\n\n@capture(\"action\")\ndef current_time_text():\n    time = datetime.now()\n    return f\"The time is {time}\"\n\n\npage = vm.Page(\n    title=\"Action triggered by button\",\n    layout=vm.Flex(),\n    components=[\n        vm.Button(\n            actions=vm.Action(\n                function=current_time_text(),\n                outputs=\"time_text\",\n            )\n        ),\n        vm.Text(id=\"time_text\", text=\"Click the button\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to define a CapturedCallables custom action and parse YAML configuration\n# More explanation in the docs on `Dashboard` and extensions.\npages:\n  - components:\n      - type: button\n        actions:\n          - type: action\n            function:\n              _target_: __main__.current_time_text\n            outputs: time_text\n      - type: text\n        id: time_text\n        text: Click the button\n    layout:\n      type: flex\n    title: Action triggered by button\n</code></pre> <p></p> <p>Before clicking the button, the text shows \"Click the button\". When you click the button, the <code>current_time_text</code> action is triggered. This finds the current time and returns a string \"The time is ...\". The resulting value is sent back to the user's screen and updates the text of the model <code>vm.Text(id=\"time_text\")</code>.</p> <p>Tip</p> <p>If you have many buttons that trigger actions then you might like to give them icons. You can even have icon-only buttons with no text.</p>","path":["How to create custom actions"],"tags":[]},{"location":"user-guides/custom-actions/#trigger-an-action-with-a-graph","level":2,"title":"Trigger an action with a graph","text":"<p>This is already possible, and documentation is coming soon!</p>","path":["How to create custom actions"],"tags":[]},{"location":"user-guides/custom-actions/#trigger-with-a-runtime-input","level":2,"title":"Trigger with a runtime input","text":"<p>This extends the above example of an action triggered by a button to include an input. Here is the action function:</p> <pre><code>from datetime import datetime\nfrom vizro.models.types import capture\n\n\n@capture(\"action\")\ndef current_time_text(use_24_hour_clock):  # (1)!\n    time_format = \"%H:%M:%S\" if use_24_hour_clock else \"%I:%M:%S %p\"\n    time = datetime.now().strftime(time_format)\n    return f\"The time is {time}\"  # (2)!\n</code></pre> <ol> <li>The function has one argument, which will receive a boolean value <code>True</code> or <code>False</code> to determine the time format used.</li> <li>The function returns a single value.</li> </ol> <p>To attach the action to a button model, we use it inside the <code>actions</code> argument as follows:</p> <pre><code>vm.Button(\n    actions=vm.Action(\n        function=current_time_text(use_24_hour_clock=\"clock_switch\"),  # (1)!\n        outputs=\"time_text\",  # (2)!\n    ),\n)\n</code></pre> <ol> <li>The argument <code>use_24_hour_clock</code> corresponds to the value of the component with <code>id=\"clock_switch\"</code> (not yet defined). Here we used a keyword argument <code>use_24_hour_clock=\"clock_switch\"</code> but, as with normal Python function call, we could instead use a positional argument with <code>current_time_text(\"clock_switch\")</code>.</li> <li>The returned value \"The time is ...\" will update the component <code>id=\"time_text\"</code> (not yet defined).</li> </ol> <p>Here is the full example code that includes the input component <code>vm.Switch(id=\"clock_switch\")</code> and the output component <code>vm.Time(id=\"time_text\")</code>.</p> <p>Use runtime inputs</p> app.pyapp.yamlResult <pre><code>from datetime import datetime\n\nimport vizro.models as vm\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\n\n@capture(\"action\")\ndef current_time_text(use_24_hour_clock):\n    time_format = \"%H:%M:%S\" if use_24_hour_clock else \"%I:%M:%S %p\"\n    time = datetime.now().strftime(time_format)\n    return f\"The time is {time}\"\n\n\nvm.Page.add_type(\"components\", vm.Switch)  # (1)!\n\npage = vm.Page(\n    title=\"Action triggered by button\",\n    layout=vm.Flex(),\n    components=[\n        vm.Switch(id=\"clock_switch\", title=\"24-hour clock\", value=True),\n        vm.Button(\n            actions=vm.Action(\n                function=current_time_text(use_24_hour_clock=\"clock_switch\"),\n                outputs=\"time_text\",\n            ),\n        ),\n        vm.Text(id=\"time_text\", text=\"Click the button\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>Currently [<code>Switch</code>][vizro.models.Switch] is designed to be used as a control selectors. In future, Vizro will have a dedicated <code>Form</code> model for the creation of forms. For now, we add them directly as <code>components</code> inside a [<code>Container</code>][vizro.models.Container]. For this to be a valid configuration we must first do <code>add_type</code> as for a custom component.</li> </ol> <pre><code># Custom components and added component types (with `add_type`) are currently only possible via Python configuration\n</code></pre> <p></p> <p>Before clicking the button, the text shows \"Click the button\". When you click the button, the <code>current_time_text</code> action is triggered. This finds the current time and returns a string \"The time is ...\" with a time format that depends on the switch's setting. The resulting value is sent back to the user's screen and updates the text of the model <code>vm.Text(id=\"time_text\")</code>.</p>","path":["How to create custom actions"],"tags":[]},{"location":"user-guides/custom-actions/#multiple-inputs-and-outputs","level":3,"title":"Multiple inputs and outputs","text":"<p>An action can have any number of inputs and outputs (including zero). Here is an action with two inputs and two outputs:</p> <pre><code>from vizro.models.types import capture\n\n\n@capture(\"action\")\ndef action_function(input_1, input_2):\n    ...\n    return \"My string value 2\", \"My string value 2\"\n</code></pre> <p>This would be attached to an <code>actions</code> argument as follows:</p> <pre><code>import vizro.models as vm\n\nactions = vm.Action(\n    function=action_function(input_1=\"input_id_1\", input_2=\"input_id_2\"),  # (1)!\n    outputs=[\"output_id_1\", \"output_id_2\"],\n)\n</code></pre> <ol> <li>As with an ordinary Python function call, this could also be written using positional arguments as <code>action_function(\"input_id_1\", \"input_id_2\")</code>.</li> </ol> <p>The returned values of an action function with multiple outputs are matched to the <code>outputs</code> in order. For actions with many return values, it can be a good idea to instead return a dictionary where returned values are labeled by string keys. In this case, <code>outputs</code> should also be a dictionary with matching keys, and the order of entries does not matter:</p> <pre><code>@capture(\"action\")\ndef action_function(input_1, input_2):\n    ...\n    return {\"key 1\": \"My string value 2\", \"key 2\": \"My string value 2\"}\n\n\nactions = vm.Action(\n    function=action_function(input_1=\"input_id_1\", input_2=\"input_id_2\"),\n    outputs={\"key 1\": \"output_id_1\", \"key 2\": \"output_id_2\"},  # (1)!\n)\n</code></pre> <ol> <li>Specifying outputs in the \"wrong\" order as <code>outputs={\"key 2\": \"output_id_2\", \"key 1\": \"output_id_1\"}</code> would work exactly the same way.</li> </ol> <p>A full real world example of using multiple inputs and outputs is given in the tutorial.</p>","path":["How to create custom actions"],"tags":[]},{"location":"user-guides/custom-actions/#multiple-actions","level":2,"title":"Multiple actions","text":"<p>When you specify multiple actions as <code>actions=[action_1, action_2, ...]</code> then Vizro chains these actions in order, so that <code>action_2</code> executes only when <code>action_1</code> has completed. You can freely mix built-in actions and custom actions in an actions chain. For more details on how actions chains execute, see our tutorial on custom actions.</p> <p>Here is an example actions chain that uses a custom <code>action_function</code> action and the built-in <code>export_data</code> action:</p> <pre><code>import vizro.actions as va\nimport vizro.models as vm\n\nactions = [\n    va.export_data(),\n    vm.Action(\n        function=action_function(\"input_id_1\", \"input_id_2\"),\n        outputs=\"output_id\",\n    ),\n]\n</code></pre>","path":["How to create custom actions"],"tags":[]},{"location":"user-guides/custom-actions/#address-specific-parts-of-a-model","level":2,"title":"Address specific parts of a model","text":"<p>For most actions that you write, you should only need to specify <code>&lt;model_id&gt;</code> for the <code>outputs</code> or as input arguments to the action function. However, some models have multiple arguments that you may want to use in an action. This is possible with the syntax <code>&lt;model_id&gt;.&lt;argument_name&gt;</code>. For more advanced use cases you can even address the underlying Dash component and property.</p>","path":["How to create custom actions"],"tags":[]},{"location":"user-guides/custom-actions/#model-arguments-as-input-and-output","level":3,"title":"Model arguments as input and output","text":"<p>The syntax for using a particular model argument as an action input or output is <code>&lt;model_id&gt;.&lt;argument_name&gt;</code>.</p> <p>For example, let's alter the above example of a switch that toggles between formatting time with the 12- and 24-hour clock. [<code>Switch</code>][vizro.models.Switch] has an argument <code>title</code> that adds a label to the switch. We can update this in an action by including <code>clock_switch.title</code> in the action's <code>outputs</code>.</p> <p>Use model argument as output</p> app.pyapp.yamlResult <pre><code>from datetime import datetime\n\nimport vizro.models as vm\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\n\n@capture(\"action\")\ndef current_time_text(use_24_hour_clock):\n    time_format = \"%H:%M:%S\" if use_24_hour_clock else \"%I:%M:%S %p\"\n    switch_title = \"24-hour clock\" if use_24_hour_clock else \"12-hour clock\"\n    time = datetime.now().strftime(time_format)\n    return f\"The time is {time}\", switch_title\n\n\nvm.Page.add_type(\"components\", vm.Switch)  # (1)!\n\npage = vm.Page(\n    title=\"Action triggered by switch\",\n    layout=vm.Flex(),\n    components=[\n        vm.Switch(\n            id=\"clock_switch\",\n            title=\"24-hour clock\",\n            value=True,\n            actions=vm.Action(  # (2)!\n                function=current_time_text(use_24_hour_clock=\"clock_switch\"),\n                outputs=[\"time_text\", \"clock_switch.title\"],  # (3)!\n            ),\n        ),\n        vm.Text(id=\"time_text\", text=\"Toggle the switch\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>Currently [<code>Switch</code>][vizro.models.Switch] is designed to be used as a control selectors. In future, Vizro will have a dedicated <code>Form</code> model for the creation of forms. For now, we add them directly as <code>components</code> inside a [<code>Container</code>][vizro.models.Container]. For this to be a valid configuration we must first do <code>add_type</code> as for a custom component.</li> <li>In the previous example, the action was triggered when a button is clicked; now we change the action to be triggered when the switch itself is clicked.</li> <li>This action now has two <code>outputs</code>. We refer to <code>\"clock_switch.title\"</code> to update the title of the switch.</li> </ol> <pre><code># Custom components and added component types (with `add_type`) are currently only possible via Python configuration\n</code></pre> <p></p>","path":["How to create custom actions"],"tags":[]},{"location":"user-guides/custom-actions/#dash-properties-as-input-and-output","level":3,"title":"Dash properties as input and output","text":"<p>Sometimes you might like to use as input or output a component that is on the screen but cannot be addressed explicitly with <code>&lt;model_id&gt;.&lt;argument_name&gt;</code>. Vizro actions in fact accept as input and output any Dash component in the format <code>&lt;component_id&gt;.&lt;property&gt;</code>.</p> <p>For example, let's alter the above example of a switch that toggles between formatting time with the 12- and 24-hour clock. We want to disable the switch when the button is clicked so that it can no longer be toggled. [<code>Switch</code>][vizro.models.Switch] does not contain an argument to disable the switch, but the underlying Dash component <code>dbc.Switch</code> does. We can address this by using <code>\"clock_switch.disabled\"</code> in our <code>outputs</code>.</p> <p>Use Dash property as input</p> app.pyapp.yamlResult <pre><code>from datetime import datetime\n\nimport vizro.models as vm\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\n\n@capture(\"action\")\ndef current_time_text(use_24_hour_clock):\n    time_format = \"%H:%M:%S\" if use_24_hour_clock else \"%I:%M:%S %p\"\n    time = datetime.now().strftime(time_format)\n    return f\"The time is {time}\", True  # (1)!\n\n\nvm.Page.add_type(\"components\", vm.Switch)  # (2)!\n\npage = vm.Page(\n    title=\"Action triggered by button\",\n    layout=vm.Flex(),\n    components=[\n        vm.Switch(id=\"clock_switch\", title=\"24-hour clock\", value=True),\n        vm.Button(\n            actions=vm.Action(\n                function=current_time_text(use_24_hour_clock=\"clock_switch\"),\n                outputs=[\"time_text\", \"clock_switch.disabled\"],  # (3)!\n            ),\n        ),\n        vm.Text(id=\"time_text\", text=\"Click the button\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We disable the switch by returning <code>True</code> to its <code>disabled</code> property. After this action runs, the switch can no longer the clicked. To reset it, you must refresh the page.</li> <li>Currently [<code>Switch</code>][vizro.models.Switch] is designed to be used as a control selectors. In future, Vizro will have a dedicated <code>Form</code> model for the creation of forms. For now, we add them directly as <code>components</code> inside a [<code>Container</code>][vizro.models.Container]. For this to be a valid configuration we must first do <code>add_type</code> as for a custom component.</li> <li>This action now has two <code>outputs</code>. We refer to <code>\"clock_switch.disabled\"</code> to update the <code>disabled</code> property of the component with <code>id=\"clock_switch\"</code>.</li> </ol> <pre><code># Custom components and added component types (with `add_type`) are currently only possible via Python configuration\n</code></pre> <p></p>","path":["How to create custom actions"],"tags":[]},{"location":"user-guides/custom-charts/","level":1,"title":"How to create custom charts","text":"<p>This guide shows you how to create custom charts and how to add them to your dashboard. The [<code>Graph</code>][vizro.models.Graph] model accepts the <code>figure</code> argument, where you can enter any <code>plotly.express</code> chart as explained in the user guide on graphs.</p>","path":["How to create custom charts"],"tags":[]},{"location":"user-guides/custom-charts/#when-to-use-a-custom-chart","level":2,"title":"When to use a custom chart","text":"<p>In general, you should use the custom chart decorator <code>@capture(\"graph\")</code> if your plotly chart needs any post-update calls or customization. For example:</p> <ul> <li>You want to use any of the post figure update calls by <code>plotly</code> such as <code>update_layout</code>, <code>update_xaxes</code>, <code>update_traces</code> (for more details, see the docs on plotly's update calls)</li> <li>You want to use a custom-created <code>plotly.graph_objects.Figure()</code> object (in short, <code>go.Figure()</code>) and add traces yourself via <code>add_trace</code></li> </ul>","path":["How to create custom charts"],"tags":[]},{"location":"user-guides/custom-charts/#steps-to-create-a-custom-chart","level":2,"title":"Steps to create a custom chart","text":"<ol> <li>Define a function that returns a <code>go.Figure()</code>.</li> <li>Decorate it with <code>@capture(\"graph\")</code>.</li> <li>The function must accept a <code>data_frame</code> argument (of type <code>pandas.DataFrame</code>).</li> <li>The visualization should be derived from and require only one <code>pandas.DataFrame</code>. Dataframes from other arguments will not react to dashboard controls such as <code>Filter</code>.</li> <li>Pass your function to the <code>figure</code> argument of the [<code>Graph</code>][vizro.models.Graph] model.</li> </ol> <p>The minimal example below can be used as a base to build more sophisticated charts.</p> Minimal example of a custom chart<pre><code>from vizro.models.types import capture\nimport pandas as pd\nimport plotly.graph_objects as go\n\n@capture(\"graph\")\ndef minimal_example(data_frame:pd.DataFrame=None):\n    return go.Figure()\n</code></pre> <p>Building on the above, there are several routes one can take. The following examples are guides on the most common custom requests, but also serve as an illustration of more general principles.</p> <p>To alter the data in the <code>data_frame</code> argument, consider using a Filter or parametrized data loading and dynamic data. The <code>data_frame</code> argument input to a custom chart contains the data after filters and parameters have been applied.</p> <p>Note</p> <p>Custom charts can be targeted by Filters or Parameters without any extra configuration. We will showcase both possibilities in the following examples.</p>","path":["How to create custom charts"],"tags":[]},{"location":"user-guides/custom-charts/#interact-with-other-graphs-and-tables","level":2,"title":"Interact with other graphs and tables","text":"<p>A custom graph can act as a source for interactions with other components, for example to cross-filter another graph or table when the user clicks on a point.</p>","path":["How to create custom charts"],"tags":[]},{"location":"user-guides/custom-charts/#enhanced-plotlyexpress-chart-with-reference-line","level":2,"title":"Enhanced <code>plotly.express</code> chart with reference line","text":"<p>The below examples shows a case where we enhance an existing <code>plotly.express</code> chart. We add a new argument (<code>hline</code>), that is used to draw a grey reference line at the height determined by the value of <code>hline</code>. The important thing to note is that we then add a <code>Parameter</code> that enables the dashboard user to interact with the argument, and hence move the line in this case. See the <code>Result</code> tab for an animation.</p> <p>Custom <code>plotly.express</code> scatter chart with a <code>Parameter</code></p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.managers import data_manager\nfrom vizro.models.types import capture\n\n\ndata_manager[\"iris\"] = px.data.iris()\n\n@capture(\"graph\")\ndef scatter_with_line(data_frame, x, y, color=None, size=None, hline=None): # (1)!\n    fig = px.scatter(data_frame=data_frame, x=x, y=y, color=color, size=size)\n    fig.add_hline(y=hline, line_color=\"gray\")\n    return fig\n\n\npage = vm.Page(\n    title=\"Custom chart\",\n    components=[\n        vm.Graph(\n            id=\"enhanced_scatter\",\n            figure=scatter_with_line(\n                data_frame=\"iris\",\n                x=\"sepal_length\",\n                y=\"sepal_width\",\n                color=\"species\",\n                size=\"petal_width\",\n                hline=3,\n            ),\n        ),\n    ],\n    controls=[\n        vm.Parameter( # (2)!\n            targets=[\"enhanced_scatter.hline\"],\n            selector=vm.Slider(min=2, max=5, step=1, value=3, title=\"Horizontal line\"),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>Note that arguments of the custom chart can be parametrized. Here we choose to parametrize the <code>hline</code> argument (see below).</li> <li>Here we parametrize the <code>hline</code> argument, but any other argument can be parametrized as well. Since there is complete flexibility regarding what can be derived from such arguments, the dashboard user has a wide range of customization options.</li> </ol> <pre><code># Still requires a .py to add data to the data manager, define CapturedCallables, and parse YAML configuration\n# More explanation in the docs on `Dashboard` and extensions.\npages:\n  - components:\n      - figure:\n          _target_: __main__.scatter_with_line\n          color: species\n          data_frame: iris\n          hline: 3\n          size: petal_width\n          x: sepal_length\n          y: sepal_width\n        id: enhanced_scatter\n        type: graph\n    controls:\n      - selector:\n          max: 5.0\n          min: 2.0\n          step: 1.0\n          title: Horizontal line\n          type: slider\n          value: 3.0\n        targets:\n          - enhanced_scatter.hline\n        type: parameter\n    title: Custom chart\n</code></pre> <p></p>","path":["How to create custom charts"],"tags":[]},{"location":"user-guides/custom-charts/#new-waterfall-chart-based-on-gofigure","level":2,"title":"New Waterfall chart based on <code>go.Figure()</code>","text":"<p>The below examples shows a more involved use-case. We create and style a waterfall chart, and add it alongside a filter to the dashboard. The example is based on a plotly waterfall chart tutorial.</p> <p>Custom <code>go.Figure()</code> waterfall chart with a <code>Parameter</code></p> app.pyapp.yamlResult <pre><code>import pandas as pd\nimport plotly.graph_objects as go\n\nimport vizro.models as vm\nfrom vizro import Vizro\nfrom vizro.managers import data_manager\nfrom vizro.models.types import capture\n\n\ndef waterfall_data():\n    return pd.DataFrame(\n        {\n            \"measure\": [\"relative\", \"relative\", \"total\", \"relative\", \"relative\", \"total\"],\n            \"x\": [\"Sales\", \"Consulting\", \"Net revenue\", \"Purchases\", \"Other expenses\", \"Profit before tax\"],\n            \"text\": [\"+60\", \"+80\", \"\", \"-40\", \"-20\", \"Total\"],\n            \"y\": [60, 80, 0, -40, -20, 0],\n        }\n    )\n\ndata_manager[\"waterfall_data\"] = waterfall_data()\n\n\n@capture(\"graph\")\ndef waterfall(data_frame, measure, x, y, text, title=None):\n    fig = go.Figure()\n    fig.add_traces(\n        go.Waterfall(\n            measure=data_frame[measure],\n            x=data_frame[x],\n            y=data_frame[y],\n            text=data_frame[text],\n            decreasing={\"marker\": {\"color\": \"#ff5267\"}},\n            increasing={\"marker\": {\"color\": \"#08bdba\"}},\n            totals={\"marker\": {\"color\": \"#00b4ff\"}},\n        ),\n    )\n\n    fig.update_layout(title=title)\n    return fig\n\n\npage = vm.Page(\n    title=\"Custom chart\",\n    components=[\n        vm.Graph(\n            figure=waterfall(data_frame=\"waterfall_data\", measure=\"measure\", x=\"x\", y=\"y\", text=\"text\"),\n        ),\n    ],\n    controls=[\n        vm.Filter(column=\"x\", selector=vm.Dropdown(title=\"Financial categories\")),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager, define CapturedCallables, and parse YAML configuration\n# More explanation in the docs on `Dashboard` and extensions.\npages:\n  - components:\n      - figure:\n          _target_: __main__.waterfall\n          data_frame: waterfall_data\n          measure: measure\n          text: text\n          x: x\n          y: y\n        type: graph\n    controls:\n      - column: x\n        selector:\n          title: Financial categories\n          type: dropdown\n        type: filter\n    title: Custom chart\n</code></pre> <p></p>","path":["How to create custom charts"],"tags":[]},{"location":"user-guides/custom-components/","level":1,"title":"How to create custom components","text":"<p>The number of [built-in Vizro models][vizro.models] is deliberately kept quite small to enable quick and easy configuration of a dashboard. However, Vizro is also extensible, so that you can modify any model or create an entirely new one. This guide shows you how to do so.</p> <p>In general, you can create a custom component based on a Dash component from any Dash component library, for example:</p> <ul> <li>Dash Core Components</li> <li>Dash HTML Components</li> <li>Dash Bootstrap Components</li> <li>Dash Mantine Components</li> </ul>","path":["How to create custom components"],"tags":[]},{"location":"user-guides/custom-components/#general-principles","level":2,"title":"General principles","text":"<p>Can you use <code>extra</code> instead of creating a custom component?</p> <p>If you want to modify an existing component, you may not even need to create a custom component. Many of our models have an <code>extra</code> argument to pass arguments to the underlying Dash component directly, for example to make the [<code>RadioItem</code>][vizro.models.RadioItems] inline instead of stacked.</p> <p>To create a custom component:</p> <ol> <li>Subclass the relevant model:<ul> <li>To extend an existing model such as [<code>RangeSlider</code>][vizro.models.RangeSlider], subclass it.</li> <li>To create a new component, subclass [<code>VizroBaseModel</code>][vizro.models.VizroBaseModel].</li> </ul> </li> <li>Write the subclass:<ul> <li>To extend an existing model you could, for example, add or change model fields or override the <code>build</code> method.</li> <li>To create a new component, you need to define fields and the <code>build</code> method from scratch.</li> </ul> </li> <li>Look at the field where your component will be used in the [API reference][vizro.models] and check whether it is described as a discriminated union. For example, in the [<code>Filter</code>][vizro.models.Filter] model the <code>selector</code> field of type [<code>SelectorType</code>][vizro.models.types.SelectorType] is a discriminated union but the <code>options</code> field of type [<code>OptionsType</code>][vizro.models.types.OptionsType] is not. If the field is a discriminated union, then:<ul> <li>You must ensure your model has a <code>type</code> field.</li> <li>You must register the new type with its parent model with [<code>add_type</code>][vizro.models.VizroBaseModel.add_type].</li> </ul> </li> </ol> <p>We will refer back to these steps in the examples below.</p>","path":["How to create custom components"],"tags":[]},{"location":"user-guides/custom-components/#extend-an-existing-component","level":2,"title":"Extend an existing component","text":"<p>You may want to use this strategy to:</p> <ul> <li>Extend an existing component, for example to add a button to a <code>Card</code>.</li> <li>Change default configuration of a Dash component set by a Vizro model, for example to set <code>allowCross=False</code> in [<code>RangeSlider</code>][vizro.models.RangeSlider].</li> <li>Change the fields of a models, for example to change the <code>title</code> field from <code>Optional</code> to have a default.</li> </ul> <p>You can extend an existing component by subclassing the component you want to modify. Remember that when subclassing a component you have access to all fields of its parent model, but you can choose to overwrite any field or method or define entirely new ones.</p> <p>In this example, we modify the [<code>RangeSlider</code>][vizro.models.RangeSlider] model so that one slider handle cannot cross the other, and to have a permanent tooltip showing the current value. It is often easier to call <code>super()</code> and modify the result when overriding a complex method such as the <code>build</code> method instead of writing it from scratch.</p> <p>In this case, the general three steps translate into:</p> <ol> <li>Subclass [<code>RangeSlider</code>][vizro.models.RangeSlider]:</li> </ol> <pre><code>import vizro.models as vm\n\nclass TooltipNonCrossRangeSlider(vm.RangeSlider):\n</code></pre> <ol> <li>Modify the component by changing the underlying parent's <code>dcc.RangeSlider</code> Dash component in the <code>build</code> method:</li> </ol> <p><pre><code>class TooltipNonCrossRangeSlider(vm.RangeSlider):\n    def build(self):\n        ...\n        allowCross=False,\n        tooltip={\"placement\": \"bottom\", \"always_visible\": True}\n</code></pre> These lines are highlighted in the example below. They are the only material change to the original <code>build</code> method.</p> <ol> <li> <p>Since the new model will be inserted into the <code>selectors</code> argument of the [<code>Filter</code>][vizro.models.Filter] model or [<code>Parameter</code>][vizro.models.Parameter] model, it will be part of the discriminated union describing the allowed types for that argument, in this case the [<code>SelectorType</code>][vizro.models.types.SelectorType]. Hence we must:</p> <ul> <li>define a new type:</li> </ul> </li> </ol> <p><pre><code>class TooltipNonCrossRangeSlider(vm.RangeSlider):\n    type: Literal[\"other_range_slider\"] = \"other_range_slider\"\n    ...\n</code></pre>     - register the type with the parent models: <pre><code>vm.Filter.add_type(\"selector\", TooltipNonCrossRangeSlider)\nvm.Parameter.add_type(\"selector\", TooltipNonCrossRangeSlider)\n</code></pre></p> Example based on existing component app.pyyamlResult <pre><code>from typing_extensions import Literal\n\nimport vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\niris = px.data.iris()\n\n\nclass TooltipNonCrossRangeSlider(vm.RangeSlider):\n    \"\"\"Custom numeric multi-selector `TooltipNonCrossRangeSlider`.\"\"\"\n\n    type: Literal[\"other_range_slider\"] = \"other_range_slider\"  # (1)!\n\n    def build(self):  # (2)!\n        range_slider_build_obj = super().build()  # (3)!\n        range_slider_build_obj[self.id].allowCross = False  # (4)!\n        range_slider_build_obj[self.id].tooltip = {\"always_visible\": True, \"placement\": \"bottom\"}  # (5)!\n        return range_slider_build_obj\n\n\nvm.Filter.add_type(\"selector\", TooltipNonCrossRangeSlider)  # (6)!\nvm.Parameter.add_type(\"selector\", TooltipNonCrossRangeSlider)  # (7)!\n\npage = vm.Page(\n    title=\"Custom Component\",\n    components=[\n        vm.Graph(\n            id=\"for_custom_chart\",\n            figure=px.scatter(iris, title=\"Iris Dataset\", x=\"sepal_length\", y=\"petal_width\", color=\"sepal_width\"),\n        ),\n    ],\n    controls=[\n        vm.Filter(\n            column=\"sepal_length\",\n            targets=[\"for_custom_chart\"],\n            selector=TooltipNonCrossRangeSlider(),\n        ),\n        vm.Parameter(\n            targets=[\"for_custom_chart.range_x\"],\n            selector=TooltipNonCrossRangeSlider(title=\"Select x-axis range\", min=0, max=10),  # (8)!\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\n\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>Here we provide a new type for the new component, so it can be distinguished in the discriminated union.</li> <li>Here we override the <code>build</code> method by altering the output of <code>super().build()</code>. Alternatively one could copy the source code of the build method and alter it directly.</li> <li><code>range_slider_build_obj[self.id]</code> then fetches the underlying <code>dcc.RangeSlider</code> object.</li> <li>This change prevents the <code>RangeSlider</code> from crossing itself when moving the handle.</li> <li>This change displays the tooltip below the handle.</li> <li>Remember! If part of a discriminated union, you must add the new component to the parent model where it will be inserted. In this case the new <code>TooltipNonCrossRangeSlider</code> will be inserted into the <code>selector</code> argument of the <code>Filter</code> model, and thus must be added as an allowed type.</li> <li>Remember! If part of a discriminated union, you must add the new component to the parent model where it will be inserted. In this case the new <code>TooltipNonCrossRangeSlider</code> will be inserted into the <code>selector</code> argument of the <code>Parameter</code> model, and thus must be added as an allowed type.</li> <li>The new component can now be inserted into a regular dashboard.</li> </ol> <pre><code># Custom components are currently only possible via Python configuration\n</code></pre> <p></p>","path":["How to create custom components"],"tags":[]},{"location":"user-guides/custom-components/#create-a-new-component","level":2,"title":"Create a new component","text":"<p>You may want to use this strategy to:</p> <ul> <li>Create a new component that does not exist as a [built-ninVizro model][vizro.models].</li> <li>Make extensive changes to an existing component.</li> <li>Combine multiple components into a single higher-level component, similar to a Dash All-in-One component.</li> </ul> <p>We will create a new <code>Rating</code> component based on the Dash Mantine Component <code>Rating</code>. This produces a form component that shows a set of 5 stars for the dashboard user to give a rating. We also include <code>html.Legend</code> in our custom component to label the form component.</p> <ol> <li> <p>Create the new component by subclassing [<code>VizroBaseModel</code>][vizro.models.VizroBaseModel]: <pre><code>import vizro.models as vm\n\nclass Rating(vm.VizroBaseModel):\n</code></pre></p> </li> <li> <p>Build the component in the <code>build</code> method:</p> <ul> <li>This can return any Dash component but is often a \"container\" component such as <code>html.Div</code> that includes multiple Dash components.</li> <li>Typically you use <code>id=self.id</code> for the \"core\" component, in this case <code>dmc.Rating</code>.</li> <li>Typically you prefix with <code>self.id</code> the <code>id</code> for a component that is not the core one.</li> </ul> <pre><code>from dash import html\nimport dash_mantine_components as dmc\n\nclass Rating(vm.VizroBaseModel):\n    ...\n    def build(self):\n        return html.Div( # (1)!\n            [\n                html.Legend(id=f\"{self.id}_title\", ...), # (2)!\n                dmc.Rating(id=self.id, ...) # (3)!\n            ]\n        )\n</code></pre> <ol> <li>In this example, for simplicity we use <code>html.Div</code> to provide the outer container. You could also use <code>html.Fieldset</code>, which is specifically designed for grouping a form legend with a set of controls.</li> <li>This is not the core component but we will later address it with an action, so it must have an <code>id</code> set. We prefix its <code>id</code> with <code>self.id</code>.</li> <li>This is the core component, and so it has <code>id=self.id</code>.</li> </ol> </li> <li> <p>Since the new model will be inserted into the <code>components</code> argument of the [<code>Page</code>][vizro.models.Page] model, it will be part of the discriminated union [<code>ComponentType</code>][vizro.models.types.ComponentType]. Hence we must:</p> <ul> <li>define a new type: <pre><code>class Rating(vm.VizroBaseModel):\n    type: Literal[\"rating\"] = \"rating\"\n    ...\n</code></pre></li> <li>register the type with the parent model: <pre><code>vm.Page.add_type(\"components\", Rating)\n</code></pre></li> </ul> </li> </ol> <p>Here is the full code for <code>Rating</code> and a simple app containing it.</p> <p>New component creation</p> app.pyyamlResult <pre><code>from typing import Literal\n\nfrom dash import html\nimport dash_mantine_components as dmc\nimport vizro.models as vm\nfrom vizro import Vizro\n\n\nclass Rating(vm.VizroBaseModel):\n    type: Literal[\"rating\"] = \"rating\"\n    title: str # (1)!\n    color: str = \"#00b4ff\" # (2)!\n\n    def build(self):\n        return html.Div( # (3)!\n            [\n                html.Legend(id=f\"{self.id}_title\", children=self.title, className=\"form-label\"),\n                dmc.Rating(id=self.id, color=self.color),\n            ]\n        )\n\n\nvm.Page.add_type(\"components\", Rating)  # (4)!\n\npage = vm.Page(\n    title=\"New rating component\",\n    layout=vm.Flex(),\n    components=[\n        Rating(title=\"Rate the last movie you watched\"),  # (5)!\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>You can optionally define other Pydantic fields to configure our custom component. Here we define a mandatory <code>title</code> field that must be a string.</li> <li>This field <code>color</code> is optional and has a default value. Here we specify the field to be a string, but there also exists a special <code>Color</code> type in the <code>pydantic-extra-types</code> package that would perform stricter validation and additional functionality.</li> <li>We use the values of the Pydantic fields <code>id</code> (inherited from <code>vm.VizroBaseModel</code>), <code>title</code> and <code>color</code> in the Dash components.</li> <li>Don't forget! If part of a discriminated union, you must add the new component to the parent model where it will be inserted. In this case the new <code>Rating</code> will be inserted into the <code>components</code> argument of the <code>Page</code> model, and thus must be added as an allowed type.</li> <li>The <code>title</code> field is mandatory; <code>id</code> and <code>color</code> are optional and not specified here.</li> </ol> <pre><code># Custom components are currently only possible via Python configuration\n</code></pre> <p></p>","path":["How to create custom components"],"tags":[]},{"location":"user-guides/custom-components/#use-custom-components-with-actions","level":2,"title":"Use custom components with actions","text":"<p>Custom components can be used with both built-in actions and custom actions. Here we demonstrate how the above <code>Rating</code> component can be used with actions.</p>","path":["How to create custom components"],"tags":[]},{"location":"user-guides/custom-components/#dash-properties-as-input-and-output","level":3,"title":"Dash properties as input and output","text":"<p>To use your custom component as an input or output for an action, you must explicitly specify an <code>id</code> when using the component, for example <code>Rating(id=\"my_rating\")</code>.</p> <p>It is then immediately possible to address the properties of Dash components built by the custom component. For example, we could use <code>\"my_rating.value\"</code> as the input or output of an action to target the <code>value</code> property of the <code>dmc.Rating</code> component. Here is an example button that triggers a custom action to set this Dash property by including <code>outputs=\"my_rating.value\"</code>.</p> <p>Use custom component Dash properties as an action output</p> app.pyyamlResult <pre><code>from typing import Literal\n\nfrom dash import html\nimport dash_mantine_components as dmc\nimport vizro.models as vm\nfrom vizro.models.types import capture\nfrom vizro import Vizro\n\n\nclass Rating(vm.VizroBaseModel):\n    type: Literal[\"rating\"] = \"rating\"\n    title: str\n    color: str = \"#00b4ff\"\n\n    def build(self):\n        return html.Div(\n            [\n                html.Legend(id=f\"{self.id}_title\", children=self.title, className=\"form-label\"),\n                dmc.Rating(id=self.id, color=self.color),\n            ]\n        )\n\n\nvm.Page.add_type(\"components\", Rating)\n\n\n@capture(\"action\") # (1)!\ndef clear_rating():\n    return 0\n\n\npage = vm.Page(\n    title=\"New rating component\",\n    layout=vm.Flex(),\n    components=[\n        Rating(id=\"my_rating\", title=\"Rate the last movie you watched\"), # (2)!\n        vm.Button(\n            text=\"Clear rating\",\n            actions=vm.Action(function=clear_rating(), outputs=\"my_rating.value\"), # (3)!\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We write a custom action <code>clear_rating</code> that has no inputs and returns <code>0</code>.</li> <li>To use our <code>Rating</code> component in a custom action, we must explicitly specify an <code>id</code>.</li> <li>We attach the <code>clear_rating</code> action to the button so that it is triggered when the button is clicked. The output of <code>clear_rating</code> sets the value of <code>\"my_rating.value\"</code>, which corresponds to the <code>value</code> property of the <code>dmc.Rating</code> component produced by our custom <code>Rating</code> component.</li> </ol> <pre><code># Custom components are currently only possible via Python configuration\n</code></pre> <p></p>","path":["How to create custom components"],"tags":[]},{"location":"user-guides/custom-components/#model-id-as-input-and-output","level":3,"title":"Model ID as input and output","text":"<p>Note</p> <p>You do not need to follow these steps if any of these conditions holds:</p> <ul> <li>Your custom component is an extension of an existing component, in which case your model inherits the <code>_action_inputs</code> and <code>_action_outputs</code> properties automatically.</li> <li>You are happy to use Dash properties as input and output.</li> </ul> <p>Generally when we use actions and built-in Vizro components, we refer only to the <code>id</code> (in this example <code>\"my_rating\"</code>) rather than a Dash component property such as <code>\"my_rating.value\"</code>. To enable this, we must define some extra information in the custom component using <code>_action_inputs</code> and <code>_action_outputs</code>. Here we define a mapping that tells actions to map <code>\"my_rating\"</code> onto <code>\"my_rating.value\"</code>.</p> <pre><code>class Rating(vm.VizroBaseModel):\n    ...\n\n    @property\n    def _action_inputs(self):\n        return {\"__default__\": f\"{self.id}.value\"}  # (1)!\n\n    @property\n    def _action_outputs(self):\n        return {\"__default__\": f\"{self.id}.value\"}\n</code></pre> <ol> <li>The <code>\"__default__\"</code> key corresponds to the Dash component property used when an action input or output specifies only the <code>id</code> of <code>\"my_rating\"</code>. Typically this maps onto the most commonly used property of the core component produced by your custom component, which has <code>id=self.id</code>.</li> </ol> <p>This enables you to replace in your dashboard configuration all action input and output references to <code>\"my_rating.value\"</code> with just <code>\"my_rating\"</code>. The full code is given below.</p> Use custom component model ID as an action output app.pyyamlResult <pre><code>from typing import Literal\n\nfrom dash import html\nimport dash_mantine_components as dmc\nimport vizro.models as vm\nfrom vizro.models.types import capture\nfrom vizro import Vizro\n\n\nclass Rating(vm.VizroBaseModel):\n    type: Literal[\"rating\"] = \"rating\"\n    title: str\n    color: str = \"#00b4ff\"\n\n    @property\n    def _action_inputs(self):\n        return {\"__default__\": f\"{self.id}.value\"}\n\n    @property\n    def _action_outputs(self):\n        return {\"__default__\": f\"{self.id}.value\"}\n\n    def build(self):\n        return html.Div(\n            [\n                html.Legend(id=f\"{self.id}_title\", children=self.title, className=\"form-label\"),\n                dmc.Rating(id=self.id, color=self.color),\n            ]\n        )\n\n\nvm.Page.add_type(\"components\", Rating)\n\n\n@capture(\"action\")\ndef clear_rating():\n    return 0\n\n\npage = vm.Page(\n    title=\"New rating component\",\n    layout=vm.Flex(),\n    components=[\n        Rating(id=\"my_rating\", title=\"Rate the last movie you watched\"),\n        vm.Button(\n            text=\"Clear rating\",\n            actions=vm.Action(function=clear_rating(), outputs=\"my_rating\"),  # (1)!\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We replace <code>outputs=\"my_rating.value\"</code> with <code>outputs=\"my_rating\"</code>. This will look up the <code>\"__default__\"</code> key in the <code>_action_outputs</code> mapping defined for the the model with <code>id=\"my_rating\"</code>.</li> </ol> <pre><code># Custom components are currently only possible via Python configuration\n</code></pre> <p></p>","path":["How to create custom components"],"tags":[]},{"location":"user-guides/custom-components/#model-fields-as-input-and-output","level":3,"title":"Model fields as input and output","text":"<p>Note</p> <p>You do not need to follow these steps if any of these conditions holds:</p> <ul> <li>You do not wish to address anything other than your custom component's core component.</li> <li>You are happy to use Dash properties as input and output.</li> </ul> <p>To map your model's fields onto Dash component properties you can define further entries in <code>_action_inputs</code> and <code>_action_outputs</code>. For example, let's say we wanted to add a [radio items][vizro.models.RadioItems] model so the user can select which movie to rate. When the movie is selected, it will trigger an action that updates the <code>title</code> of our custom <code>Rating</code> component. This corresponds to the following Dash component produced in the <code>Rating</code> model's <code>build</code> method:</p> <pre><code>html.Legend(id=f\"{self.id}_title\", children=self.title, className=\"form-label\")\n</code></pre> <p>We can already address this Dash property by using <code>\"my_rating_title.children\"</code> as an action input or output. To enable us to instead address the field with <code>\"my_rating.title\"</code>, we must add an additional mapping to <code>_action_inputs</code> and/or <code>_action_outputs</code>:</p> <pre><code>@property\ndef _action_outputs(self):\n    return {\"__default__\": f\"{self.id}.value\", \"title\": f\"{self.id}_title.children\"}\n</code></pre> <p>This enables you to replace in your dashboard configuration all references to <code>output=\"my_rating_title.children\"</code> with <code>output=\"my_rating.title\"</code>. The full code is given below.</p> Use custom component model field as an action output app.pyyamlResult <pre><code>from typing import Literal\n\nfrom dash import html\nimport dash_mantine_components as dmc\nimport vizro.models as vm\nfrom vizro.models.types import capture\nfrom vizro import Vizro\n\n\nclass Rating(vm.VizroBaseModel):\n    type: Literal[\"rating\"] = \"rating\"\n    title: str\n    color: str = \"#00b4ff\"\n\n    @property\n    def _action_inputs(self):\n        return {\"__default__\": f\"{self.id}.value\"}\n\n    @property\n    def _action_outputs(self):\n        return {\"__default__\": f\"{self.id}.value\", \"title\": f\"{self.id}_title.children\"}\n\n    def build(self):\n        return html.Div(\n            [\n                html.Legend(id=f\"{self.id}_title\", children=self.title, className=\"form-label\"),\n                dmc.Rating(id=self.id, color=self.color),\n            ]\n        )\n\n\nvm.Page.add_type(\"components\", Rating)\nvm.Page.add_type(\"components\", vm.RadioItems) # (1)!\n\n\n@capture(\"action\")\ndef clear_rating():\n    return 0\n\n\n@capture(\"action\") # (2)!\ndef set_movie_title(title):\n    return f\"Rate the movie {title}\"\n\n\npage = vm.Page(\n    title=\"New rating component\",\n    layout=vm.Flex(),\n    components=[\n        vm.RadioItems( # (3)!\n            id=\"movie_title\",\n            options=[\"Casablanca\", \"Citizen Kane\", \"Gone with the Wind\"],\n            actions=vm.Action(\n                function=set_movie_title(title=\"movie_title\"), # (4)!\n                outputs=\"my_rating.title\" # (5)!\n            ),\n        ),\n        Rating(id=\"my_rating\", title=\"Select a movie to rate\"),\n        vm.Button(\n            text=\"Clear rating\",\n            actions=vm.Action(function=clear_rating(), outputs=\"my_rating\"),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>Currently [<code>RadioItems</code>][vizro.models.RadioItems] is designed to be used as a control selector. In future, Vizro will have a dedicated <code>Form</code> model for the creation of forms. For now, we add form components directly as <code>components</code> inside the <code>Page</code>. For this to be a valid configuration we must first do <code>add_type</code> as for a custom component.</li> <li>We write a custom action <code>set_movie_title</code> that takes in the <code>title</code> specified and returns a string \"Rate the movie ...\".</li> <li>We attach the <code>set_movie_title</code> action to the radio items, so that it is triggered when an option is selected.</li> <li>The input <code>\"movie_title\"</code> corresponds to the value selected in the radio items and sets the <code>title</code> argument of the <code>set_movie_title</code> action.</li> <li>The output of <code>set_movie_title</code> sets the value of <code>\"my_rating.title\"</code>, which maps onto the contents of the legend in the <code>Rating(id=\"my_rating\")</code> component.</li> </ol> <pre><code># Custom components are currently only possible via Python configuration\n</code></pre> <p></p>","path":["How to create custom components"],"tags":[]},{"location":"user-guides/custom-components/#trigger-actions","level":3,"title":"Trigger actions","text":"<p>Note</p> <p>You do not need to follow these steps if your custom component is an extension of an existing component, in which case your model inherits the <code>_action_triggers</code> property automatically.</p> <p>To enable your custom component to trigger one or multiple actions:</p> <ol> <li>Add a field <code>actions</code> of type [<code>ActionsType</code>][vizro.models.types.ActionsType].</li> <li>Set the action trigger using <code>make_actions_chain</code> and <code>_action_triggers</code>.</li> <li>When the custom component is used, attach one or more built-in actions or custom actions to it by setting the <code>actions</code> field.</li> </ol> <p>For example, let's make our <code>Rating</code> component trigger an action when the user clicks on the stars. Clicking the stars updates the <code>value</code> property, and so this must be linked to the <code>\"__default__\"</code> key in the <code>_action_triggers</code> mapping as follows:</p> <pre><code>from pydantic import model_validator\nfrom vizro.models._models_utils import make_actions_chain\nfrom vizro.models.types import ActionsType\n\n\nclass Rating(vm.VizroBaseModel):\n    ...\n    actions: ActionsType\n\n    _make_actions_chain = model_validator(mode=\"after\")(make_actions_chain)\n\n    @property\n    def _action_triggers(self):\n        return {\"__default__\": f\"{self.id}.value\"}\n</code></pre> <p>In our dashboard configuration we would then attach the actions to trigger when we configure the <code>Rating</code> component:</p> <pre><code>Rating(..., actions=...)\n</code></pre> <p>A full example is given below.</p> Trigger actions with a custom component app.pyyamlResult <pre><code>from typing import Literal\n\nfrom dash import html\nimport dash_mantine_components as dmc\nfrom pydantic import model_validator\nimport vizro.models as vm\nfrom vizro.models._models_utils import make_actions_chain\nfrom vizro.models.types import capture, ActionsType\nfrom vizro import Vizro\n\n\nclass Rating(vm.VizroBaseModel):\n    type: Literal[\"rating\"] = \"rating\"\n    title: str\n    color: str = \"#00b4ff\"\n    actions: ActionsType\n\n    _make_actions_chain = model_validator(mode=\"after\")(make_actions_chain)\n\n    @property\n    def _action_triggers(self):\n        return {\"__default__\": f\"{self.id}.value\"}\n\n    @property\n    def _action_inputs(self):\n        return {\"__default__\": f\"{self.id}.value\"}\n\n    @property\n    def _action_outputs(self):\n        return {\"__default__\": f\"{self.id}.value\", \"title\": f\"{self.id}_title.children\"}\n\n    def build(self):\n        return html.Div(\n            [\n                html.Legend(id=f\"{self.id}_title\", children=self.title, className=\"form-label\"),\n                dmc.Rating(id=self.id, color=self.color),\n            ]\n        )\n\n\nvm.Page.add_type(\"components\", Rating)\nvm.Page.add_type(\"components\", vm.RadioItems)\n\n\n@capture(\"action\")\ndef clear_rating():\n    return 0\n\n\n@capture(\"action\")\ndef set_movie_title(title):\n    return f\"Rate the movie {title}\"\n\n\n@capture(\"action\")\ndef update_rating_text(rating_value): # (1)!\n    if rating_value:\n        return f\"You gave a rating of {rating_value} out of 5 stars\"\n    return \"You have not provided a rating\"\n\n\npage = vm.Page(\n    title=\"New rating component\",\n    layout=vm.Flex(),\n    components=[\n        vm.RadioItems(\n            id=\"movie_title\",\n            options=[\"Casablanca\", \"Citizen Kane\", \"Gone with the Wind\"],\n            actions=vm.Action(\n                function=set_movie_title(\"movie_title\"),\n                outputs=\"my_rating.title\"\n            ),\n        ),\n        Rating(\n            id=\"my_rating\",\n            title=\"Select a movie to rate\",\n            actions=vm.Action(\n                function=update_rating_text(\"my_rating\"), # (2)!\n                outputs=\"rating_text\" # (3)!\n            ),\n        ),\n        vm.Text(id=\"rating_text\", text=\"You have not provided a rating\"),\n        vm.Button(\n            text=\"Clear rating\",\n            actions=vm.Action(function=clear_rating(), outputs=\"my_rating\"),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We write a custom action <code>update_rating_text</code> that takes in the <code>rating_value</code> (an integer between 1 and 5) and returns a string \"You gave a rating of ...\".</li> <li>We attach the <code>update_rating_text</code> action to our custom <code>Rating</code> component, so that it is triggered when the rating stars are clicked. The input <code>\"my_rating\"</code> (which also maps onto <code>\"my_rating.value\"</code>) sets the <code>rating_value</code> argument of the <code>update_rating_text</code> action.</li> <li>The output of <code>update_rating_text</code> sets the value of <code>\"rating_text\"</code>, which maps onto the contents of the <code>vm.Text(id=\"rating_text\")</code> component.</li> </ol> <pre><code># Custom components are currently only possible via Python configuration\n</code></pre> <p></p>","path":["How to create custom components"],"tags":[]},{"location":"user-guides/custom-components/#persistence","level":2,"title":"Persistence","text":"<p>By default, all Dash components in Vizro that persist clientside data set <code>persistence_type=\"session\"</code> to use <code>window.SessionStorage</code>, which is cleared upon closing the browser.</p> <p>Be careful when using any custom components that persist data beyond this scope: it is your responsibility to ensure compliance with any legal requirements affecting jurisdictions in which your app operates.</p>","path":["How to create custom components"],"tags":[]},{"location":"user-guides/custom-css/","level":1,"title":"How to customize dashboard CSS","text":"<p>Vizro is opinionated about visual formatting, and some elements, such as the layout of the navigation and controls, are fixed. You can customize some settings such as background colors, fonts, and other styles via CSS overrides.</p> <p>To make customizations, you need to:</p> <ol> <li>Add a CSS file to your <code>assets</code> folder. Refer to our user guide on adding static assets.</li> <li>Identify the correct CSS selector for the component you want to style.</li> <li>Change the relevant CSS properties in your CSS file.</li> </ol> <p>For quick visual fixes, you may shortcut by using the <code>extra</code> argument</p> <p>If you want to alter the visual appearance of a single component quickly, or if you are not yet comfortable with creating a CSS file, you could opt for an alternative approach. Many of our models have an <code>extra</code> argument, that let's you pass arguments to the underlying Dash component directly. Often these components have a <code>style</code> or <code>className</code> argument that let's you alter the style directly. You can check the API reference of the model in question. An example of this would be to make the [<code>Button</code>][vizro.models.Button] outlined and green.</p>","path":["How to customize dashboard CSS"],"tags":[]},{"location":"user-guides/custom-css/#introduction-to-vizro-css","level":2,"title":"Introduction to Vizro CSS","text":"<p>For a short introduction to CSS, we recommend reading this article: Get Started with CSS in 5 Minutes.</p> <p>For a more comprehensive tutorial, refer to the W3Schools CSS tutorial. The entire tutorial is beneficial, but the section on CSS selectors will be particularly useful.</p> <p>In Vizro, the CSS file is read in as an external stylesheet. The most common way of applying any styling to Vizro is therefore through the use of CSS selectors:</p> <ul> <li> <p>Element Selector: Applies the style to all elements inside the Vizro app.</p> <pre><code>h1 {\n    font-size: 20px;\n}\n\np {\n    color: green;\n}\n</code></pre> </li> <li> <p>Class selector: Targets all elements with the given class for styling. All CSS classes must be preceded with a <code>.</code> symbol.</p> <pre><code>.card {\n    background: lightblue;\n}\n</code></pre> </li> <li> <p>ID selector: Targets the element with the given ID for styling. All CSS IDs must be preceded by a <code>#</code> symbol.</p> <pre><code>#my-card {\n    background: lightblue;\n}\n</code></pre> </li> </ul>","path":["How to customize dashboard CSS"],"tags":[]},{"location":"user-guides/custom-css/#identify-the-correct-css-selector","level":2,"title":"Identify the correct CSS selector","text":"<p>Use Chrome DevTools or a similar tool (Web Inspector, Web Developer Tools, etc.) to inspect the HTML document in your browser.</p> <ol> <li> <p>Open DevTools: In Google Chrome, right-click on the app and select \"Inspect\" from the context menu. This opens the HTML document of your Vizro app.</p> <p></p> </li> <li> <p>Select an element: Suppose you want to change the background color of your cards. Click the \"Select an element in the page to inspect it\" icon in the top left corner of the inspect panel.</p> <p></p> </li> <li> <p>Find the HTML Block: Hover over the component you want to style. The corresponding HTML block will be highlighted in the HTML document.</p> <p></p> <p>Notice that the selected HTML block corresponds to the container of the card and has a CSS class, here it is <code>card</code>.</p> </li> <li> <p>Apply CSS: Use this CSS class to style the card component. In your CSS file, you can write:</p> <pre><code>.card {\n    background-color: blue;\n}\n</code></pre> <p>This changes the background color for any HTML element with the <code>card</code> class.</p> </li> </ol> <p>Tip: You can also test your CSS live by editing the CSS attributes in the \"Elements\" panel. For example, temporarily add <code>background: blue;</code>. Note that this change will be lost upon reloading the page.</p> <p></p>","path":["How to customize dashboard CSS"],"tags":[]},{"location":"user-guides/custom-css/#css-overwrites","level":2,"title":"CSS overwrites","text":"","path":["How to customize dashboard CSS"],"tags":[]},{"location":"user-guides/custom-css/#overwrite-css-globally","level":3,"title":"Overwrite CSS globally","text":"<p>To overwrite any global CSS property, you need to target the element selector and place your CSS file with the overwrites in the <code>assets</code> folder.</p> <p>Overwrite CSS globally</p> my_css_file.cssapp.pyapp.yamlResult <pre><code>h1,\nh2 {\n    color: hotpink;\n}\n</code></pre> <pre><code>import os\nimport vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n        title=\"Changing the header color\",\n        components=[\n            vm.Card(\n                text=\"\"\"\n\n                    # This is an &lt;h1&gt; tag\n\n                    ## This is an &lt;h2&gt; tag\n\n                    ###### This is an &lt;h6&gt; tag\n                \"\"\")\n            ],\n        )\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <p>Run and edit this code in PyCafe</p> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          # This is an &lt;h1&gt; tag\n\n          ## This is an &lt;h2&gt; tag\n\n          ###### This is an &lt;h6&gt; tag\n        type: card\n    title: Changing the header color\n</code></pre> <p></p>","path":["How to customize dashboard CSS"],"tags":[]},{"location":"user-guides/custom-css/#overwrite-css-for-selected-pages","level":3,"title":"Overwrite CSS for selected pages","text":"<p>To style components for a specific page, use the page's <code>id</code> in the CSS selectors. By default, this is the same as the page <code>title</code>, but such a value might not be a valid CSS identifier.</p> <p>A suitable <code>id</code> must be unique across all models in the dashboard and should contain only alphanumeric characters, hyphens (<code>-</code>) and underscores (<code>_</code>). In particular, note that spaces are not allowed.</p> <p>Suppose you want to hide the page title on one page only. Here's how you can achieve this:</p> <ol> <li>Give a valid <code>id</code> to the <code>Page</code>, for example <code>Page(id=\"page-with-hidden-title\", title=\"Page with hidden title\", ...)</code>.</li> <li>Identify the CSS class or CSS <code>id</code> you need to target. To hide the page title, you need to hide the parent container with the id <code>page-header</code>.</li> <li>Use the <code>id</code> to hide the content.</li> <li>Add your custom css file to the <code>assets</code> folder.</li> </ol> <p>Hide page title on selected pages</p> my_css_file.cssapp.pyapp.yamlResult <pre><code>#page-with-hidden-title #page-header {\n    display: none;\n}\n</code></pre> <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage_one = vm.Page(\n    id=\"page-with-hidden-title\",\n    title=\"Page with hidden title\",\n    components=[vm.Card(text=\"\"\"# Placeholder\"\"\")]\n)\n\npage_two = vm.Page(\n    title=\"Page with shown title\",\n    components=[vm.Card(text=\"\"\"# Placeholder\"\"\")]\n)\n\ndashboard = vm.Dashboard(pages=[page_one, page_two])\nVizro().build(dashboard).run()\n</code></pre> <p>Run and edit this code in PyCafe</p> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          # Placeholder\n        type: card\n    title: Page with hidden title\n    id: page-with-hidden-title\n  - components:\n      - text: |\n          # Placeholder\n        type: card\n    title: Page with shown title\n</code></pre> <p></p>","path":["How to customize dashboard CSS"],"tags":[]},{"location":"user-guides/custom-css/#overwrite-css-for-selected-components","level":3,"title":"Overwrite CSS for selected components","text":"<p>To adjust CSS properties for specific components, such as altering the appearance of a selected <code>Card</code> rather than all Cards, supply an <code>id</code> to the component you want to style.</p> <p>Let's say we want to change the <code>background-color</code> and <code>color</code> of a specific <code>Card</code>.</p> <p>Here's how you can do it:</p> <ol> <li>Assign a unique <code>id</code> to the relevant <code>Card</code>, for example: <code>Card(id=\"custom-card\", ...)</code></li> <li>Run your dashboard and open it in your browser</li> <li>View the HTML document to find the appropriate CSS class or element you need to target, as explained in the section on identifying the correct CSS selector.</li> </ol> <p>It's essential to understand the relationship between the targeted CSS class or element and the component assigned <code>id</code>, for example:</p> HTML structure of a card<pre><code>&lt;div class=\"card\"&gt;\n &lt;div id=\"custom-card\"&gt;\n  &lt;p&gt;\n   Lorem ipsum dolor sit amet consectetur adipisicing elit.\n  &lt;/p&gt;\n &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <ul> <li>Main element with <code>id</code>: There is a <code>&lt;div&gt;</code> with our <code>id=\"custom-card\"</code>.</li> <li>Parent element: That <code>&lt;div&gt;</code> is wrapped inside a parent <code>&lt;div&gt;</code> with the class name <code>\"card\"</code>. This is the element we need to target to change the background color.</li> <li>Child element: The card text is wrapped inside a <code>&lt;p&gt;</code> that is a child of the <code>&lt;div&gt;</code> with our <code>id</code>. This is the element we need to target to change the font color.</li> </ul> <p>Customizing CSS properties in selective components</p> my_css_file.cssapp.pyapp.yamlResult <pre><code>/* Apply styling to parent */\n.card:has(#custom-card) {\n    background-color: white;\n}\n\n/* Apply styling to child */\n#custom-card p {\n    color: black;\n}\n</code></pre> <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"Changing the card color\",\n    components=[\n        vm.Card(id=\"custom-card\", text=\"\"\"Lorem ipsum dolor sit amet consectetur adipisicing elit.\"\"\"),\n        vm.Card(text=\"\"\"Lorem ipsum dolor sit amet consectetur adipisicing elit.\"\"\")\n             ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <p>Run and edit this code in PyCafe</p> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          Lorem ipsum dolor sit amet consectetur adipisicing elit.\n        type: card\n        id: custom-card\n      - text: |\n          Lorem ipsum dolor sit amet consectetur adipisicing elit.\n        type: card\n    title: Changing the card color\n</code></pre> <p></p> <p>Relationship between model ID and CSS ID</p> <p>Some Vizro components produce a single HTML element with an ID that matches the model ID, allowing you to target it directly using the CSS #id selector. Other components generate multiple HTML elements. Within these, the \"core\" element will have an ID matching the model ID, while non-core elements may have IDs that are variations of it, such as <code>{model-id}-title</code>.</p> <p>In all instances, you can determine the correct selector by using Chrome DevTools or a similar tool after setting the appropriate model ID.</p>","path":["How to customize dashboard CSS"],"tags":[]},{"location":"user-guides/custom-css/#common-examples","level":2,"title":"Common examples","text":"","path":["How to customize dashboard CSS"],"tags":[]},{"location":"user-guides/custom-css/#make-your-css-responsive-to-theme-switches-with-variables","level":3,"title":"Make your CSS responsive to theme switches with variables","text":"<p>To ensure your CSS adapts to theme changes, we recommend using CSS variables (<code>var</code>) whenever possible. For a comprehensive list of available variable names, refer to the Bootstrap documentation.</p>","path":["How to customize dashboard CSS"],"tags":[]},{"location":"user-guides/custom-css/#remove-theme-switch","level":3,"title":"Remove theme-switch","text":"<p>By default, Vizro displays a theme toggle button in the top right corner that allows users to switch between dark and light themes. If you want to restrict your dashboard to a single theme or prefer not to offer theme switching, you can hide this toggle using CSS.</p> <pre><code>#theme-selector {\n    display: none;\n}\n</code></pre>","path":["How to customize dashboard CSS"],"tags":[]},{"location":"user-guides/custom-css/#turn-off-page-title","level":3,"title":"Turn off page title","text":"<p>See the example above on hiding the page title on selected pages.</p>","path":["How to customize dashboard CSS"],"tags":[]},{"location":"user-guides/custom-css/#change-the-background-color-of-a-card","level":3,"title":"Change the background color of a card","text":"<p>See the example above on customizing CSS properties in selective components.</p>","path":["How to customize dashboard CSS"],"tags":[]},{"location":"user-guides/custom-css/#change-the-global-font","level":3,"title":"Change the global font","text":"<p>The default fonts for a Vizro app are <code>Inter, sans-serif, Arial, serif</code>.</p> <p>If you need to change the global font, perhaps to adhere to branding guidelines, follow these steps:</p> <ol> <li> <p>Download the desired font from a font provider such as Google Fonts.</p> </li> <li> <p>Place the font file (<code>.ttf</code>, <code>woff2</code>, etc.) into your <code>assets</code> folder. Here’s an example of what the assets folder might look like:</p> <p></p> </li> <li> <p>Add the font to your CSS file using the <code>@font-face</code> rule and apply the font globally to your Vizro app, making sure to specify fallback fonts. Add the following to your <code>custom.css</code> file:</p> <pre><code>@font-face {\n    font-family: PlayfairDisplay;\n    src: url(\"PlayfairDisplay-VariableFont_wght.ttf\") format(\"truetype\");\n}\n\n* {\n    font-family: PlayfairDisplay, Inter, sans-serif, Arial, serif;\n}\n</code></pre> </li> <li> <p>Note that the modification above applies solely to the dashboard font. To also change the font within the Plotly charts, you must specify this at the beginning of your <code>app.py</code> file:</p> <pre><code>import plotly.io as pio\n\npio.templates[\"vizro_dark\"][\"layout\"][\"font_family\"] = \"PlayfairDisplay, Inter, sans-serif, Arial, serif\"\npio.templates[\"vizro_light\"][\"layout\"][\"font_family\"] = \"PlayfairDisplay, Inter, sans-serif, Arial, serif\"\n</code></pre> </li> </ol>","path":["How to customize dashboard CSS"],"tags":[]},{"location":"user-guides/custom-css/#reposition-the-logo","level":3,"title":"Reposition the logo","text":"<p>By default, the logo appears in the top left corner of the dashboard. You can move it further to the left or right by adjusting the <code>padding</code> of the <code>#header</code> element. Here is an example of how to achieve this:</p> <pre><code>#header {\n    padding-left: 4px;\n}\n</code></pre> <p></p>","path":["How to customize dashboard CSS"],"tags":[]},{"location":"user-guides/custom-figures/","level":1,"title":"How to create custom figures","text":"<p>This guide explains how to create custom figures, which is useful when you need a component that reacts to filter and parameter controls.</p> <p>The [<code>Figure</code>][vizro.models.Figure] model accepts the <code>figure</code> argument, where you can enter any custom figure function as explained in the user guide on figures.</p>","path":["How to create custom figures"],"tags":[]},{"location":"user-guides/custom-figures/#when-to-use-a-custom-figure","level":2,"title":"When to use a custom figure","text":"<p>As described in the flowchart detailing when to use <code>Figure</code>, custom figures should be used if both of the following conditions are met:</p> <ul> <li>You need a figure that doesn't fit into the existing built-in models ([<code>Graph</code>][vizro.models.Graph], [<code>Table</code>][vizro.models.Table] or [<code>AgGrid</code>][vizro.models.AgGrid]).</li> <li>You need a figure that isn't available in our built-in figure functions <code>vizro.figures</code>.</li> </ul>","path":["How to create custom figures"],"tags":[]},{"location":"user-guides/custom-figures/#steps-to-create-a-custom-figure","level":2,"title":"Steps to create a custom figure","text":"<ol> <li>Define a function that returns a Dash component. This can, but does not need to, be based on code in our built-in figure functions in <code>vizro.figures</code>.</li> <li>Decorate it with <code>@capture(\"figure\")</code>.</li> <li>The function must accept a <code>data_frame</code> argument (of type <code>pandas.DataFrame</code>).</li> <li>The figure should be derived from and require only one <code>pandas.DataFrame</code>. Dataframes from other arguments will not react to dashboard controls such as <code>Filter</code>.</li> <li>Pass your function to the <code>figure</code> argument of the [<code>Figure</code>][vizro.models.Figure] model.</li> </ol> <p>The following examples can be used as a base to build more sophisticated figures.</p>","path":["How to create custom figures"],"tags":[]},{"location":"user-guides/custom-figures/#examples-of-custom-figures","level":2,"title":"Examples of custom figures","text":"","path":["How to create custom figures"],"tags":[]},{"location":"user-guides/custom-figures/#custom-kpi-card","level":3,"title":"Custom KPI card","text":"<p>To change the design or content of our existing KPI (key performance indicator) cards from <code>vizro.figures</code>, you can do so by following the steps described above.</p> <p>For instance, to make a KPI card with the icon positioned on the right side of the title instead of the left, copy and paste the source code of <code>kpi_card</code> and adjust the return statement of the function.</p> <p>Custom KPI card</p> app.pyapp.yamlResult <pre><code>import dash_bootstrap_components as dbc\nimport pandas as pd\nimport vizro.models as vm\nimport vizro.plotly.express as px\nfrom dash import html\nfrom vizro import Vizro\nfrom vizro.figures import kpi_card\nfrom vizro.models.types import capture\n\ntips = px.data.tips()\n\n\n@capture(\"figure\")  # (1)!\ndef custom_kpi_card(\n    data_frame: pd.DataFrame,\n    value_column: str,\n    *,\n    value_format: str = \"{value}\",\n    agg_func: str = \"sum\",\n    title: str | None,\n    icon: str | None,\n) -&gt; dbc.Card:  # (2)!\n    title = title or f\"{agg_func} {value_column}\".title()\n    value = data_frame[value_column].agg(agg_func)\n    header = dbc.CardHeader(\n            [\n                html.H4(title, className=\"card-kpi-title\"),\n                html.P(icon, className=\"material-symbols-outlined\") if icon else None,  # (3)!\n            ]\n        )\n    body = dbc.CardBody([value_format.format(value=value)])\n    return dbc.Card([header, body], class_name=\"card-kpi\")\n\n\npage = vm.Page(\n    title=\"Create your own KPI card\",\n    layout=vm.Flex(direction=\"row\"),  # (4)!\n    components=[\n        vm.Figure(\n            figure=kpi_card(  # (5)!\n                data_frame=tips,\n                value_column=\"tip\",\n                value_format=\"${value:.2f}\",\n                icon=\"Shopping Cart\",\n                title=\"Default KPI card\",\n            )\n        ),\n        vm.Figure(\n            figure=custom_kpi_card(  # (6)!\n                data_frame=tips,\n                value_column=\"tip\",\n                value_format=\"${value:.2f}\",\n                icon=\"Payment\",\n                title=\"Custom KPI card\",\n            )\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>Here we decorate our custom figure function with the <code>@capture(\"figure\")</code> decorator.</li> <li>The custom figure function needs to have a <code>data_frame</code> argument and return a <code>Dash</code> component.</li> <li>We adjust the return statement to include the icon on the right side of the title. This is achieved by swapping the order of the <code>html.H2</code> and <code>html.P</code> compared to the original <code>kpi_card</code>.</li> <li>We use a <code>Flex</code> layout with <code>direction=\"row\"</code> to ensure the KPI cards are placed side by side and only take up as much space as needed.</li> <li>For more information, refer to the API reference for the <code>kpi_card</code>.</li> <li>Our custom figure function <code>custom_kpi_card</code> now needs to be passed on to the <code>vm.Figure</code>.</li> </ol> <pre><code># Still requires a .py to add data to the data manager, define CapturedCallables, and parse YAML configuration\n# More explanation in the docs on `Dashboard` and extensions.\npages:\n  - components:\n      - figure:\n          _target_: kpi_card\n          data_frame: tips\n          value_column: tip\n          value_format: ${value:.2f}\n          icon: Shopping Cart\n          title: Default KPI card\n        type: figure\n      - figure:\n          _target_: __main__.custom_kpi_card\n          data_frame: tips\n          value_column: tip\n          value_format: ${value:.2f}\n          icon: Payment\n          title: Custom KPI card\n        type: figure\n    layout:\n      direction: row\n      type: flex\n    title: Create your own KPI card\n</code></pre> <p></p>","path":["How to create custom figures"],"tags":[]},{"location":"user-guides/custom-figures/#dynamic-html-header","level":3,"title":"Dynamic HTML header","text":"<p>You can create a custom figure for any Dash component. Below is an example of a custom figure that returns a <code>html.H2</code> component that dynamically updates based on the selected name from a filter.</p> <p>Dynamic HTML header</p> app.pyapp.yamlResult <pre><code>import pandas as pd\nimport vizro.models as vm\nfrom dash import html\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\ndf = pd.DataFrame({\"names\": [\"Emma\", \"Jack\", \"Sophia\", \"Ethan\", \"Mia\"]})\n\n\n@capture(\"figure\")  # (1)!\ndef dynamic_html_header(data_frame: pd.DataFrame, column: str) -&gt; html.H2:  # (2)!\n    \"\"\"Creates a HTML header that dynamically updates based on controls.\"\"\"\n    return html.H2(f\"Good morning, {data_frame[column].iloc[0]}! ☕ ⛅\")  # (3)!\n\n\npage = vm.Page(\n    title=\"Dynamic HTML header\",\n    components=[vm.Figure(figure=dynamic_html_header(data_frame=df, column=\"names\"))],  # (4)!\n    controls=[vm.Filter(column=\"names\", selector=vm.RadioItems(title=\"Select a name\"))],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>Here we decorate our custom figure function with the <code>@capture(\"figure\")</code> decorator.</li> <li>The custom figure function needs to have a <code>data_frame</code> argument and return a <code>Dash</code> component.</li> <li>We return a <code>html.H2</code> component that dynamically updates based on the selected name from the filter.</li> <li>Our custom figure function <code>dynamic_html_header</code> now needs to be passed on to the <code>vm.Figure</code>.</li> </ol> <pre><code># Still requires a .py to add data to the data manager, define CapturedCallables, and parse YAML configuration\n# More explanation in the docs on `Dashboard` and extensions.\npages:\n  - components:\n      - figure:\n          _target_: __main__.dynamic_html_header\n          data_frame: df\n          column: names\n        type: figure\n    controls:\n      - column: names\n        type: filter\n        selector:\n          type: radio_items\n    title: Dynamic HTML header\n</code></pre> <p></p>","path":["How to create custom figures"],"tags":[]},{"location":"user-guides/custom-figures/#dynamic-number-of-cards","level":3,"title":"Dynamic number of cards","text":"<p>The example below shows how to create multiple cards created from a <code>pandas.DataFrame</code> where the number of cards displayed dynamically adjusts based on a <code>vm.Parameter</code>.</p> <p>Dynamic number of cards</p> app.pystyling.cssapp.yamlResult <pre><code>import dash_bootstrap_components as dbc\nimport pandas as pd\nimport vizro.models as vm\nfrom dash import dcc, html\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\ntext = [\n    \"Lorem ipsum dolor sit amet, consetetur sadipscing no sea elitr sed diam nonumy.\",\n    \"Sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat.\",\n    \"Sed diam voluptua. At vero eos et accusam et justo no duo dolores et ea rebum.\",\n    \"Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.\",\n    \"Lorem ipsum dolor sit amet, consetetur sadipscing no sea est elitr dolor sit amet.\",\n    \"Sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat.\",\n]\n\ndf = pd.DataFrame({\"text\": text * 2})\n\n\n@capture(\"figure\")  # (1)!\ndef multiple_cards(data_frame: pd.DataFrame, n_rows: int = 1) -&gt; html.Div:  # (2)!\n    \"\"\"Creates a list with a variable number of `vm.Card` components from the provided data_frame.\n\n    Args:\n        data_frame: Data frame containing the data.\n        n_rows: Number of rows to use from the data_frame. Defaults to 1.\n\n    Returns:\n        html.Div with a list of dbc.Card objects generated from the data.\n\n    \"\"\"\n    texts = data_frame.head(n_rows)[\"text\"]\n    return html.Div(\n        [dbc.Card(dcc.Markdown(f\"### Card #{i}\\n{text}\")) for i, text in enumerate(texts, 1)],\n        className=\"multiple-cards-container\",\n    )\n\n\npage = vm.Page(\n    title=\"Page with variable number of cards\",\n    components=[vm.Figure(id=\"my-figure\", figure=multiple_cards(data_frame=df))],  # (3)!\n    controls=[\n        vm.Parameter(\n            targets=[\"my-figure.n_rows\"],  # (4)!\n            selector=vm.Slider(min=2, max=12, step=2, value=10, title=\"Number of cards to display\"),\n        ),\n    ],\n    layout=vm.Flex()\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>Here we decorate our custom figure function with the <code>@capture(\"figure\")</code> decorator.</li> <li>The custom figure function needs to have a <code>data_frame</code> argument and return a <code>Dash</code> component.</li> <li>Our decorated figure function <code>multiple_cards</code> now needs to be passed on to the <code>vm.Figure</code>.</li> <li>We add a <code>vm.Parameter</code> to dynamically adjust the number of cards displayed. The parameter targets the <code>n_rows</code> argument of the <code>multiple_cards</code> function, determining the number of rows taken from the data.</li> </ol> <p>Run and edit this code in PyCafe</p> <pre><code>.multiple-cards-container {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 12px;\n}\n\n.figure-container {\n    height: unset;\n    width: unset;\n}\n\n.figure-container .card {\n    height: 210px;\n    width: 240px;\n}\n</code></pre> <pre><code># Still requires a .py to add data to the data manager, define CapturedCallables, and parse YAML configuration\n# More explanation in the docs on `Dashboard` and extensions.\npages:\n  - components:\n      - figure:\n          _target_: __main__.multiple_cards\n          data_frame: df\n        id: my-figure\n        type: figure\n    controls:\n      - targets: [my-figure.n_rows]\n        type: parameter\n        selector:\n          type: slider\n          min: 2\n          max: 12\n          step: 2\n          value: 10\n          title: Number of cards to display\n    layout:\n      type: flex\n    title: Dynamic HTML header\n</code></pre> <p></p>","path":["How to create custom figures"],"tags":[]},{"location":"user-guides/custom-tables/","level":1,"title":"How to create custom Dash AG Grids and Dash DataTables","text":"<p>In cases where the available arguments for the [<code>dash_ag_grid</code>][vizro.tables.dash_ag_grid] or [<code>dash_data_table</code>][vizro.tables.dash_data_table] models are not sufficient, you can create a custom Dash AG Grid or Dash DataTable.</p> <p>The [<code>Table</code>][vizro.models.Table] and the [<code>AgGrid</code>][vizro.models.AgGrid] model accept the <code>figure</code> argument, where you can enter any [<code>dash_ag_grid</code>][vizro.tables.dash_ag_grid] or [<code>dash_data_table</code>][vizro.tables.dash_data_table] chart as explained in the user guide on tables.</p> <p>More examples of AG Grid</p> <p>If you would like to see more than the below examples on what can be done with AG Grid and Dash DataTables, head to the Dash AG Grid and Dash DataTable documentation respectively. Almost anything you see there is possible in Vizro by modifying the examples below.</p> <p>One reason to customize could be that you want to create a table/grid that requires computations that can be controlled by parameters. The below example shows this for the case of AG Grid and Dash DataTable.</p>","path":["How to create custom Dash AG Grids and Dash DataTables"],"tags":[]},{"location":"user-guides/custom-tables/#steps-to-create-a-custom-table","level":3,"title":"Steps to create a custom table","text":"<ol> <li>Define a function that returns a <code>dash_ag_grid.AgGrid</code> or <code>dash_table.DataTable</code> object.</li> <li>Decorate it with <code>@capture(\"ag_grid\")</code> or <code>@capture(\"table\")</code>.</li> <li>The function must accept a <code>data_frame</code> argument (of type <code>pandas.DataFrame</code>).</li> <li>The table should be derived from and require only one <code>pandas.DataFrame</code>. Dataframes from other arguments will not react to dashboard controls such as <code>Filter</code>.</li> <li>Pass your function to the <code>figure</code> argument of the [<code>Table</code>][vizro.models.Table] or [<code>AgGrid</code>][vizro.models.AgGrid] model.</li> </ol> <p>The following examples show a possible version of a custom table. In this case the argument <code>chosen_columns</code> was added, which you can control with a parameter:</p> Custom Dash DataTable app.pyapp.yamlResult <pre><code>from dash import dash_table\n\nimport vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\ndf = px.data.gapminder().query(\"year == 2007\")\n\n\n@capture(\"table\")\ndef my_custom_table(chosen_columns: list[str], data_frame=None):\n    columns = [{\"name\": i, \"id\": i} for i in chosen_columns]\n    defaults = {\n        \"style_as_list_view\": True,\n        \"style_data\": {\"border_bottom\": \"1px solid var(--bs-border-color)\", \"height\": \"40px\"},\n        \"style_header\": {\n            \"border_bottom\": \"1px solid var(--bs-border-color-translucent)\",\n            \"border_top\": \"None\",\n            \"height\": \"32px\",\n        },\n    }\n    return dash_table.DataTable(data=data_frame.to_dict(\"records\"), columns=columns, **defaults)\n\n\npage = vm.Page(\n    title=\"Example of a custom Dash DataTable\",\n    components=[\n        vm.Table(\n            id=\"custom_table\",\n            title=\"Custom Dash DataTable\",\n            figure=my_custom_table(\n                data_frame=df, chosen_columns=[\"country\", \"continent\", \"lifeExp\", \"pop\", \"gdpPercap\"]\n            ),\n        ),\n    ],\n    controls=[\n        vm.Parameter(\n            targets=[\"custom_table.chosen_columns\"],\n            selector=vm.Dropdown(title=\"Choose columns\", options=df.columns.to_list()),\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager, define CapturedCallables, and parse YAML configuration\n# More explanation in the docs on `Dashboard` and extensions.\npages:\n  - components:\n      - figure:\n          _target_: __main__.my_custom_table\n          chosen_columns:\n            - country\n            - continent\n            - lifeExp\n            - pop\n            - gdpPercap\n          data_frame: gapminder_2007\n        id: custom_table\n        title: Custom Dash DataTable\n        type: table\n    controls:\n      - selector:\n          options:\n            - country\n            - continent\n            - lifeExp\n            - pop\n            - gdpPercap\n            - year\n          title: Choose columns\n          type: dropdown\n        targets:\n          - custom_table.chosen_columns\n        type: parameter\n    title: Example of a custom Dash DataTable\n</code></pre> <p></p> Custom Dash AgGrid app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom dash_ag_grid import AgGrid\nfrom vizro import Vizro\nfrom vizro.models.types import capture\n\ndf = px.data.gapminder().query(\"year == 2007\")\n\n\n@capture(\"ag_grid\")\ndef my_custom_aggrid(chosen_columns: list[str], data_frame=None):\n    defaults = {\n        \"className\": \"ag-theme-quartz-dark ag-theme-vizro\",\n        \"defaultColDef\": {\n            \"resizable\": True,\n            \"sortable\": True,\n            \"filter\": True,\n            \"filterParams\": {\n                \"buttons\": [\"apply\", \"reset\"],\n                \"closeOnApply\": True,\n            },\n            \"flex\": 1,\n            \"minWidth\": 70,\n        },\n    }\n    return AgGrid(\n        columnDefs=[{\"field\": col} for col in chosen_columns], rowData=data_frame.to_dict(\"records\"), **defaults\n    )\n\n\npage = vm.Page(\n    title=\"Example of a custom Dash AgGrid\",\n    components=[\n        vm.AgGrid(\n            id=\"custom_ag_grid\",\n            title=\"Custom Dash AgGrid\",\n            figure=my_custom_aggrid(\n                data_frame=df, chosen_columns=[\"country\", \"continent\", \"lifeExp\", \"pop\", \"gdpPercap\"]\n            ),\n        ),\n    ],\n    controls=[\n        vm.Parameter(\n            targets=[\"custom_ag_grid.chosen_columns\"],\n            selector=vm.Dropdown(title=\"Choose columns\", options=df.columns.to_list()),\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager, define CapturedCallables and parse YAML configuration\n# More explanation in the docs on `Dashboard` and extensions.\npages:\n  - components:\n      - figure:\n          _target_: __main__.my_custom_aggrid\n          chosen_columns:\n            - country\n            - continent\n            - lifeExp\n            - pop\n            - gdpPercap\n          data_frame: gapminder_2007\n        id: custom_ag_grid\n        title: Custom Dash AgGrid\n        type: ag_grid\n    controls:\n      - selector:\n          options:\n            - country\n            - continent\n            - lifeExp\n            - pop\n            - gdpPercap\n            - year\n          title: Choose columns\n          type: dropdown\n        targets:\n          - custom_ag_grid.chosen_columns\n        type: parameter\n    title: Example of a custom Dash AgGrid\n</code></pre> <p></p>","path":["How to create custom Dash AG Grids and Dash DataTables"],"tags":[]},{"location":"user-guides/custom-tables/#interact-with-other-graphs-and-tables","level":2,"title":"Interact with other graphs and tables","text":"<p>A custom AG Grid can act as a source for interactions with other components, for example to cross-filter another graph or table when the user clicks on a point.</p>","path":["How to create custom Dash AG Grids and Dash DataTables"],"tags":[]},{"location":"user-guides/dashboard/","level":1,"title":"How to create a dashboard","text":"<p>This guide shows you how to configure and call a [<code>Dashboard</code>][vizro.models.Dashboard] model using either pydantic models, Python dictionaries, YAML, or JSON.</p> <p>To create a dashboard:</p> <ol> <li>Choose one of the possible configuration syntaxes</li> <li>Create your <code>pages</code></li> <li>(optional) Customize your <code>navigation</code>, see our guide on Navigation</li> <li>(optional) Set a <code>title</code> for your dashboard</li> <li>(optional) Set a <code>description</code> for your dashboard to add a tooltip and set meta tags</li> <li>(optional) Choose a <code>theme</code>, see our guide on Themes</li> <li>Add your <code>dashboard</code> to the <code>build</code> call of Vizro</li> </ol>","path":["How to create a dashboard"],"tags":[]},{"location":"user-guides/dashboard/#use-dashboard-configuration-options","level":2,"title":"Use dashboard configuration options","text":"<p>Dashboard Configuration Syntaxes</p> app.py - pydantic modelsapp.py - Python dictdashboard.yamldashboard.jsonResult <pre><code>import vizro.plotly.express as px\nfrom vizro import Vizro\nimport vizro.models as vm\n\ndf = px.data.iris()\n\npage = vm.Page(\n    title=\"My first dashboard\",\n    components=[\n        vm.Graph(figure=px.scatter(df, x=\"sepal_length\", y=\"petal_width\", color=\"species\")),\n        vm.Graph(figure=px.histogram(df, x=\"sepal_width\", color=\"species\"))],\n    controls=[\n        vm.Filter(column=\"species\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code>import vizro.plotly.express as px\nfrom vizro import Vizro\n\ndf = px.data.iris()\n\npage = {\n    \"title\": \"My first dashboard\",\n    \"components\": [\n        {\n            \"type\": \"graph\",\n            \"figure\": px.scatter(\n                df,\n                x=\"sepal_length\",\n                y=\"petal_width\",\n                color=\"species\",\n            ),\n        },\n        {\n            \"type\": \"graph\",\n            \"figure\": px.histogram(\n                df,\n                x=\"sepal_width\",\n                color=\"species\"\n            ),\n        },\n    ],\n    \"controls\": [\n        {\n            \"type\": \"filter\",\n            \"column\": \"species\",\n        },\n    ],\n}\n\ndashboard = {\"pages\": [page]}\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: scatter\n          data_frame: iris\n          x: sepal_length\n          y: petal_width\n          color: species\n        type: graph\n      - figure:\n          _target_: histogram\n          data_frame: iris\n          x: sepal_width\n          color: species\n        type: graph\n    controls:\n      - column: species\n        type: filter\n    title: My first dashboard\n</code></pre> <pre><code>{\n  \"pages\": [\n    {\n      \"components\": [\n        {\n          \"figure\": {\n            \"_target_\": \"scatter\",\n            \"color\": \"species\",\n            \"data_frame\": \"iris\",\n            \"x\": \"sepal_length\",\n            \"y\": \"petal_width\"\n          },\n          \"type\": \"graph\"\n        },\n        {\n          \"figure\": {\n            \"_target_\": \"histogram\",\n            \"color\": \"species\",\n            \"data_frame\": \"iris\",\n            \"x\": \"sepal_width\"\n          },\n          \"type\": \"graph\"\n        }\n      ],\n      \"controls\": [\n        {\n          \"column\": \"species\",\n          \"type\": \"filter\"\n        }\n      ],\n      \"title\": \"My first dashboard\"\n    }\n  ]\n}\n</code></pre> <p></p> <p>Extra <code>.py</code> files for <code>yaml</code> and <code>json</code> required</p> <p>Note that in the <code>yaml</code> and <code>json</code> example an extra <code>.py</code> is required to register the data and parse the yaml/json configuration.</p> app.py for yamlapp.py for json <pre><code>from pathlib import Path\n\nimport yaml\n\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.managers import data_manager\nfrom vizro.models import Dashboard\n\ndata_manager[\"iris\"] = px.data.iris()\ndashboard = yaml.safe_load(Path(\"dashboard.yaml\").read_text(encoding=\"utf-8\"))\ndashboard = Dashboard(**dashboard)\n\nVizro().build(dashboard).run()\n</code></pre> <pre><code>import json\nfrom pathlib import Path\n\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.managers import data_manager\nfrom vizro.models import Dashboard\n\ndata_manager[\"iris\"] = px.data.iris()\ndashboard = json.loads(Path(\"dashboard.json\").read_text(encoding=\"utf-8\"))\ndashboard = Dashboard(**dashboard)\n\nVizro().build(dashboard).run()\n</code></pre> <p>After running the dashboard, you can access the dashboard via <code>localhost:8050</code>.</p>","path":["How to create a dashboard"],"tags":[]},{"location":"user-guides/dashboard/#add-a-dashboard-title","level":2,"title":"Add a dashboard title","text":"<p>If supplied, the <code>title</code> of the [<code>Dashboard</code>][vizro.models.Dashboard] model displays a heading at the top of every page.</p>","path":["How to create a dashboard"],"tags":[]},{"location":"user-guides/dashboard/#add-a-dashboard-logo","level":2,"title":"Add a dashboard logo","text":"<p>Vizro automatically displays a logo in the top-left corner of each page if you place an image named <code>logo.&lt;extension&gt;</code> in the assets folder. You can also add theme-specific logos named <code>logo-dark.&lt;extension&gt;</code> and <code>logo-light.&lt;extension&gt;</code>, which switch automatically with the active theme. By default, clicking the logo takes you to the homepage.</p> <p></p>","path":["How to create a dashboard"],"tags":[]},{"location":"user-guides/dashboard/#add-a-dashboard-tooltip","level":2,"title":"Add a dashboard tooltip","text":"<p>The <code>description</code> argument enables you to add helpful context to your dashboard by displaying an info icon next to its title. Hovering over the icon shows a tooltip with your provided text.</p> <p>You can provide Markdown text as a string to use the default info icon or a [<code>Tooltip</code>][vizro.models.Tooltip] model to use any icon from the Google Material Icons library.</p> <p></p>","path":["How to create a dashboard"],"tags":[]},{"location":"user-guides/dashboard/#customize-the-header","level":2,"title":"Customize the header","text":"<p>You can add custom content to the dashboard header using the [<code>Dashboard.custom_header</code>][vizro.models.Dashboard.custom_header] method. This enables you to inject any Dash component(s) into a dedicated area of the header. Common examples include text, badges, or buttons.</p> <p></p> <p>To add items to the custom header area, subclass the Dashboard[vizro.models.Dashboard] model and override the [<code>custom_header</code>][vizro.models.Dashboard.custom_header] method to return your desired Dash component(s):</p> <ul> <li>The returned value can be a single Dash component or a list of components.</li> <li>The custom header area is styled as a flex row with an 8px gap.</li> <li>The custom content will appear in the header, to the left of the theme switch.</li> </ul> <p>Customize dashboard header</p> app.pyapp.yamlResult <pre><code>from vizro import Vizro\nimport vizro.models as vm\nfrom typing import Literal\nfrom dash import html\nimport dash_bootstrap_components as dbc\n\n\nclass CustomDashboard(vm.Dashboard):\n    type: Literal[\"custom_dashboard\"] = \"custom_dashboard\"\n\n    def custom_header(self):\n        return [html.Div(\"Good morning, Li! ☕\"), dbc.Badge(\"Tuesday\", color=\"primary\")]\n\n\npage = vm.Page(title=\"Page Title\", components=[vm.Card(text=\"Placeholder\")])\ndashboard = CustomDashboard(pages=[page], title=\"Dashboard with custom header\")\nVizro().build(dashboard).run()\n</code></pre> <p>Custom dashboards are currently only possible via Python configuration.</p> <p></p>","path":["How to create a dashboard"],"tags":[]},{"location":"user-guides/dashboard/#meta-tags-for-social-media","level":2,"title":"Meta tags for social media","text":"<p>Vizro automatically adds meta tags to display a preview card when your app is shared on social media and chat clients. To see an example, try sharing an example such the Vizro visual vocabulary dashboard.</p> <p>The preview includes:</p> <ul> <li>the dashboard <code>title</code> and the [Page <code>title</code>][vizro.models.Page]</li> <li>an image if a suitable assets file exists</li> <li>the dashboard <code>description</code> or the [Page <code>description</code>][vizro.models.Page]</li> </ul>","path":["How to create a dashboard"],"tags":[]},{"location":"user-guides/dashboard/#browser-title","level":2,"title":"Browser title","text":"<p>The website icon, Dashboard <code>title</code> (if supplied) and [Page <code>title</code>][vizro.models.Page] are displayed in the browser's title bar. For example, if your Dashboard <code>title</code> is \"Vizro Demo\" and the Page <code>title</code> is \"Homepage\", then the title in the browser tab will be \"Vizro Demo: Homepage\".</p>","path":["How to create a dashboard"],"tags":[]},{"location":"user-guides/data-actions/","level":1,"title":"How to use actions to handle data","text":"","path":["How to use actions to handle data"],"tags":[]},{"location":"user-guides/data-actions/#export-data","level":2,"title":"Export data","text":"<p>To download data from your dashboard, you can use the [<code>export_data</code> action][vizro.actions.export_data]. For example, you can attach the action to a button as follows. When a user clicks the \"Export data\" button, all data on the page is downloaded.</p> <p>Export data action</p> app.pyapp.yamlResult <pre><code>import vizro.actions as va\nimport vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\ndf = px.data.iris()\n\npage = vm.Page(\n    title=\"Action triggered by a button\",\n    components=[\n        vm.Graph(figure=px.histogram(df, x=\"sepal_length\")),\n        vm.Button(text=\"Export data\", actions=va.export_data()),\n    ],\n    controls=[vm.Filter(column=\"species\")],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - type: graph\n        figure:\n          _target_: histogram\n          x: sepal_length\n      - type: button\n        text: Export data\n        actions:\n          - type: export_data\n  - controls:\n      - type: filter\n        column: species\n    layout:\n      type: flex\n    title: Action triggered by a button\n</code></pre> <p></p> <p>When you click the \"Export data\" button, the data for all graphs, tables and figures on the page is downloaded. In this example, this will produce a csv file for the graph's source data <code>px.data.iris()</code>.</p> <p>Exported data includes the effect of controls such as filters and dynamic data parameters. Modifications from the chart, table or figure itself are not included (for example, AG Grid filters, graph zoom and data transformations performed inside a custom chart functions).</p>","path":["How to use actions to handle data"],"tags":[]},{"location":"user-guides/data/","level":1,"title":"How to connect your dashboard to data","text":"<p>Vizro supports two different types of data:</p> <ul> <li>Static data: pandas DataFrame. This is the simplest method and best to use if you do not need the more advanced functionality of dynamic data.</li> <li>Dynamic data: function that returns a pandas DataFrame. This is a bit more complex to understand but has more advanced functionality such as the ability to refresh data while the dashboard is running.</li> </ul> <p>The following flowchart shows what you need to consider when choosing how to set up your data.</p> <pre><code>graph TD\n  refresh[\"`Do you need your data to refresh while the dashboard is running?`\"]\n  specification[\"`Do you need to specify your dashboard through a configuration language like YAML?`\"]\n  dynamic([Use dynamic data referenced by name])\n  static-direct([Use static data supplied directly])\n  static-name([Use static data referenced by name])\n\n  refresh -- No --&gt; specification\n  refresh -- Yes --&gt; dynamic\n  specification -- No --&gt; static-direct\n  specification -- Yes --&gt; static-name\n\n  click static-direct href \"#supply-directly\"\n  click static-name href \"#reference-by-name\"\n  click dynamic href \"#dynamic-data\"\n\n  classDef clickable color:#4051b5;</code></pre> Static vs. dynamic data comparison <p>This table gives a full comparison between static and dynamic data. Do not worry if you do not yet understand everything in it; it will become clearer after reading more about static data and dynamic data!</p> Static Dynamic Required Python type pandas DataFrame Function that returns a pandas DataFrame Can be supplied directly in <code>data_frame</code> argument of <code>figure</code> Yes No Can be referenced by name after adding to data manager Yes Yes Can be refreshed while dashboard is running No Yes Production-ready Yes Yes <p>If you have a Kedro project, you should use Vizro's integration with the Kedro Data Catalog to add <code>kedro_datasets.pandas</code> data to the Vizro data manager.</p> <p>Kedro Data Catalog as a data source registry</p> <p>Even if you do not have a Kedro project, you can still use a Kedro Data Catalog as a YAML registry of your dashboard's data sources. This separates configuration of your data sources from your app's code and is the recommended approach if you have many data sources or a complex project. Here is an example <code>catalog.yaml</code> file:</p> <pre><code>motorbikes:\n  type: pandas.CSVDataset\n  filepath: s3://your_bucket/data/motorbikes.csv\n  load_args:\n    sep: ','\n    na_values: [NA]\n  credentials: s3_credentials\n</code></pre>","path":["How to connect your dashboard to data"],"tags":[]},{"location":"user-guides/data/#static-data","level":2,"title":"Static data","text":"<p>A static data source is the simplest way to send data to your dashboard and should be used for any data that does not need to be reloaded while the dashboard is running. It is production-ready and works out of the box in a multi-process deployment. If you need data to be refreshed without restarting the dashboard then you should instead use dynamic data.</p>","path":["How to connect your dashboard to data"],"tags":[]},{"location":"user-guides/data/#supply-directly","level":3,"title":"Supply directly","text":"<p>You can directly supply a pandas DataFrame into components such as graphs, tables, and figures.</p> <p>The below example uses the Iris data saved to a file <code>iris.csv</code> in the same directory as <code>app.py</code>. This data can be generated using <code>px.data.iris()</code> or downloaded.</p> <p>Static data supplied directly</p> app.pyResult <pre><code>from vizro import Vizro\nimport pandas as pd\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\niris = pd.read_csv(\"iris.csv\") # (1)!\n\npage = vm.Page(\n    title=\"Static data example\",\n    components=[\n        vm.Graph(figure=px.box(iris, x=\"species\", y=\"petal_width\", color=\"species\")),\n    ]\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li><code>iris</code> is a pandas DataFrame created by reading from the CSV file <code>iris.csv</code>.</li> </ol> <p></p> <p>The [<code>Graph</code>][vizro.models.Graph], [<code>AgGrid</code>][vizro.models.AgGrid] and [<code>Table</code>][vizro.models.Table] models all have an argument called <code>figure</code>. This accepts a function (in the above example, <code>px.scatter</code>) that takes a pandas DataFrame as its first argument. The name of this argument is always <code>data_frame</code>. When configuring the dashboard using Python, it is optional to give the name of the argument: if you like, you could write <code>data_frame=iris</code> instead of <code>iris</code>.</p> <p>Note</p> <p>With static data, once the dashboard is running, the data shown in the dashboard cannot change even if the source data in <code>iris.csv</code> changes. The code <code>iris = pd.read_csv(\"iris.csv\")</code> is only executed once when the dashboard is first started. If you would like changes to source data to flow through to the dashboard then you must use dynamic data.</p>","path":["How to connect your dashboard to data"],"tags":[]},{"location":"user-guides/data/#reference-by-name","level":3,"title":"Reference by name","text":"<p>If you would like to specify your dashboard configuration through YAML then you must first add your data to the data manager, importable as <code>vizro.managers.data_manager</code>. The value of the <code>data_frame</code> argument in the YAML configuration should then refer to the name of your data in the data manager.</p> <p>Static data referenced by name</p> app.pydashboard.yamlResult <pre><code>import yaml\n\nfrom vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\nimport pandas as pd\nfrom vizro.managers import data_manager\n\ndata_manager[\"iris\"] = pd.read_csv(\"iris.csv\") # (1)!\n\ndashboard = yaml.safe_load(Path(\"dashboard.yaml\").read_text(encoding=\"utf-8\"))\ndashboard = Dashboard(**dashboard)\n\nVizro().build(dashboard).run()\n</code></pre> <ol> <li><code>\"iris\"</code> is the name of a data source added to the data manager. This data is a pandas DataFrame created by reading from the CSV file <code>iris.csv</code>.</li> </ol> <pre><code>pages:\n  - components:\n      figure:\n        _target_: box\n        data_frame: iris # (1)!\n        x: species\n        y: petal_width\n        color: species\n      type: graph\n      title: Static data example\n</code></pre> <ol> <li>Refer to the <code>\"iris\"</code> data source in the data manager.</li> </ol> <p></p> <p>It is also possible to refer to a named data source using the Python API: <code>px.scatter(\"iris\", ...)</code> or <code>px.scatter(data_frame=\"iris\", ...)</code> would work if the <code>\"iris\"</code> data source has been registered in the data manager.</p>","path":["How to connect your dashboard to data"],"tags":[]},{"location":"user-guides/data/#dynamic-data","level":2,"title":"Dynamic data","text":"<p>A dynamic data source is a Python function that returns a pandas DataFrame. This function is executed when the dashboard is initially started and can be executed again while the dashboard is running. This makes it possible to refresh the data shown in your dashboard without restarting the dashboard itself. If you do not require this functionality then you should use static data instead.</p> <p>Unlike static data, dynamic data cannot be supplied directly into the <code>data_frame</code> argument of a <code>figure</code>. Instead, it must first be added to the data manager and then referenced by name.</p> <p>The example below shows how data is fetched dynamically every time the page is refreshed. When you run the code and refresh the page the function <code>load_iris_data</code> is re-run, which returns different data each time. The example uses the Iris data saved to a file <code>iris.csv</code> in the same directory as <code>app.py</code>. This data can be generated using <code>px.data.iris()</code> or downloaded.</p> <p>Dynamic data</p> app.pyResult <pre><code>from vizro import Vizro\nimport pandas as pd\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\nfrom vizro.managers import data_manager\n\ndef load_iris_data():\n    iris = pd.read_csv(\"iris.csv\") # (1)!\n    return iris.sample(50) # (2)!\n\ndata_manager[\"iris\"] = load_iris_data # (3)!\n\npage = vm.Page(\n    title=\"Update the chart on page refresh\",\n    components=[\n        vm.Graph(figure=px.box(\"iris\", x=\"species\", y=\"petal_width\", color=\"species\")) # (4)!\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li><code>iris</code> is a pandas DataFrame created by reading from the CSV file <code>iris.csv</code>.</li> <li>To demonstrate that dynamic data can change when the page is refreshed, select 50 points at random. This simulates what would happen if your file <code>iris.csv</code> were constantly changing.</li> <li>To use <code>load_iris_data</code> as dynamic data it must be added to the data manager. You should not actually call the function as <code>load_iris_data()</code>; doing so would result in static data that cannot be reloaded.</li> <li>Dynamic data is referenced by the name of the data source <code>\"iris\"</code>.</li> </ol> <p></p> <p>Since dynamic data sources must always be added to the data manager and referenced by name, they may be used in YAML configuration exactly the same way as for static data sources.</p>","path":["How to connect your dashboard to data"],"tags":[]},{"location":"user-guides/data/#configure-cache","level":3,"title":"Configure cache","text":"<p>By default, a dynamic data function executes every time the dashboard is refreshed. Data loading is batched so that a dynamic data function that supplies multiple graphs on the same page only executes once per page refresh. Even with this batching, if loading your data is a slow operation, your dashboard performance may suffer.</p> <p>The Vizro data manager has a server-side caching mechanism to help solve this. Vizro's cache uses Flask-Caching, which supports a number of possible cache backends and configuration options. By default, the cache is turned off.</p> <p>In a development environment the easiest way to enable caching is to use a simple memory cache with the default configuration options. This is achieved by adding one line to the above example to set <code>data_manager.cache</code>:</p> <p>Simple cache with default timeout of 5 minutes</p> <pre><code>from flask_caching import Cache\nfrom vizro import Vizro\nimport pandas as pd\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\nfrom vizro.managers import data_manager\n\ndef load_iris_data():\n    iris = pd.read_csv(\"iris.csv\")\n    return iris.sample(50)\n\ndata_manager.cache = Cache(config={\"CACHE_TYPE\": \"SimpleCache\"})\ndata_manager[\"iris\"] = load_iris_data\n\npage = vm.Page(\n    title=\"Update the chart on page refresh\",\n    components=[\n        vm.Graph(figure=px.box(\"iris\", x=\"species\", y=\"petal_width\", color=\"species\"))\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <p>By default, when caching is turned on, dynamic data is cached in the data manager for 5 minutes. A refresh of the dashboard within this time interval will fetch the pandas DataFrame from the cache and not re-run the data loading function. Once the cache timeout period has elapsed, the next refresh of the dashboard will re-execute the dynamic data loading function. The resulting pandas DataFrame will again be put into the cache and not expire until another 5 minutes has elapsed.</p> <p>If you would like to alter some options, such as the default cache timeout, then you can specify a different cache configuration:</p> Simple cache with timeout set to 10 minutes<pre><code>data_manager.cache = Cache(config={\"CACHE_TYPE\": \"SimpleCache\", \"CACHE_DEFAULT_TIMEOUT\": 600})\n</code></pre> <p>Warning</p> <p>Simple cache exists purely for single-process development purposes and is not intended to be used in production. If you deploy with multiple workers, for example with Gunicorn, then you should use a production-ready cache backend. All of Flask-Caching's built-in backends other than <code>SimpleCache</code> are suitable for production. In particular, you might like to use <code>FileSystemCache</code> or <code>RedisCache</code>:</p> Production-ready caches<pre><code># Store cached data in CACHE_DIR\ndata_manager.cache = Cache(config={\"CACHE_TYPE\": \"FileSystemCache\", \"CACHE_DIR\": \"cache\"})\n\n# Use Redis key-value store\ndata_manager.cache = Cache(config={\"CACHE_TYPE\": \"RedisCache\", \"CACHE_REDIS_HOST\": \"localhost\", \"CACHE_REDIS_PORT\": 6379})\n</code></pre> <p>Since Flask-Caching relies on <code>pickle</code>, which can execute arbitrary code during unpickling, you should not cache data from untrusted sources. Doing so could be unsafe.</p> <p>Note that when a production-ready cache backend is used, the cache is persisted beyond the Vizro process and is not cleared by restarting your server. To clear the cache then you must do so manually, for example, if you use <code>FileSystemCache</code> then you would delete your <code>cache</code> directory. Persisting the cache can also be useful for development purposes when handling data that takes a long time to load: even if you do not need the data to refresh while your dashboard is running, it can speed up your development loop to use dynamic data with a cache that is persisted between repeated runs of Vizro.</p>","path":["How to connect your dashboard to data"],"tags":[]},{"location":"user-guides/data/#set-timeouts","level":4,"title":"Set timeouts","text":"<p>You can change the timeout of the cache independently for each dynamic data source in the data manager using the <code>timeout</code> setting (measured in seconds). A <code>timeout</code> of 0 indicates that the cache does not expire. This is effectively the same as using static data.</p> Set the cache timeout for each dynamic data source<pre><code>from vizro.managers import data_manager\nfrom flask_caching import Cache\n\ndata_manager.cache = Cache(config={\"CACHE_TYPE\": \"SimpleCache\", \"CACHE_DEFAULT_TIMEOUT\": 600})\n\n# Cache of default_expire_data expires every 10 minutes, the default set by CACHE_DEFAULT_TIMEOUT\ndata_manager[\"default_expire_data\"] = load_iris_data\n\n# Set cache of fast_expire_data to expire every 10 seconds\ndata_manager[\"fast_expire_data\"] = load_iris_data\ndata_manager[\"fast_expire_data\"].timeout = 10\n\n# Set cache of slow_expire_data to expires every hour\ndata_manager[\"slow_expire_data\"] = load_iris_data\ndata_manager[\"slow_expire_data\"].timeout = 60 * 60\n\n# Set cache of no_expire_data to never expire\ndata_manager[\"no_expire_data\"] = load_iris_data\ndata_manager[\"no_expire_data\"].timeout = 0\n</code></pre>","path":["How to connect your dashboard to data"],"tags":[]},{"location":"user-guides/data/#parametrize-data-loading","level":3,"title":"Parametrize data loading","text":"<p>You can give arguments to your dynamic data loading function that can be modified from the dashboard. For example:</p> <ul> <li>To load different versions of the same data.</li> <li>To handle large datasets you can use an argument that controls the amount of data that is loaded. This effectively pre-filters data before it reaches the Vizro dashboard.</li> </ul> <p>In general, a parametrized dynamic data source should always return a pandas DataFrame with a fixed schema (column names and types). This ensures that page components and controls continue to work as expected when the parameter is changed on screen.</p> <p>To add a parameter to control a dynamic data source, do the following:</p> <ol> <li>add the appropriate argument to your dynamic data function and specify a default value for the argument.</li> <li>give an <code>id</code> to all components that have the data source you wish to alter through a parameter.</li> <li>add a parameter with <code>targets</code> of the form <code>&lt;target_component_id&gt;.data_frame.&lt;dynamic_data_argument&gt;</code> and a suitable selector.</li> </ol> <p>For example, let us extend the dynamic data example above into an example of how parametrized dynamic data works. The <code>load_iris_data</code> can take an argument <code>number_of_points</code> controlled from the dashboard with a [<code>Slider</code>][vizro.models.Slider].</p> <p>Parametrized dynamic data</p> app.pyResult <pre><code>from vizro import Vizro\nimport pandas as pd\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\nfrom vizro.managers import data_manager\n\ndef load_iris_data(number_of_points=10): # (1)!\n    iris = pd.read_csv(\"iris.csv\") # (2)!\n    return iris.sample(number_of_points) # (3)!\n\ndata_manager[\"iris\"] = load_iris_data # (4)!\n\npage = vm.Page(\n    title=\"Update the chart on page refresh\",\n    components=[\n        vm.Graph(id=\"graph\", figure=px.box(\"iris\", x=\"species\", y=\"petal_width\", color=\"species\")) # (5)!\n    ],\n    controls=[\n        vm.Parameter(\n            targets=[\"graph.data_frame.number_of_points\"], # (6)!\n            selector=vm.Slider(min=10, max=100, step=10, value=10),\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li><code>load_iris_data</code> takes a single argument, <code>number_of_points</code>, with a default value of 10.</li> <li><code>iris</code> is a pandas DataFrame created by reading from the CSV file <code>iris.csv</code>.</li> <li>Sample points at random, where <code>number_of_points</code> gives the number of points selected.</li> <li>To use <code>load_iris_data</code> as dynamic data it must be added to the data manager. You should not actually call the function as <code>load_iris_data()</code> or <code>load_iris_data(number_of_points=...)</code>; doing so would result in static data that cannot be reloaded.</li> <li>Give the <code>vm.Graph</code> component <code>id=\"graph\"</code> so that the <code>vm.Parameter</code> can target it. Dynamic data is referenced by the name of the data source <code>\"iris\"</code>.</li> <li>Create a <code>vm.Parameter</code> to target the <code>number_of_points</code> argument for the <code>data_frame</code> used in <code>graph</code>.</li> </ol> <p></p> <p>Parametrized data loading is compatible with caching. The cache uses memoization, so that the dynamic data function's arguments are included in the cache key. This means that <code>load_iris_data(number_of_points=10)</code> is cached independently of <code>load_iris_data(number_of_points=20)</code>.</p> <p>Warning</p> <p>You should always treat the content of user input as untrusted. For example, you should not expose a filepath to load without passing it through a function like <code>werkzeug.utils.secure_filename</code>, or you might enable arbitrary access to files on your server.</p> <p>You cannot pass nested parameters to dynamic data. You can only target the top-level arguments of the data loading function, not the nested keys in a dictionary.</p>","path":["How to connect your dashboard to data"],"tags":[]},{"location":"user-guides/data/#filters","level":3,"title":"Filters","text":"<p>When a filter depends on dynamic data and no <code>selector</code> is explicitly defined in the <code>vm.Filter</code> model, it is called a dynamic filter. A dynamic filter always reflects the latest data since the available selector values update either when the page refreshes or when a relevant dynamic data parameter changes.</p> <p>The mechanism behind updating dynamic filters works exactly like other non-control components such as <code>vm.Graph</code>. However, unlike such components, a filter can depend on multiple data sources. If at least one data source of the components in the filter's <code>targets</code> is dynamic then the filter is dynamic. Remember that when <code>targets</code> is not explicitly specified, a filter applies to all the components on a page that use a DataFrame including <code>column</code>.</p> <p>A dynamic filter behaves as follows when updated:</p> <ul> <li>The filter's selector updates its available values:<ul> <li>For categorical selectors, <code>options</code> updates to give all unique values found in <code>column</code> across all the data sources of components in <code>targets</code>.</li> <li>For numerical selectors and temporal selectors, <code>min</code> and <code>max</code> update to give the overall minimum and maximum values found in <code>column</code> across all the data sources of components in <code>targets</code>.</li> </ul> </li> <li>The value selected on screen by a dashboard user does not change. If the selected value is not already present in the new set of available values then the <code>options</code> or <code>min</code> and <code>max</code> are modified to include it. In this case, the filtering operation might result in an empty DataFrame.</li> <li>Even though the values present in a data source can change, the schema should not: <code>column</code> should remain present and of the same type in the data sources. The <code>targets</code> of the filter and selector type cannot change while the dashboard is running. For example, a <code>vm.Dropdown</code> selector cannot turn into <code>vm.RadioItems</code>.</li> </ul> <p>For example, let us extend the parametrized dynamic data example above with a filter. When you run the code and refresh the page, the filter and Graph update automatically. The same happens when the dynamic data parameter [<code>Slider</code>][vizro.models.Slider] changes, ensuring the latest data is always reflected.</p> <p>Dynamic filters</p> app.pyResult <pre><code>from vizro import Vizro\nimport pandas as pd\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\nfrom vizro.managers import data_manager\n\ndef load_iris_data(number_of_points=10):\n    iris = pd.read_csv(\"iris.csv\")\n    return iris.sample(number_of_points)\n\ndata_manager[\"iris\"] = load_iris_data\n\npage = vm.Page(\n    title=\"Update the chart on page refresh or when the Parameter changes\",\n    components=[\n        vm.Graph(id=\"graph\", figure=px.box(\"iris\", x=\"species\", y=\"petal_width\", color=\"species\"))\n    ],\n    controls=[\n        vm.Filter(column=\"species\", selector=vm.RadioItems()),  # (1)!\n        vm.Parameter(\n            targets=[\"graph.data_frame.number_of_points\"],\n            selector=vm.Slider(min=1, max=10, step=1, value=1),\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>This filter implicitly controls the dynamic data source <code>\"iris\"</code>, which supplies the <code>data_frame</code> to the targeted <code>vm.Graph</code>. On page refresh or when the dynamic data parameter changes, Vizro reloads this data, finds all the unique values in the <code>\"species\"</code> column and sets the categorical selector's <code>options</code> accordingly. We set <code>selector=vm.RadioItems()</code> just to make the <code>options</code> more obvious in the example app; if <code>selector</code> had not been specified then the filter would have defaulted to using <code>vm.Dropdown</code> but options would refresh exactly the same way.</li> </ol> <p></p> <p>Consider a filter that depends on dynamic data, where you do not want the available values to change when the dynamic data changes. You should manually specify the <code>selector</code>'s <code>options</code> field (categorical selector) or <code>min</code> and <code>max</code> fields (numerical and temporal selector). In the above example, this could be achieved as follows:</p> Override selector options to make a dynamic filter static<pre><code>controls = [\n    vm.Filter(column=\"species\", selector=vm.Dropdown(options=[\"setosa\", \"versicolor\", \"virginica\"])),\n    vm.Filter(column=\"sepal_length\", selector=vm.RangeSlider(min=4.3, max=7.9)),\n    vm.Filter(column=\"date_column\", selector=vm.DatePickerRange(min=\"2025-01-01\", max=\"2025-05-29\")),\n]\n</code></pre> <p>If you use a specific selector for a dynamic filter without manually specifying <code>options</code> (categorical selector) or <code>min</code> and <code>max</code> (numerical and temporal selector) then the selector remains dynamic. For example:</p> Dynamic filter with specific selector is still dynamic<pre><code>controls = [\n    vm.Filter(column=\"species\", selector=vm.Checklist()),\n    vm.Filter(column=\"sepal_length\", selector=vm.Slider()),\n    vm.Filter(column=\"date_column\", selector=vm.DatePicker(range=False)),\n]\n</code></pre> <p>When Vizro initially builds a filter that depends on parametrized dynamic data loading, data is loaded using the default argument values. This data is used to:</p> <ul> <li>perform initial validation</li> <li>check which data sources contain the specified <code>column</code> (unless <code>targets</code> is explicitly specified) and</li> <li>find the type of selector to use (unless <code>selector</code> is explicitly specified).</li> </ul>","path":["How to connect your dashboard to data"],"tags":[]},{"location":"user-guides/extensions/","level":1,"title":"How to extend and customize Vizro dashboards","text":"<p>At its simplest, Vizro enables low-code configuration, but you can also customize it to go beyond its default capabilities by incorporating any Dash component, Dash callback, or Plotly chart.</p> <ul> <li> <p>Vizro customizations. You can customize Vizro to extend the default functionality of Vizro and create Python functions as customized Plotly charts, tables, dashboard components, actions, or reactive HTML components, and then plug them directly into the existing Vizro dashboard configuration (as explained below).</p> </li> <li> <p>Dash customizations. You can add custom Dash callbacks directly to any Vizro dashboard, enabling you to code beneath the Vizro layer and control Dash directly.</p> </li> <li> <p>CSS customizations. You can add custom CSS to any Vizro dashboard, enabling users to deviate from the default styling and create a unique look and feel for their dashboard.</p> </li> <li> <p>React.js customizations. You can add custom React.js components directly to any Vizro dashboard, enabling users to go beneath both the Vizro and Dash layers and control React.js directly</p> </li> </ul> <p>Vizro offers the ability to combine ease of use of low-code configuration, with the flexibility of a range of high-code extensions to expand your dashboard's functionality.</p>","path":["How to extend and customize Vizro dashboards"],"tags":[]},{"location":"user-guides/extensions/#vizro-customizations","level":2,"title":"Vizro customizations","text":"","path":["How to extend and customize Vizro dashboards"],"tags":[]},{"location":"user-guides/extensions/#custom-charts","level":3,"title":"Custom charts","text":"<p>You can create custom chart functions in Vizro by wrapping Plotly chart code inside a Vizro chart function wrapper, and then use the functions directly inside the Vizro dashboard configuration. This enables the creation of <code>plotly.graph_objects</code> charts with multiple traces, or <code>plotly_express</code> charts with post update customizations</p>","path":["How to extend and customize Vizro dashboards"],"tags":[]},{"location":"user-guides/extensions/#custom-tables","level":3,"title":"Custom tables","text":"<p>If the available arguments for the [<code>dash_ag_grid</code>][vizro.tables.dash_ag_grid] or [<code>dash_data_table</code>][vizro.tables.dash_data_table] models are insufficient, you can create a custom Dash AG Grid or Dash DataTable.</p>","path":["How to extend and customize Vizro dashboards"],"tags":[]},{"location":"user-guides/extensions/#custom-components","level":3,"title":"Custom components","text":"<p>You can create a custom component based on any dash-compatible component (for example, dash-core-components, dash-bootstrap-components, dash-html-components).</p> <p>All Vizro's components are based on <code>Dash</code> and ship with a set of defaults that can be modified. If you would like to overwrite one of those defaults, or if you would like to use extra <code>args</code> or <code>kwargs</code> of those components, then this is the correct way to include those. You can use any existing attribute of any underlying Dash component with this method.</p>","path":["How to extend and customize Vizro dashboards"],"tags":[]},{"location":"user-guides/extensions/#custom-actions","level":3,"title":"Custom actions","text":"<p>If you want to perform functions that are not available in the built-in action functions, you can create your own custom actions.</p>","path":["How to extend and customize Vizro dashboards"],"tags":[]},{"location":"user-guides/extensions/#custom-figures","level":3,"title":"Custom figures","text":"<p>Custom figures are useful when you need a component that reacts to filter and parameter controls.</p> <p>Vizro's [<code>Figure</code>][vizro.models.Figure] model accepts the <code>figure</code> argument, where you can enter any custom figure function as described in the how-to guide for figures.</p>","path":["How to extend and customize Vizro dashboards"],"tags":[]},{"location":"user-guides/extensions/#use-custom-functions-in-yamljson-configuration","level":3,"title":"Use custom functions in <code>yaml</code>/<code>json</code> configuration","text":"<p>Exposing configuration to untrusted users</p> <p>Exposing Vizro configuration to untrusted users may pose a security risk. A user with access to YAML/JSON configuration can potentially execute arbitrary Python code when the dashboard is run. The security of your <code>yaml</code>/<code>json</code> configuration should be regarded as equivalent to the security of your <code>app.py</code> file.</p> <p>It is possible to refer to custom functions that are used as <code>CapturedCallable</code> by their import path in a <code>yaml</code>/<code>json</code> configuration of the dashboard.</p> <p>In the above guides, you will find examples on how the Vizro schema can be extended by using custom Python code. It is possible to refer to these custom functions in the <code>yaml</code>/<code>json</code> configuration by using the <code>_target_</code> key and the correct import path.</p> <p>Custom charts with YAML config example</p> app.pydashboard.yamlcustom_charts.py <pre><code>from pathlib import Path\n\nimport vizro.plotly.express as px\nimport yaml\nfrom vizro import Vizro\nfrom vizro.managers import data_manager\nfrom vizro.models import Dashboard\n\ndata_manager[\"iris\"] = px.data.iris()\n\ndashboard = yaml.safe_load(Path(\"dashboard.yaml\").read_text(encoding=\"utf-8\"))  # (1)!\ndashboard = Dashboard(**dashboard)\n\nif __name__ == \"__main__\":\n    Vizro().build(dashboard).run()\n</code></pre> <ol> <li>Parse the YAML or JSON configuration that lies in a separate file.</li> </ol> <pre><code>pages:\n  - components:\n      - figure:\n          _target_: custom_charts.custom_bar    # (1)!\n          data_frame: iris\n          x: sepal_length\n          y: sepal_width\n        type: graph\n    title: Custom Bar Chart\n</code></pre> <ol> <li>Here we refer to the import path of the custom chart function. If you define the custom chart in <code>app.py</code>, then use <code>__main__</code> as the import path. Note that the import path will be interpreted by pydantics <code>ImportString</code> type.</li> </ol> <pre><code>import pandas as pd\nimport plotly.graph_objects as go\nfrom vizro.models.types import capture\n\n\n@capture(\"graph\")\ndef custom_bar(data_frame: pd.DataFrame, x: str, y: str) -&gt; go.Figure:  # (1)!\n    \"\"\"Custom bar chart.\"\"\"\n    return go.Figure(data=[go.Bar(x=data_frame[x], y=data_frame[y])])\n</code></pre> <ol> <li>Definition of the custom chart function as usual.</li> </ol>","path":["How to extend and customize Vizro dashboards"],"tags":[]},{"location":"user-guides/extensions/#validate-dashboards-without-defining-capturedcallable-functions","level":4,"title":"Validate dashboards without defining <code>CapturedCallable</code> functions","text":"<p>It is possible to validate a dashboard configuration without importing or executing some <code>CapturedCallable</code> functions.</p> <p>You can use this method when you want to check if the dashboard configuration is valid, but you don't want to import or execute the custom functions until run-time, which may be in a sandboxed environment. This is useful when the custom functions are not available at validation time, or when they originate from untrusted sources (e.g. when a large language model is used to generate that code).</p> <p>Note</p> <p>If you validate your dashboard configuration with a <code>CapturedCallable</code> function that is undefined, you will not be able to start the server. Hence when running the dashboard, you will need to recreate a dashboard object with all the <code>CapturedCallable</code> functions defined.</p> <p>Validating dashboards without executing <code>CapturedCallable</code> functions</p> <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.managers import data_manager\n\ndata_manager[\"iris\"] = px.data.iris()\n\ndashboard_config = {\n    \"title\": \"Test dashboard\",\n    \"pages\": [\n        {\n            \"title\": \"Page 1\",\n            \"components\": [\n                {\n                    \"type\": \"ag_grid\",\n                    \"figure\": {\"_target_\": \"llm_generated_grid\", \"data_frame\": \"iris\"},\n                },\n            ],\n        }\n    ],\n}\n\ndashboard = vm.Dashboard.model_validate(\n    dashboard_config,\n    context={\n        \"allow_undefined_captured_callable\": [\n            \"llm_generated_grid\",\n        ]\n    },\n)\napp = Vizro().build(dashboard)  # (1)!\ntry:\n    app.run()  # (2)!\nexcept ValueError as exc:\n    print(exc)\n</code></pre> <ol> <li>The dashboard configuration contains a <code>CapturedCallable</code> function that is undefined but allowed by <code>allow_undefined_captured_callable</code>. The app can still be built without raising any errors.</li> <li>However, it is not possible to run the app without undefined <code>CapturedCallable</code>s. This raises an error.</li> </ol>","path":["How to extend and customize Vizro dashboards"],"tags":[]},{"location":"user-guides/extensions/#dash-customizations","level":2,"title":"Dash customizations","text":"<p>Since Vizro is built using Dash, it is possible to use Dash callbacks directly in any Vizro dashboard. This enables you to code beneath the Vizro layer and control Dash directly, which is especially useful when working with callbacks</p> <p>Here is an example showing a Dash callback within Vizro, enabling an interaction between data points in a scatter plot and the content of a text card:</p> <p>Dash callback example</p> app.py <pre><code>from dash import callback, Input, Output\nimport vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\n@callback(\n    Output(\"card_id\", \"children\"),\n    Input(\"source_chart\", \"clickData\")\n)\ndef update_card(click_data):\n    if click_data is None:\n        return \"Click on the graph to select a data point.\"\n    return f\"Clicked species: '{click_data['points'][0]['customdata'][0]}'\"\n\npage = vm.Page(\n    title=\"Example: Dash callback within Vizro\",\n    components=[\n        vm.Graph(id=\"source_chart\",\n                 figure=px.scatter(px.data.iris(), x=\"sepal_width\", y=\"sepal_length\", color=\"species\", custom_data=\"species\")),\n        vm.Card(id=\"card_id\",\n                text=\"Click on the graph to apply filter interaction.\"),\n    ]\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre>","path":["How to extend and customize Vizro dashboards"],"tags":[]},{"location":"user-guides/extensions/#css-customizations","level":2,"title":"CSS customizations","text":"<p>Vizro is opinionated about visual formatting, and some elements, such as the layout of the navigation and controls, are fixed. You can customize some settings such as background colors, fonts, and other styles via CSS overrides.</p> <p>For more information, see our documentation on customizing CSS</p>","path":["How to extend and customize Vizro dashboards"],"tags":[]},{"location":"user-guides/extensions/#reactjs-customizations","level":2,"title":"React.js customizations","text":"<p>It is possible to create custom React.js components and add them directly to any Vizro dashboard so enabling you to code beneath both the Vizro and Dash layers and control React.js directly</p> <p>For more information, see the documentation on using React.js components with Dash</p>","path":["How to extend and customize Vizro dashboards"],"tags":[]},{"location":"user-guides/figure/","level":1,"title":"How to use figures","text":"<p>This guide shows you how to add any Dash component that needs to be reactive to controls such as filters and parameters. If you want to add a static Dash component to your page, use custom components instead.</p> <p>[<code>Figure</code>][vizro.models.Figure] provides a flexible foundation for all types of reactive Dash components in Vizro. The [<code>Graph</code>][vizro.models.Graph], [<code>Table</code>][vizro.models.Table] and [<code>AgGrid</code>][vizro.models.AgGrid] models are specific implementations of <code>Figure</code>. They serve as intuitive shortcuts, embedding behaviors and interactions specific to their purposes.</p> <p>If these more specific models already achieve what you need then they should be used in preference to the more generic <code>Figure</code>. Remember that it is possible to supply custom charts to <code>Graph</code> and custom tables to <code>Table</code>.</p> <p>There are already a few figure functions you can reuse, see the section on KPI cards for more details:</p> <ul> <li>[<code>kpi_card</code>][vizro.figures.kpi_card]</li> <li>[<code>kpi_card_reference</code>][vizro.figures.kpi_card_reference]</li> </ul> <p>The following flowchart shows what you need to consider when choosing which model to use:</p> <pre><code>graph TD\n  first[\"`Does your desired component exist in Vizro, e.g. Graph, Table or AgGrid?`\"]\n  specific-component([Use the specific component])\n  second[\"`Does your component need to be reactive to controls?`\"]\n  second-static([Use custom components])\n  second-reactive([Use Figure])\n\n  first -- Yes --&gt; specific-component\n  first -- No --&gt; second\n  second -- No --&gt; second-static\n  second -- Yes --&gt; second-reactive\n\n  click specific-component href \"../components/\"\n  click second-static href \"../custom-components/\"\n  click second-reactive href \"#how-to-use-figures\"\n\n  classDef clickable color:#4051b5;</code></pre> <p>To add a <code>Figure</code> to your page:</p> <ol> <li>Add the <code>Figure</code> model to the components argument of the [Page][vizro.models.Page] model.</li> <li>Use an existing figure function from <code>vizro.figures</code> and pass it to the <code>figure</code> argument of the <code>Figure</code> model.</li> </ol> <p>Use existing figure functions</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.figures import kpi_card  # (1)!\n\ntips = px.data.tips()\n\npage = vm.Page(\n    title=\"KPI card\",\n    layout=vm.Flex(direction=\"row\"),  # (2)!\n    components=[\n        vm.Figure(\n            figure=kpi_card(\n                data_frame=tips,\n                value_column=\"tip\",\n                value_format=\"${value:.2f}\",\n                icon=\"Shopping Cart\",\n                title=\"Average Price\",\n            )\n        )\n    ],\n    controls=[vm.Filter(column=\"day\", selector=vm.RadioItems())],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>For more information, refer to the API reference for [<code>kpi_card</code>][vizro.figures.kpi_card].</li> <li>We switch to a <code>Flex</code> layout so that the KPI card only takes up as much space as it needs.</li> </ol> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: kpi_card\n          data_frame: tips\n          value_column: tip\n          value_format: ${value:.2f}\n          icon: Shopping Cart\n          title: Average Price\n        type: figure\n    controls:\n      - column: day\n        type: filter\n        selector:\n          type: radio_items\n    layout:\n      direction: row\n      type: flex\n    title: KPI card\n</code></pre> <p></p>","path":["How to use figures"],"tags":[]},{"location":"user-guides/figure/#key-performance-indicator-kpi-cards","level":3,"title":"Key Performance Indicator (KPI) cards","text":"<p>A KPI card is a dynamic card that can display a single value, but optionally, can also include a title, icon, and reference value. It is a common visual component to display key metrics in a dashboard. Vizro comes with two built-in KPI card functions:</p> <ul> <li> <p><code>kpi_card</code>: A KPI card that shows a single value found by performing an aggregation function (by default, <code>sum</code>) over a specified column. Required arguments are <code>data_frame</code> and <code>value_column</code>.</p> </li> <li> <p><code>kpi_card_with_reference</code>: A KPI card that shows a single value and a delta comparison to a reference value found by performing an aggregation function (by default, <code>sum</code>) over the specified columns. Required arguments are <code>data_frame</code>, <code>value_column</code> and <code>reference_column</code>.</p> </li> </ul> <p>As described in the API reference and illustrated in the below example, these functions have several arguments to customize your KPI cards. If you require a level of customization that cannot be done with the built-in functions then you can create a custom figure.</p> <p>KPI card variations</p> my_css_file.cssapp.pyapp.yamlResult <pre><code>/* We define a fixed height and width to ensure uniform styling for all KPI cards. */\n.flex-item .card-kpi {\n    width: 300px;\n    height: 150px;\n}\n</code></pre> <pre><code>import pandas as pd\nimport vizro.models as vm\nfrom vizro import Vizro\nfrom vizro.figures import kpi_card, kpi_card_reference  # (1)!\n\ndf_kpi = pd.DataFrame({\"Actual\": [100, 200, 700], \"Reference\": [100, 300, 500], \"Category\": [\"A\", \"B\", \"C\"]})\n\nexample_cards = [\n    kpi_card(data_frame=df_kpi, value_column=\"Actual\", title=\"KPI with value\"),\n    kpi_card(data_frame=df_kpi, value_column=\"Actual\", title=\"KPI with aggregation\", agg_func=\"median\"),\n    kpi_card(\n        data_frame=df_kpi,\n        value_column=\"Actual\",\n        title=\"KPI with formatting\",\n        value_format=\"${value:.2f}\",\n    ),\n    kpi_card(\n        data_frame=df_kpi,\n        value_column=\"Actual\",\n        title=\"KPI with icon\",\n        icon=\"Shopping Cart\",\n    ),\n]\n\nexample_reference_cards = [\n    kpi_card_reference(\n        data_frame=df_kpi,\n        value_column=\"Actual\",\n        reference_column=\"Reference\",\n        title=\"KPI reference (pos)\",\n    ),\n    kpi_card_reference(\n        data_frame=df_kpi,\n        value_column=\"Actual\",\n        reference_column=\"Reference\",\n        agg_func=\"median\",\n        title=\"KPI reference (neg)\",\n    ),\n    kpi_card_reference(\n        data_frame=df_kpi,\n        value_column=\"Actual\",\n        reference_column=\"Reference\",\n        title=\"KPI reference with formatting\",\n        value_format=\"{value:.2f}€\",\n        reference_format=\"{delta:+.2f}€ vs. last year ({reference:.2f}€)\",\n    ),\n    kpi_card_reference(\n        data_frame=df_kpi,\n        value_column=\"Actual\",\n        reference_column=\"Reference\",\n        title=\"KPI reference with icon\",\n        icon=\"Shopping Cart\",\n    ),\n    kpi_card_reference(\n        data_frame=df_kpi,\n        value_column=\"Actual\",\n        reference_column=\"Reference\",\n        title=\"KPI reference (reverse color)\",\n        reverse_color=True,\n    ),\n]\n\npage = vm.Page(\n    title=\"KPI cards\",\n    layout=vm.Flex(direction=\"row\", wrap=True),  # (2)!\n    components=[vm.Figure(figure=figure) for figure in example_cards + example_reference_cards],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>For more information, refer to the API reference for [<code>kpi_card</code>][vizro.figures.kpi_card] and [<code>kpi_card_reference</code>][vizro.figures.kpi_card_reference].</li> <li>We use a <code>Flex</code> layout with <code>direction=row</code> and <code>wrap=True</code> to allow KPI cards to wrap to the next line when needed.</li> </ol> <p>Run and edit this code in PyCafe</p> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: kpi_card\n          data_frame: df_kpi\n          value_column: Actual\n          title: KPI with value\n        type: figure\n      - figure:\n          _target_: kpi_card\n          data_frame: df_kpi\n          value_column: Actual\n          title: KPI with aggregation\n          agg_func: median\n        type: figure\n      - figure:\n          _target_: kpi_card\n          data_frame: df_kpi\n          value_column: Actual\n          title: KPI with formatting\n          value_format: ${value:.2f}\n        type: figure\n      - figure:\n          _target_: kpi_card\n          data_frame: df_kpi\n          value_column: Actual\n          title: KPI with icon\n          icon: Shopping Cart\n        type: figure\n      - figure:\n          _target_: kpi_card_reference\n          data_frame: df_kpi\n          value_column: Actual\n          reference_column: Reference\n          title: KPI reference (pos)\n        type: figure\n      - figure:\n          _target_: kpi_card_reference\n          data_frame: df_kpi\n          value_column: Actual\n          reference_column: Reference\n          agg_func: median\n          title: KPI reference (neg)\n        type: figure\n      - figure:\n          _target_: kpi_card_reference\n          data_frame: df_kpi\n          value_column: Actual\n          reference_column: Reference\n          title: KPI reference with formatting\n          value_format: '{value:.2f}€'\n          reference_format: '{delta:+.2f}€ vs. last year ({reference:.2f}€)'\n        type: figure\n      - figure:\n          _target_: kpi_card_reference\n          data_frame: df_kpi\n          value_column: Actual\n          reference_column: Reference\n          title: KPI reference with icon\n          icon: Shopping Cart\n        type: figure\n      - figure:\n          _target_: kpi_card_reference\n          data_frame: df_kpi\n          value_column: Actual\n          reference_column: Reference\n          title: KPI reference (reverse color)\n          reverse_color: true\n        type: figure\n    layout:\n      direction: row\n      wrap: true\n      type: flex\n    title: KPI cards\n</code></pre> <p></p>","path":["How to use figures"],"tags":[]},{"location":"user-guides/filters/","level":1,"title":"How to use filters","text":"<p>This guide shows you how to add filters to your dashboard. A filter selects a subset of rows of a component's data to alter the appearance of that component. The following components are reactive to filters:</p> <ul> <li>built-in graphs and custom graphs</li> <li>built-in tables and custom tables</li> <li>built-in figures and custom figures</li> </ul> <p>It is possible to add filters to a page or container. Both the [<code>Page</code> model][vizro.models.Page] and the [<code>Container</code> model][vizro.models.Container] have an optional <code>controls</code> argument where you can give any number of controls, including filters. A filter uses the [<code>Filter</code> model][vizro.models.Filter] to filter the <code>data_frame</code> of the <code>figure</code> function of a target component model such as [<code>Graph</code>][vizro.models.Graph].</p> <p>When the dashboard is running there are two ways for a user to set a filter:</p> <ul> <li>Direct user interaction with the underlying selector. For example, the user selects values from a checklist.</li> <li>User interaction with a graph or table via the [<code>set_control</code> action][vizro.actions.set_control]. This enables functionality such as cross-filtering. To achieve a visually cleaner dashboard you might like to hide the filter's underlying selector with <code>visible=False</code>.</li> </ul> <p>By default, filters that control components with dynamic data are dynamically updated when the underlying data changes while the dashboard is running.</p>","path":["How to use filters"],"tags":[]},{"location":"user-guides/filters/#basic-filters","level":2,"title":"Basic filters","text":"<p>To add a filter to your page, do the following:</p> <ol> <li>add the [<code>Filter</code>][vizro.models.Filter] model into the <code>controls</code> argument of the [<code>Page</code>][vizro.models.Page] model</li> <li>configure the <code>column</code> argument, which denotes the target column to be filtered</li> </ol> <p>You can also set <code>targets</code> to specify which components on the page the filter should apply to. If this is not explicitly set then <code>targets</code> defaults to all components on the page whose data source includes <code>column</code>.</p> <p>Basic Filter</p> app.pyapp.yamlResult <pre><code>from vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Graph(figure=px.scatter(iris, x=\"sepal_length\", y=\"petal_width\", color=\"species\")),\n    ],\n    controls=[\n        vm.Filter(column=\"species\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: scatter\n          data_frame: iris\n          x: sepal_length\n          y: petal_width\n          color: species\n        type: graph\n    controls:\n      - column: species\n        type: filter\n    title: My first page\n</code></pre> <p></p> <p>The selector is configured automatically based on the target column type data as follows:</p> <ul> <li>Categorical data uses [<code>vm.Dropdown(multi=True)</code>][vizro.models.Dropdown] where <code>options</code> is the set of unique values found in <code>column</code> across all the data sources of components in <code>targets</code>.</li> <li>Numerical data uses [<code>vm.RangeSlider</code>][vizro.models.RangeSlider] where <code>min</code> and <code>max</code> are the overall minimum and maximum values found in <code>column</code> across all the data sources of components in <code>targets</code>.</li> <li>Temporal data uses [<code>vm.DatePicker(range=True)</code>][vizro.models.DatePicker] where <code>min</code> and <code>max</code> are the overall minimum and maximum values found in <code>column</code> across all the data sources of components in <code>targets</code>. A column can be converted to this type with pandas.to_datetime.</li> <li>Boolean data uses [<code>vm.Switch</code>][vizro.models.Switch] which provides a toggle interface for True/False values. The Switch also works with binary numerical columns containing 0/1 values.</li> </ul> <p>The following example demonstrates these default selector types.</p> <p>Default Filter selectors</p> app.pyapp.yamlResult <pre><code>import pandas as pd\nfrom vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\ndf_stocks = px.data.stocks(datetimes=True)\n\ndf_stocks_long = pd.melt(\n    df_stocks,\n    id_vars='date',\n    value_vars=['GOOG', 'AAPL', 'AMZN', 'FB', 'NFLX', 'MSFT'],\n    var_name='stocks',\n    value_name='value'\n)\n\ndf_stocks_long['value'] = df_stocks_long['value'].round(3)\ndf_stocks_long['Is GOOG?'] = df_stocks_long[\"stocks\"] == \"GOOG\"\n\npage = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Graph(figure=px.line(df_stocks_long, x=\"date\", y=\"value\", color=\"stocks\")),\n    ],\n    controls=[\n        vm.Filter(column=\"stocks\"),\n        vm.Filter(column=\"value\"),\n        vm.Filter(column=\"date\"),\n        vm.Filter(column=\"Is GOOG?\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: line\n          data_frame: df_stocks_long\n          x: date\n          y: value\n          color: stocks\n        type: graph\n    controls:\n      - column: stocks\n        type: filter\n      - column: value\n        type: filter\n      - column: date\n        type: filter\n      - column: Is GOOG?\n        type: filter\n    title: My first page\n</code></pre> <p></p>","path":["How to use filters"],"tags":[]},{"location":"user-guides/filters/#change-selector","level":2,"title":"Change selector","text":"<p>If you want to have a different selector for your filter, you can give the <code>selector</code> argument of the [<code>Filter</code>][vizro.models.Filter] model a different selector model. Currently available selectors are [<code>Checklist</code>][vizro.models.Checklist], [<code>Dropdown</code>][vizro.models.Dropdown], [<code>RadioItems</code>][vizro.models.RadioItems], [<code>RangeSlider</code>][vizro.models.RangeSlider], [<code>Slider</code>][vizro.models.Slider], [<code>DatePicker</code>][vizro.models.DatePicker] and [<code>Switch</code>][vizro.models.Switch].</p> <p>You can explore and test all available selectors interactively on our feature demo dashboard.</p> <p>Filter with different selector</p> app.pyapp.yamlResult <pre><code>from vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Graph(figure=px.scatter(iris, x=\"sepal_length\", y=\"petal_width\")),\n    ],\n    controls=[\n        vm.Filter(column=\"species\", selector=vm.RadioItems()),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: scatter\n          data_frame: iris\n          x: sepal_length\n          y: petal_width\n        type: graph\n    controls:\n      - column: species\n        selector:\n          type: radio_items\n        type: filter\n    title: My first page\n</code></pre> <p></p>","path":["How to use filters"],"tags":[]},{"location":"user-guides/filters/#further-customization","level":2,"title":"Further customization","text":"<p>For further customizations, refer to the guide to selectors and the [<code>Filter</code> model][vizro.models.Filter]. Some popular choices are:</p> <ul> <li>Select which components the filter applies to by using <code>targets</code>.</li> <li>Customize the <code>selector</code>, for example <code>multi</code> to switch between a multi-option and single-option selector, <code>options</code> for a categorical filter or <code>min</code> and <code>max</code> for a numerical filter.</li> <li>Make the filter's selector invisible by setting <code>visible=False</code>.</li> </ul> <p>Below is an example where we only target one page component, and where we further customize the chosen <code>selector</code>.</p> <p>Customized Filter</p> app.pyapp.yamlResult <pre><code>from vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Graph(id=\"scatter_chart\", figure=px.scatter(iris, x=\"sepal_length\", y=\"petal_width\", color=\"species\")),\n        vm.Graph(figure=px.scatter(iris, x=\"petal_length\", y=\"sepal_width\", color=\"species\")),\n    ],\n    controls=[\n        vm.Filter(column=\"petal_length\",targets=[\"scatter_chart\"], selector=vm.RangeSlider(step=1)),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: scatter\n          data_frame: iris\n          x: sepal_length\n          y: petal_width\n          color: species\n        id: scatter_chart\n        type: graph\n      - figure:\n          _target_: scatter\n          data_frame: iris\n          x: petal_length\n          y: sepal_width\n          color: species\n        type: graph\n    controls:\n      - column: petal_length\n        targets:\n          - scatter_chart\n        selector:\n          step: 1\n          type: range_slider\n        type: filter\n    title: My first page\n</code></pre> <p></p>","path":["How to use filters"],"tags":[]},{"location":"user-guides/graph-table-actions/","level":1,"title":"Graph and table interactions","text":"<p>In this guide we show you how to configure interactions between graphs and tables, as is commonly done in business intelligence (BI) tools. In Vizro, all such interactions are enabled by an intermediate control that you must explicitly define. For example:</p> <ul> <li>Cross-filter: a source graph or table filters the <code>data_frame</code> of a target graph or table. The source component sets a filter, which in turn updates the target component.</li> <li>Cross-parameter: a source graph or table updates any argument other than <code>data_frame</code> of a target graph or table. The source component sets a parameter, which in turn updates the target component.</li> <li>Cross-highlight: a source graph or table highlights data in a target graph or table. This is an example of a cross-parameter.</li> </ul> <p>All these interactions use the [<code>set_control</code> action][vizro.actions.set_control]. This gives very generic and powerful functionality thanks to the functionality of the intermediate control:</p> <ul> <li>The target components can be anything that reacts to a control: built-in graphs, custom graphs, built-in tables, custom tables, built-in figures and custom figures.</li> <li>A single control can update any number of these target components, and a single source component can set any number of controls. Hence a single source component can interact with any number of target components.</li> <li>A target component can be on the same page as the source or on a different page (so long as the intermediate control has <code>show_in_url=True</code>).</li> <li>A target component can also be the source component to enable a \"self-interaction\".</li> <li>The value of a control is persisted when you change page.</li> <li>Interactions are not \"invisible\"; they are explicitly shown on the screen by the value of the control. Just like a normal control, you can change the value manually.</li> </ul> <p>Invisible controls</p> <p>If you prefer, you can make your control invisible by setting <code>visible=False</code>, for example <code>vm.Parameter(..., visible=False)</code>. The control can then only be set by <code>set_control</code>. This achieves a visually cleaner dashboard but can also make it less clear what graph and table interactions have been applied. We use <code>visible=False</code> in all our examples on cross-highlighting.</p> <p>A user can reset all controls on a page, including those with <code>visible=False</code>, by clicking the \"Reset controls\" button.</p>","path":["Graph and table interactions"],"tags":[]},{"location":"user-guides/graph-table-actions/#cross-filter","level":2,"title":"Cross-filter","text":"<p>A cross-filter is when the user clicks on one source graph or table to filter one or more target components. In Vizro, a cross-filter operates through an intermediate filter. To configure a cross-filter:</p> <ol> <li> <p>Create a filter that targets the graphs, tables or figures you would like to filter. The filter must have a categorical selector (both multi- and single-option are allowed).</p> <pre><code>import vizro.models as vm\n\ncontrols = [vm.Filter(id=\"my_filter\", column=\"species\")]  # (1)!\n</code></pre> <ol> <li>Remember that if <code>targets</code> is not explicitly specified, a filter targets all components on the page whose data source includes <code>column</code>.</li> </ol> </li> <li> <p>Call <code>set_control</code> in the <code>actions</code> argument of the source [<code>Graph</code>][vizro.models.Graph] or [<code>AgGrid</code>][vizro.models.AgGrid] component that triggers the cross-filter.</p> <ol> <li>Set <code>control</code> to the ID of the filter.</li> <li>Set <code>value</code>. The format of this depends on the source model and is given in the [API reference][vizro.actions.set_control], but it is often <code>column</code> of the filter. Think of it as an instruction for what to lookup in the source data: whatever value is fetched from this lookup is used to set <code>control</code>.</li> </ol> <pre><code>import vizro.actions as va\n\ncomponents = [vm.Graph(..., actions=va.set_control(control=\"my_filter\", value=\"species\"))]\n</code></pre> </li> <li> <p>If your source component is a <code>Graph</code> and you use a column name for <code>value</code> then this must be included in the <code>custom_data</code> of your graph's <code>figure</code> function, for example <code>figure=px.scatter(..., custom_data=\"species\")</code>.</p> </li> </ol> <p>Tip</p> <p>Often the <code>value</code> of <code>set_control</code> is the same as the <code>column</code> of the filter, but this does not need to be the case. You can perform a cross-filter where the source component's column name given by <code>value</code> is different from the target component's column name, which is given by the filter's <code>column</code>.</p>","path":["Graph and table interactions"],"tags":[]},{"location":"user-guides/graph-table-actions/#cross-filter-from-table","level":3,"title":"Cross-filter from table","text":"<p>The trigger for a cross-filter from an AG Grid is clicking on a row in the table. The <code>value</code> argument of the [<code>set_control</code> action][vizro.actions.set_control] specifies the column of the value that sets <code>control</code>.</p> <p>Cross-filter from table to graph</p> app.pyapp.yamlResult <pre><code>import vizro.actions as va\nimport vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\n\ntips = px.data.tips()\n\npage = vm.Page(\n    title=\"Cross-filter from table to graph\",\n    components=[\n        vm.AgGrid(\n            title=\"Click on a row to use that row's sex to filter graph\",\n            figure=dash_ag_grid(tips),\n            actions=va.set_control(control=\"sex_filter\", value=\"sex\"),\n        ),\n        vm.Graph(id=\"tips_graph\", figure=px.histogram(tips, x=\"tip\")),  # (1)!\n    ],\n    controls=[vm.Filter(id=\"sex_filter\", column=\"sex\", targets=[\"tips_graph\"])],  # (2)!\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We give the <code>vm.Graph</code> an <code>id</code> so that it can be targeted explicitly by <code>vm.Filter(id=\"sex_filter\")</code>.</li> <li>We give the <code>vm.Filter</code> an <code>id</code> so that it can be set explicitly by <code>va.set_control</code>.</li> </ol> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - actions:\n          - control: sex_filter\n            type: set_control\n            value: sex\n        figure:\n          _target_: dash_ag_grid\n          data_frame: tips\n        title: Click on a row to use that row's sex to filter graph\n        type: ag_grid\n      - figure:\n          _target_: histogram\n          data_frame: tips\n          x: tip\n        id: tips_graph\n        type: graph\n    controls:\n      - column: sex\n        id: sex_filter\n        targets:\n          - tips_graph\n        type: filter\n    title: Cross-filter from table to graph\n</code></pre> <p></p> <p>When you click on a row in the table, the graph is cross-filtered to show data only for one sex. The column of the clicked cell does not matter: the value is always taken from the <code>sex</code> column of the clicked row.</p> Behind the scenes mechanism <p>In full, what happens is as follows:</p> <ol> <li>Clicking on a row triggers the <code>va.set_control</code> action. This uses the value of the <code>sex</code> column for the selected row (in other words, \"Male\" or \"Female\") to set the selector underlying <code>vm.Filter(id=\"sex_filter\")</code>.</li> <li>The change in value of <code>vm.Filter(id=\"sex_filter\")</code> triggers the filter to be re-applied on its <code>targets=[\"tips_graph\"]</code> so that a filtered graph is shown.</li> </ol> <p>The mechanism for triggering the filter when its value is set by <code>va.set_control</code> is an implicit actions chain.</p> <p>Tip</p> <p>You can emphasize that a row is selectable by including checkboxes in your AG Grid with <code>figure=dash_ag_grid(..., dashGridOptions={\"rowSelection\": {\"checkboxes\": True}})</code>. The Dash AG Grid offers many options to configure row selection. These can be passed directly into <code>dash_ag_grid</code> as keyword arguments or set for multiple tables by creating a custom table function.</p> <p>As well as being triggered on mouse click, <code>set_control</code> is also triggered by pressing Space while focused on a row.</p>","path":["Graph and table interactions"],"tags":[]},{"location":"user-guides/graph-table-actions/#cross-filter-from-graph","level":3,"title":"Cross-filter from graph","text":"<p>The trigger for a cross-filter from a graph is clicking on data in the graph. The <code>value</code> argument of the [<code>set_control</code> action][vizro.actions.set_control] can be used in two ways to specify what sets <code>control</code>:</p> <ul> <li>Column from which to take the value. This requires you to set <code>custom_data</code> in the graph's <code>figure</code> function. For example, for a graph <code>px.bar(..., color=\"country\", custom_data=\"country\")</code> you can use <code>va.set_control(value=\"country\", ...)</code>.</li> <li>As a shortcut, if the value is encoded by a positional dimension such as <code>x</code> or <code>y</code> then you can use that variable directly and do not need to set <code>custom_data</code>. For example, for a graph <code>px.bar(x=\"country\", ...)</code> you can use <code>va.set_control(value=\"x\", ...)</code>. Positional dimensions include <code>x</code>, <code>y</code>, <code>z</code> for Cartesian plots and <code>lat</code>, <code>lon</code>, <code>location</code> for choropleth maps.</li> </ul> Behind the scenes mechanism <p><code>value</code> is an instruction for what to lookup in Plotly's <code>clickData</code>, whose format and content depend on the type of chart clicked. Generally speaking, positional information is automatically included in <code>clickData</code> but other information such as <code>color</code> must be manually supplied using <code>custom_data</code> to make it available.</p> <p>The rules for how <code>value</code> is interpreted by <code>set_control</code> are:</p> <ol> <li>If the graph has <code>custom_data</code> then interpret the <code>value</code> as a column name and attempt to find it in <code>custom_data</code>.</li> <li>If the graph does not have <code>custom_data</code> or does not include <code>value</code> as a column in <code>custom_data</code> then perform a lookup inside <code>clickData[\"points\"][0]</code>. For example:<ul> <li><code>value=\"x\"</code> is equivalent to looking at <code>clickData[\"points\"][0][\"x\"]</code>.</li> <li><code>value=\"key.subkey[1]\"</code> is equivalent to looking at <code>clickData[\"points\"][0][\"key\"][\"subkey\"][1]</code>.</li> </ul> </li> </ol> <p>Based on the source graph and its available <code>clickData</code>, you can therefore configure precisely which property to set as <code>value</code>. For almost all use cases, this would be a column name or a positional variable such as <code>x</code>. However, advanced users might like to use other data that is available in <code>clickData</code> such as <code>pointNumber</code> or to refer to an object nested deeply inside <code>custom_data</code>.</p> <p>We show an example of each of these in turn. Here is an example where we use <code>custom_data</code> and <code>value=\"sex\"</code> to use a value from the <code>sex</code> column. We need to specify <code>custom_data</code> because the <code>sex</code> column is not a positional dimension in the plot.</p> <p>Cross-filter from graph to table with <code>custom_data</code></p> app.pyapp.yamlResult <pre><code>import vizro.actions as va\nimport vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\n\ntips = px.data.tips()\n\npage = vm.Page(\n    title=\"Cross-filter from graph to table\",\n    components=[\n        vm.Graph(\n            title=\"Click on a box to use that box's sex to filter table\",\n            figure=px.box(tips, x=\"tip\", y=\"time\", color=\"sex\", custom_data=\"sex\"),  # (1)!\n            actions=va.set_control(control=\"sex_filter\", value=\"sex\"),\n        ),\n        vm.AgGrid(id=\"tips_table\", figure=dash_ag_grid(tips)),  # (2)!\n    ],\n    controls=[vm.Filter(id=\"sex_filter\", column=\"sex\", targets=[\"tips_table\"])],  # (3)!\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We encode the <code>sex</code> column as <code>color</code> in the plot and include it in <code>custom_data=\"sex\"</code>.</li> <li>We give the <code>vm.AgGrid</code> an <code>id</code> so that it can be targeted explicitly by <code>vm.Filter(id=\"sex_filter\")</code>.</li> <li>We give the <code>vm.Filter</code> an <code>id</code> so that it can be set explicitly by <code>va.set_control</code>.</li> </ol> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - actions:\n          - control: sex_filter\n            type: set_control\n            value: sex\n        figure:\n          _target_: box\n          color: sex\n          custom_data: sex\n          data_frame: tips\n          x: tip\n          y: time\n        title: Click on a box to use that box's sex to filter table\n        type: graph\n      - figure:\n          _target_: dash_ag_grid\n          data_frame: tips\n        id: tips_table\n        type: ag_grid\n    controls:\n      - column: sex\n        id: sex_filter\n        targets:\n          - tips_table\n        type: filter\n    title: Cross-filter from graph to table\n</code></pre> <p></p> <p>When you click on a box in the graph, the table is cross-filtered to show data for only one sex.</p> Behind the scenes mechanism <p>In full, what happens is as follows:</p> <ol> <li>Clicking on the box triggers the <code>va.set_control</code> action. This uses the value of <code>sex</code> taken from the graph's <code>custom_data</code> (in other words, \"Male\" or \"Female\") to set the selector underlying <code>vm.Filter(id=\"sex_filter\")</code>.</li> <li>The change in value of <code>vm.Filter(id=\"sex_filter\")</code> triggers the filter to be re-applied on its <code>targets=[\"tips_table\"]</code> so that a filtered table is shown.</li> </ol> <p>The mechanism for triggering the filter when its value is set by <code>va.set_control</code> is an implicit actions chain.</p> <p>Cross-filter from custom chart</p> <p>If you cross-filter from a custom chart and wish to use a column supplied through <code>custom_data</code> for the <code>value</code> argument of <code>va.set_control</code> then you must explicitly include <code>custom_chart</code> in the function signature:</p> <pre><code>@capture(\"graph\")\ndef my_custom_chart(data_frame, custom_data, **kwargs):\n    return px.scatter(data_grame, custom_data=custom_data, **kwargs)\n</code></pre> <p>Here is an example where we do not need to use <code>custom_data</code> because the value used in <code>va.set_control</code> is positional: it corresponds to the <code>y</code> axis of the graph.</p> <p>Cross-filter from graph without <code>custom_data</code> to table</p> app.pyapp.yamlResult <pre><code>import vizro.actions as va\nimport vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\n\ntips = px.data.tips()\n\npage = vm.Page(\n    title=\"Cross-filter from graph to table\",\n    components=[\n        vm.Graph(\n            title=\"Click on a box to use that box's sex to filter table\",\n            figure=px.box(tips, x=\"tip\", y=\"sex\"),\n            actions=va.set_control(control=\"sex_filter\", value=\"y\"),\n        ),\n        vm.AgGrid(id=\"tips_table\", figure=dash_ag_grid(tips)),  # (1)!\n    ],\n    controls=[vm.Filter(id=\"sex_filter\", column=\"sex\", targets=[\"tips_table\"])],  # (2)!\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We give the <code>vm.AgGrid</code> an <code>id</code> so that it can be targeted explicitly by <code>vm.Filter(id=\"sex_filter\")</code>.</li> <li>We give the <code>vm.Filter</code> an <code>id</code> so that it can be set explicitly by <code>va.set_control</code>.</li> </ol> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - actions:\n          - control: sex_filter\n            type: set_control\n            value: y\n        figure:\n          _target_: box\n          data_frame: tips\n          x: tip\n          y: sex\n        title: Click on a box to use that box's sex to filter table\n        type: graph\n      - figure:\n          _target_: dash_ag_grid\n          data_frame: tips\n        id: tips_table\n        type: ag_grid\n    controls:\n      - column: sex\n        id: sex_filter\n        targets:\n          - tips_table\n        type: filter\n    title: Cross-filter from graph to table\n</code></pre> <p></p> <p>When you click on a box in the graph, the table is cross-filtered to show data for only one sex, which is the <code>y</code> variable for the plot.</p> Behind the scenes mechanism <p>In full, what happens is as follows:</p> <ol> <li>Clicking on the box triggers the <code>va.set_control</code> action. This uses the value of <code>y</code> (in other words, \"Male\" or \"Female\") to set the selector underlying <code>vm.Filter(id=\"sex_filter\")</code>.</li> <li>The change in value of <code>vm.Filter(id=\"sex_filter\")</code> triggers the filter to be re-applied on its <code>targets=[\"tips_table\"]</code> so that a filtered table is shown.</li> </ol> <p>The mechanism for triggering the filter when its value is set by <code>va.set_control</code> is an implicit actions chain.</p>","path":["Graph and table interactions"],"tags":[]},{"location":"user-guides/graph-table-actions/#cross-filter-between-containers","level":3,"title":"Cross-filter between containers","text":"<p>A cross-filter often works best when used inside a container. This typically makes it clearer which components the filter applies to, especially when the container is styled.</p> <p>For example, let us rearrange the above example of a cross-filter from a table into containers. Now the control appears directly above the table that it targets rather than on the left hand side of the page. The rearrangement here is purely visual to give a better user experience; <code>va.set_control</code> itself is configured exactly the same way and behaves identically while the dashboard is running.</p> <p>Cross-filter between containers</p> app.pyapp.yamlResult <pre><code>import vizro.actions as va\nimport vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\n\ntips = px.data.tips()\n\npage = vm.Page(\n    title=\"Cross-filter between containers\",\n    components=[\n        vm.Container(\n            components=[\n                vm.AgGrid(\n                    title=\"Click on a row to use that row's sex to filter graph\",\n                    figure=dash_ag_grid(tips),\n                    actions=va.set_control(control=\"sex_filter\", value=\"sex\"),\n                )\n            ],\n            variant=\"filled\",  # (1)!\n        ),\n        vm.Container(\n            components=[vm.Graph(figure=px.histogram(tips, x=\"tip\"))],  # (2)!\n            controls=[vm.Filter(id=\"sex_filter\", column=\"sex\")],  # (3)!\n            variant=\"filled\",\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We use styled containers to make it clear which components and controls are in each container.</li> <li>The <code>vm.Graph</code> no longer needs an <code>id</code> assigned to it, since the <code>vm.Filter</code> does not need to explicitly target it any more.</li> <li>The <code>vm.Filter</code> no longer needs to specify <code>targets</code>. By default, the <code>vm.Filter</code> targets all components in its container whose data source includes <code>column=\"sex\"</code>.</li> </ol> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - components:\n          - actions:\n              - control: sex_filter\n                type: set_control\n                value: sex\n            figure:\n              _target_: dash_ag_grid\n              data_frame: tips\n            title: Click on a row to use that row's sex to filter graph\n            type: ag_grid\n        type: container\n        variant: filled\n      - components:\n          - figure:\n              _target_: histogram\n              data_frame: tips\n              x: tip\n            type: graph\n        controls:\n          - column: sex\n            id: sex_filter\n            type: filter\n        type: container\n        variant: filled\n    title: Cross-filter between containers\n</code></pre> <p></p>","path":["Graph and table interactions"],"tags":[]},{"location":"user-guides/graph-table-actions/#cross-filter-between-pages","level":3,"title":"Cross-filter between pages","text":"<p>You can perform a cross-filter where the target components are on a different page from the source. The use of [<code>va.set_control</code>][vizro.actions.set_control] is identical, but the intermediate filter must have <code>show_in_url=True</code>.</p> <p>For example, let us rearrange the above example of a cross-filter from a table so that the source table is on a different page from the target graph (and hence filter). When you click or press Space on a row in the table, you are taken to the target page with the graph cross-filtered to show data only for one sex.</p> <p>Cross filter between pages</p> app.pyapp.yamlResult <pre><code>import vizro.actions as va\nimport vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\n\ntips = px.data.tips()\n\npage_1 = vm.Page(\n    title=\"Cross-filter source table\",\n    components=[\n        vm.AgGrid(\n            title=\"Click on a row to use that row's sex to filter graph\",\n            figure=dash_ag_grid(tips),\n            actions=va.set_control(control=\"sex_filter\", value=\"sex\"),\n        )\n    ],\n)\n\npage_2 = vm.Page(\n    title=\"Cross-filter target graph\",\n    components=[vm.Graph(figure=px.histogram(tips, x=\"tip\"))],   # (1)!\n    controls=[vm.Filter(id=\"sex_filter\", column=\"sex\", show_in_url=True)],  # (2)!\n)\n\ndashboard = vm.Dashboard(pages=[page_1, page_2])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>The <code>vm.Graph</code> no longer needs an <code>id</code> assigned to it, since the <code>vm.Filter</code> does not need to explicitly target it any more.</li> <li>The <code>vm.Filter</code> no longer needs to specify <code>targets</code>. By default, the <code>vm.Filter</code> targets all components on its page whose data source includes <code>column=\"sex\"</code>. We must set <code>show_in_url=True</code> for this filter to be set by <code>va.set_control</code>.</li> </ol> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - actions:\n          - control: sex_filter\n            type: set_control\n            value: sex\n        figure:\n          _target_: dash_ag_grid\n          data_frame: tips\n        title: Click on a row to use that row's sex to filter graph\n        type: ag_grid\n    title: Cross-filter source table\n  - components:\n      - figure:\n          _target_: histogram\n          data_frame: tips\n          x: tip\n        type: graph\n    controls:\n      - column: sex\n        id: sex_filter\n        show_in_url: true\n        type: filter\n    title: Cross-filter target graph\n</code></pre> <p></p>","path":["Graph and table interactions"],"tags":[]},{"location":"user-guides/graph-table-actions/#cross-filter-from-pivoted-or-multi-dimensional-data","level":3,"title":"Cross-filter from pivoted or multi-dimensional data","text":"<p>A single source component can trigger multiple cross-filters. For example, pivoted data can be visualized using a table or a 2-dimensional heatmap.</p> <p>To perform multiple cross-filters, each dimension that is filtered must have its own <code>vm.Filter</code> that is set by <code>va.set_control</code> in the <code>actions</code> of the source component in an actions chain. Here is a 2-dimensional example that cross-filters from a graph using the positional variables <code>x</code> and <code>y</code>.</p> <p>Cross-filter over 2 dimensions</p> app.pyapp.yamlResult <pre><code>import vizro.actions as va\nimport vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\n\ntips = px.data.tips()\n\npage = vm.Page(\n    title=\"Cross-filter over 2 dimensions\",\n    components=[\n        vm.Graph(\n            title=\"Click on a cell to use that cell's sex and day to filter table\",\n            figure=px.density_heatmap(  # (1)!\n                tips,\n                x=\"day\",\n                y=\"sex\",\n                category_orders={\"day\": [\"Thur\", \"Fri\", \"Sat\", \"Sun\"]},\n            ),\n            actions=[\n                va.set_control(control=\"day_filter\", value=\"x\"),  # (2)!\n                va.set_control(control=\"sex_filter\", value=\"y\"),\n            ],\n        ),\n        vm.AgGrid(id=\"tips_table\", figure=dash_ag_grid(tips)),\n    ],\n    controls=[\n        vm.Filter(id=\"day_filter\", column=\"day\", targets=[\"tips_table\"]),  # (3)!\n        vm.Filter(id=\"sex_filter\", column=\"sex\", targets=[\"tips_table\"]),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>We make a 2-dimensional histogram to show the number of rows in the <code>tips</code> data for each day and sex.</li> <li>Each dimension has its own <code>va.set_control</code> to set the relevant <code>vm.Filter</code>.</li> <li>Each has its own <code>vm.Filter</code> to filter by the relevant <code>column</code>.</li> </ol> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - actions:\n          - control: day_filter\n            type: set_control\n            value: x\n          - control: sex_filter\n            type: set_control\n            value: y\n        figure:\n          _target_: density_heatmap\n          category_orders:\n            day:\n              - Thur\n              - Fri\n              - Sat\n              - Sun\n          data_frame: tips\n          x: day\n          y: sex\n        title: Click on a cell to use that cell's sex and day to filter table\n        type: graph\n      - figure:\n          _target_: dash_ag_grid\n          data_frame: tips\n        id: tips_table\n        type: ag_grid\n    controls:\n      - column: day\n        id: day_filter\n        targets:\n          - tips_table\n        type: filter\n      - column: sex\n        id: sex_filter\n        targets:\n          - tips_table\n        type: filter\n    title: Cross-filter over 2 dimensions\n</code></pre> <p></p> <p>When you click on a colored cell in the heatmap, the table is cross-filtered to show data for only one sex and one day. The \"count\" shown for each heatmap cell corresponds to the number of rows shown in the filtered table when that cell is clicked.</p> Behind the scenes mechanism <p>In full, what happens is as follows:</p> <ol> <li>Clicking on a cell triggers the first <code>va.set_control</code> action. This uses the value of <code>day</code> (in other words, \"Thur\", \"Fri\", \"Sat\" or \"Sun\") to set the selector underlying <code>vm.Filter(id=\"day_filter\")</code>.</li> <li>When the <code>day_filter</code> has been set, the second <code>va.set_control</code> action runs. This uses the value of <code>sex</code> (in other words, \"Male\" or \"Female\") to set the selector underlying <code>vm.Filter(id=\"sex_filter\")</code>.</li> <li>The change in value of <code>vm.Filter(id=\"day_filter\")</code> triggers the filter on its <code>targets=[\"tips_table\"]</code> so that a filtered table is shown.</li> <li>The change in value of <code>vm.Filter(id=\"sex_filter\")</code> triggers the filter on its <code>targets=[\"tips_table\"]</code> so that a filtered table is shown.</li> </ol> <p>The mechanism for triggering the filter when its value is set by <code>va.set_control</code> is an implicit actions chain, while the sequence of applying the two <code>va.set_control</code> is an explicit actions chain. In general, steps 2 and 3 above will execute in parallel.</p> <p>When performing multiple filters with dynamic data, you should consider configuring a cache so that steps 3 and 4 above do not repeatedly perform a slow data load.</p> <p>Multiple cross-filters are similarly possible from a table:</p> <pre><code>vm.AgGrid(\n    ...,\n    actions=[\n        va.set_control(control=\"day_filter\", value=\"day\"),\n        va.set_control(control=\"sex_filter\", value=\"sex\"),\n    ],\n)\n</code></pre> <p>However, it is not yet possible to cross-filter from a pivot table according to the row and column of the clicked cell.</p>","path":["Graph and table interactions"],"tags":[]},{"location":"user-guides/graph-table-actions/#cross-parameter","level":2,"title":"Cross-parameter","text":"<p>A cross-parameter is when the user clicks on one source graph or table to update any argument other than <code>data_frame</code> of one or more target components. In Vizro, a cross-parameter operates through an intermediate parameter. To configure a cross-parameter:</p> <ol> <li> <p>Create a parameter that targets the graphs, tables or figures you would like to update. The parameter must have a categorical selector (both multi- and single-option are allowed).</p> <pre><code>import vizro.models as vm\n\ncontrols = [\n    vm.Parameter(\n        id=\"my_parameter\",\n        targets=[\"target_component.my_argument\"],\n        selector=vm.RadioItems(options=[\"A\", \"B\", \"C\"]),\n    )\n]\n</code></pre> </li> <li> <p>Call <code>set_control</code> in the <code>actions</code> argument of the source [<code>Graph</code>][vizro.models.Graph] or [<code>AgGrid</code>][vizro.models.AgGrid] component that triggers the cross-parameter.</p> <ol> <li>Set <code>control</code> to the ID of the parameter.</li> <li>Set <code>value</code>. The format of this depends on the source model and is given in the [API reference][vizro.actions.set_control]. Think of it as an instruction for what to lookup in the source data: whatever value is fetched from this lookup is used to set <code>control</code>.</li> </ol> <pre><code>import vizro.actions as va\n\ncomponents = [vm.Graph(..., actions=va.set_control(control=\"my_parameter\", value=\"country\"))]\n</code></pre> </li> </ol>","path":["Graph and table interactions"],"tags":[]},{"location":"user-guides/graph-table-actions/#cross-highlight","level":3,"title":"Cross-highlight","text":"<p>A cross-highlight is an example of a cross-parameter where the effect of the intermediate parameter is to highlight data. When a user clicks on one source graph or table, the corresponding data is highlighted in a target graph or table (typically a custom graph). The highlighting can occur in two ways:</p> <ul> <li>Target highlighting: The highlighting appears in a target graph that is distinct from the source that was clicked. Below we give examples of highlighting a target graph from a source table and from a source graph.</li> <li>Source highlighting or self-highlighting: The highlighting appears in the same source graph that was clicked. Below we give an example of self-highlighting a graph.</li> </ul> <p>In Vizro, cross-highlighting operates through an intermediate parameter. Often this parameter is hidden from view with <code>visible=False</code> since the highlighting effect itself provides sufficient visual feedback about the selected data. Remember that the cross-highlight can be cleared with the \"Reset controls\" button.</p> <p>In general, there are many different ways to visually highlight data in a graph. For example:</p> <ul> <li>Change the style of a marker, line or bar, for example its color, opacity or shape.</li> <li>Add an annotation.</li> <li>Highlight a region of the plot's background.</li> </ul> <p>Tip</p> <p>All cross-parameters, which includes cross-highlights, can operate across different containers and different pages. The use of [<code>va.set_control</code>][vizro.actions.set_control] is identical to when source and target are in the same container and page. For further examples and styling hints, see the sections on cross-filtering between containers and between pages.</p>","path":["Graph and table interactions"],"tags":[]},{"location":"user-guides/graph-table-actions/#cross-highlight-from-table","level":4,"title":"Cross-highlight from table","text":"<p>This example shows how to configure cross-highlighting where clicking on the row in a table highlights the corresponding data in a target scatter graph. The highlighting is visually shown by changing the color of the point for the selected country. Since cross-highlight is a sort of cross-parameter, the method follows the same pattern as configuring a cross-parameter.</p> <ol> <li> <p>Create a parameter that targets the graph you would like to visually highlight.</p> <pre><code>import vizro.models as vm\n\ncontrols = [\n    vm.Parameter(\n        id=\"highlight_parameter\",  # (1)!\n        targets=[\"scatter_chart.highlight_country\"],  # (2)!\n        selector=vm.RadioItems(options=[\"NONE\", ...]),  # (3)!\n        visible=False,  # (4)!\n    )\n]\n</code></pre> <ol> <li>We give the parameter an <code>id</code> so that it can be set explicitly by <code>va.set_control</code>.</li> <li>The parameter targets the argument <code>highlight_country</code> of <code>vm.Graph(id=\"scatter_chart\")</code>.</li> <li>We add <code>\"NONE\"</code> as an option, corresponding to a parameter value <code>highlight_country=None</code>. This is used so the target graph is initially unhighlighted.</li> <li>We set <code>visible=False</code> to hide the parameter selector from the user interface while keeping the functionality active.</li> </ol> </li> <li> <p>Call <code>set_control</code> in the <code>actions</code> argument of the source [<code>AgGrid</code>][vizro.models.AgGrid] component that triggers the cross-highlight.</p> <ol> <li>Set <code>control</code> to the ID of the parameter.</li> <li>Set <code>value</code> to specify which column contains the value that sets the control when a row in the table is clicked.</li> </ol> <pre><code>import vizro.actions as va\n\ncomponents = [vm.AgGrid(..., actions=va.set_control(control=\"highlight_parameter\", value=\"country\"))]\n</code></pre> </li> <li> <p>Create a custom chart that highlights the data corresponding to <code>highlight_country</code>.</p> <pre><code>import vizro.plotly.express as px\nfrom vizro.models.types import capture\n\n\n@capture(\"graph\")\ndef scatter_with_highlight(data_frame, highlight_country):  # (1)!\n    country_is_highlighted = data_frame[\"country\"] == highlight_country  # (2)!\n    return px.scatter(data_frame, x=..., y=..., color=country_is_highlighted)  # (3)!\n</code></pre> <ol> <li>The <code>highlight_country</code> argument receives the selected country name from <code>highlight_parameter</code>.</li> <li><code>country_is_highlighted</code> is a pandas Series that contains <code>True</code> for the highlighted country and <code>False</code> for all others.</li> <li>We color the points by <code>country_is_highlighted</code>. This will color differently the values <code>True</code> (for the highlighted country) and <code>False</code> (for all others).</li> </ol> </li> </ol> <p>The full code is given below. This shows a slightly more complicated highlighting style that also changes some additional properties of the highlighted point like its opacity.</p> <p>Cross-highlight from table</p> app.pyapp.yamlResult <pre><code>import vizro.plotly.express as px\nimport vizro.models as vm\nimport vizro.actions as va\nfrom vizro.models.types import capture\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\n\ngapminder = px.data.gapminder().query(\"continent == 'Europe' and year == 2007\")\n\n@capture(\"graph\")\ndef scatter_with_highlight(data_frame, highlight_country=None):  # (1)!\n    country_is_highlighted = data_frame[\"country\"] == highlight_country  # (2)!\n    fig = px.scatter(\n        data_frame,\n        x=\"gdpPercap\",\n        y=\"lifeExp\",\n        size=\"pop\",\n        size_max=60,\n        opacity=0.3,\n        color=country_is_highlighted,\n        category_orders={\"color\": [False, True]},  # (3)!\n    )\n\n    if highlight_country is not None: # (4)!\n        fig.update_traces(selector=1, marker={\"line_width\": 2, \"opacity\": 1})  # (5)!\n\n    fig.update_layout(showlegend=False)\n    return fig\n\n\npage = vm.Page(\n    title=\"Cross-highlight from table\",\n    layout=vm.Grid(grid=[[0, 1]], col_gap=\"80px\"),  # (6)!\n    components=[\n        vm.AgGrid(\n            header=\"💡 Click on a row to highlight that country in the scatter plot\",\n            figure=dash_ag_grid(data_frame=gapminder),\n            actions=va.set_control(control=\"highlight_parameter\", value=\"country\"),  # (7)!\n        ),\n        vm.Graph(\n            id=\"scatter_chart\",   # (8)!\n            figure=scatter_with_highlight(gapminder),\n        ),\n    ],\n    controls=[\n        vm.Parameter(\n            id=\"highlight_parameter\",   # (9)!\n            targets=[\"scatter_chart.highlight_country\"],   # (10)!\n            selector=vm.RadioItems(options=[\"NONE\", *gapminder[\"country\"]]),   # (11)!\n            visible=False,   # (12)!\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>The <code>highlight_country</code> argument receives the selected country name from <code>highlight_parameter</code>.</li> <li><code>country_is_highlighted</code> is a pandas Series that contains <code>True</code> for the highlighted country and <code>False</code> for all others. We use this to change the color of the highlighted point.</li> <li>We make sure that the colors are always ordered the same way. This ensures that the highlighted point always has the same color regardless of which row in the table is clicked.</li> <li>When a country is highlighted, make further modifications to the style of the highlighted point's marker to make it stand out more.</li> <li><code>update_traces</code> updates only the trace selected with index 1. The traces are ordered by <code>category_orders={\"color\": [False, True]}</code> and so this corresponds to <code>True</code>, in other words the trace that has <code>country_is_highlighted=True</code> and contains the highlighted point.</li> <li>We use a side-by-side layout with an 80px column gap to display the table and graph together.</li> <li>The table's <code>va.set_control</code> sets <code>higlight_parameter</code> to the country from the clicked row.</li> <li>We give the <code>vm.Graph</code> an <code>id</code> so that it can be targeted by <code>highlight_parameter</code>.</li> <li>We give the parameter an <code>id</code> so that it can be set explicitly by <code>va.set_control</code>.</li> <li>The parameter targets the argument <code>highlight_country</code> of <code>vm.Graph(id=\"scatter_chart\")</code>.</li> <li>We add <code>\"NONE\"</code> as an option, corresponding to a parameter value <code>highlight_country=None</code>. This is used so the target graph is initially unhighlighted.</li> <li>We set <code>visible=False</code> to hide the parameter selector from the user interface while keeping the functionality active.</li> </ol> <pre><code># Still requires a .py to add data to the data manager, define CapturedCallables, and parse YAML configuration\n# More explanation in the docs on `Dashboard` and extensions.\npages:\n- components:\n  - actions:\n    - control: highlight_parameter\n      type: set_control\n      value: country\n    figure:\n      _target_: dash_ag_grid\n      data_frame: gapminder\n    header: 💡 Click on a row to highlight that country in the scatter plot\n    type: ag_grid\n  - figure:\n      _target_: __main__.scatter_with_highlight\n      data_frame: gapminder\n    id: scatter_chart\n    type: graph\n  controls:\n  - id: highlight_parameter\n    selector:\n      options:\n      - NONE\n      - Albania\n      - ...\n      - United Kingdom\n      type: radio_items\n    targets:\n    - scatter_chart.highlight_country\n    type: parameter\n    visible: false\n  layout:\n    col_gap: 80px\n    grid:\n    - - 0\n      - 1\n    type: grid\n  title: Cross-highlight from table\n</code></pre> <p></p> <p>When you click on a row in the table, the corresponding point is highlighted in the scatter plot with an orange color, full opacity, and a thick border. Clicking the \"Reset controls\" button resets the parameter to its original value and hence clears the highlighting.</p> Behind the scenes mechanism <p>In full, what happens is as follows:</p> <ol> <li>Clicking on a row triggers the <code>va.set_control</code> action. This uses the value of the <code>country</code> column for the selected row to set the selector underlying <code>vm.Parameter(id=\"highlight_parameter\")</code>.</li> <li>The change in value of <code>vm.Parameter(id=\"highlight_parameter\")</code> triggers the parameter to update the <code>highlight_country</code> argument of the target component <code>scatter_chart</code> so that a highlighted graph is shown.</li> </ol> <p>The mechanism for triggering the parameter when its value is set by <code>va.set_control</code> is an implicit actions chain.</p>","path":["Graph and table interactions"],"tags":[]},{"location":"user-guides/graph-table-actions/#cross-highlight-from-graph","level":4,"title":"Cross-highlight from graph","text":"<p>This example shows how to configure cross-highlighting where clicking on a point in a graph highlights the corresponding data in a target bump chart. The highlighting is visually shown by making the line for the selector country stronger. Since cross-highlight is a sort of cross-parameter, the method follows the same pattern as configuring a cross-parameter.</p> <ol> <li> <p>Create a parameter that targets the graph you would like to visually highlight.</p> <pre><code>import vizro.models as vm\n\ncontrols = [\n    vm.Parameter(\n        id=\"highlight_parameter\",  # (1)!\n        targets=[\"bump_chart.highlight_country\"],  # (2)!\n        selector=vm.RadioItems(options=[\"NONE\", ...]),  # (3)!\n        visible=False,  # (4)!\n    )\n]\n</code></pre> <ol> <li>We give the parameter an <code>id</code> so that it can be set explicitly by <code>va.set_control</code>.</li> <li>The parameter targets the argument <code>highlight_country</code> of <code>vm.Graph(id=\"bump_chart\")</code>.</li> <li>We add <code>\"NONE\"</code> as an option, corresponding to a parameter value <code>highlight_country=None</code>. This is used so the target graph is initially unhighlighted.</li> <li>We set <code>visible=False</code> to hide the parameter selector from the user interface while keeping the functionality active.</li> </ol> </li> <li> <p>Call <code>set_control</code> in the <code>actions</code> argument of the source [<code>Graph</code>][vizro.models.Graph] component that triggers the cross-highlight.</p> <ol> <li>Set <code>control</code> to the ID of the parameter.</li> <li>Set <code>value</code>. As with a cross-filter from a graph, there are two different ways to specify this. However, often the value you require is encoded by a positional dimension such as <code>x</code>, <code>y</code>, <code>z</code>. If the value is not encoded as a positional dimension (for example, it corresponds to <code>color</code>) then you should instead use <code>custom_data</code> as described in the instructions on cross-filtering from a graph.</li> </ol> <pre><code>import vizro.actions as va\n\ncomponents = [\n    vm.Graph(\n        figure=px.bar(data_frame, x=..., y=\"country\"),\n        actions=va.set_control(control=\"highlight_parameter\", value=\"y\"),\n    )\n]\n</code></pre> </li> <li> <p>Create a custom chart that highlights the data corresponding to <code>highlight_country</code>.</p> <pre><code>import vizro.plotly.express as px\nfrom vizro.models.types import capture\n\n\n@capture(\"graph\")\ndef bump_chart_with_highlight(data_frame, highlight_country):  # (1)!\n    fig = px.line(data_frame, x=..., y=..., color=\"country\")  # (2)!\n    fig.update_traces(selector={\"name\": highlight_country}, line_width=3)  # (3)!\n    return fig\n</code></pre> <ol> <li>The <code>highlight_country</code> argument receives the selected country name from <code>highlight_parameter</code>.</li> <li>We color the plot by <code>country</code> so that each country has its own trace in the resulting chart.</li> <li>We use <code>update_traces</code> to modify the highlighted line's style.</li> </ol> </li> </ol> <p>The full code is given below. This includes the complete code for a bump chart with more advanced styling.</p> <p>Cross-highlight from graph</p> app.pyapp.yamlResult <pre><code>import vizro.plotly.express as px\nimport vizro.models as vm\nimport vizro.actions as va\nfrom vizro.models.types import capture\nfrom vizro import Vizro\n\nselected_countries = [\n    \"Singapore\",\n    \"Malaysia\",\n    \"Thailand\",\n    \"Indonesia\",\n    \"Philippines\",\n    \"Vietnam\",\n    \"Cambodia\",\n    \"Myanmar\",\n]\n\ngapminder = px.data.gapminder().query(\"country.isin(@selected_countries)\")\n\n@capture(\"graph\")\ndef bump_chart_with_highlight(data_frame, highlight_country=None):  # (1)!\n    rank = data_frame.groupby(\"year\")[\"lifeExp\"].rank(method=\"dense\", ascending=False)\n\n    fig = px.line(data_frame, x=\"year\", y=rank, color=\"country\", markers=True)  # (2)!\n    fig.update_yaxes(title=\"Rank (1 = Highest lifeExp)\", autorange=\"reversed\", dtick=1)  # (3)!\n    fig.update_traces(opacity=0.3, line_width=2)  # (4)!\n\n    if highlight_country is not None:  # (5)!\n        fig.update_traces(selector={\"name\": highlight_country}, opacity=1, line_width=3)  # (6)!\n\n    return fig\n\n\npage = vm.Page(\n    title=\"Cross-highlight from graph\",\n    components=[\n        vm.Graph(\n            figure=px.bar(\n                gapminder.query(\"year == 2007\"),\n                y=\"country\",\n                x=\"lifeExp\",\n                labels={\"lifeExp\": \"lifeExp in 2007\"},\n            ),\n            header=\"💡 Click any bar to highlight that country in the bump chart\",\n            actions=va.set_control(control=\"highlight_parameter\", value=\"y\"),  # (7)!\n        ),\n        vm.Graph(\n            id=\"bump_chart\",  # (8)!\n            figure=bump_chart_with_highlight(data_frame=gapminder),\n        ),\n    ],\n    controls=[\n        vm.Parameter(\n            id=\"highlight_parameter\",   # (9)!\n            targets=[\"bump_chart.highlight_country\"],   # (10)!\n            selector=vm.RadioItems(options=[\"NONE\", *gapminder[\"country\"]]),   # (11)!\n            visible=False,   # (12)!\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>The <code>highlight_country</code> argument receives the selected country name from <code>highlight_parameter</code>.</li> <li><code>rank</code> is a pandas Series that gives the ranking of each country by life expectancy for every year. We color the plot by <code>country</code> so that each country has its own trace in the resulting chart.</li> <li>Format the bump chart's y-axis so that it shows the rank of 1 (highest life expectancy) at the top.</li> <li>Style the lines for every country.</li> <li>When a country is highlighted, modify its line's style to make it stand out more.</li> <li><code>update_traces</code> updates only the trace selected, which is the <code>highlighted_country</code> one.</li> <li>The graph's <code>va.set_control</code> sets <code>higlight_parameter</code> to the country from the clicked bar.</li> <li>We give the <code>vm.Graph</code> an <code>id</code> so that it can be targeted by <code>highlight_parameter</code>.</li> <li>We give the parameter an <code>id</code> so that it can be set explicitly by <code>va.set_control</code>.</li> <li>The parameter targets the argument <code>highlight_country</code> of <code>vm.Graph(id=\"bump_chart\")</code>.</li> <li>We add <code>\"NONE\"</code> as an option, corresponding to a parameter value <code>highlight_country=None</code>. This is used so the target graph is initially unhighlighted.</li> <li>We set <code>visible=False</code> to hide the parameter selector from the user interface while keeping the functionality active.</li> </ol> <pre><code># Still requires a .py to add data to the data manager, define CapturedCallables, and parse YAML configuration\n# More explanation in the docs on `Dashboard` and extensions.\npages:\n  - components:\n      - type: graph\n        figure:\n          _target_: bar\n          data_frame: gapminder_2007\n          labels:\n            lifeExp: lifeExp in 2007\n          x: lifeExp\n          y: country\n        header: 💡 Click any bar to highlight that country in the bump chart\n        actions:\n          - type: set_control\n            control: highlight_parameter\n            value: y\n      - type: graph\n        id: bump_chart\n        figure:\n          _target_: __main__.bump_chart_with_highlight\n          data_frame: gapminder\n    controls:\n      - type: parameter\n        id: highlight_parameter\n        targets:\n          - bump_chart.highlight_country\n        selector:\n          type: radio_items\n          options:\n            - NONE\n            - Cambodia\n            - Indonesia\n            - Malaysia\n            - Myanmar\n            - Philippines\n            - Singapore\n            - Thailand\n            - Vietnam\n        visible: false\n    title: Cross-highlight from graph\n</code></pre> <p></p> <p>When you click on a bar in the bar chart, the corresponding line is highlighted in the bump chart with full opacity and a thicker line. Clicking the \"Reset controls\" button resets the parameter to its original value and hence clears the highlighting.</p> Behind the scenes mechanism <p>In full, what happens is as follows:</p> <ol> <li>Clicking on a bar triggers the <code>va.set_control</code> action. This uses the value of <code>y</code> (in other words, the country) taken from the source graph to set the value of the <code>vm.Parameter(id=\"highlight_parameter\")</code>.</li> <li>The change in value of <code>vm.Parameter(id=\"highlight_parameter\")</code> triggers the parameter to update the <code>highlight_country</code> argument of the target component <code>bump_chart</code> so that a highlighted graph is shown.</li> </ol> <p>The mechanism for triggering the parameter when its value is set by <code>va.set_control</code> is an implicit actions chain.</p>","path":["Graph and table interactions"],"tags":[]},{"location":"user-guides/graph-table-actions/#self-highlight-a-graph","level":4,"title":"Self-highlight a graph","text":"<p>In a self-highlight, the same component is both the source and the target of a cross-highlight. For example, when a user clicks on a graph, part of the graph can remain highlighted to show where they clicked. Since it is just a special type of cross-highlighting, the configuration works exactly the same way as a cross-highlight from a graph.</p> <p>A self-highlight is often part of an actions chain that includes another action like a cross-filter. The example below shows how clicking a graph can perform a self-highlight and cross-filter a table.</p> <p>Self-highlight a graph and cross-filter</p> app.pyapp.yamlResult <pre><code>import vizro.plotly.express as px\nimport vizro.models as vm\nimport vizro.actions as va\nfrom vizro.models.types import capture\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\n\nselected_countries = [\n    \"Singapore\",\n    \"Malaysia\",\n    \"Thailand\",\n    \"Indonesia\",\n    \"Philippines\",\n    \"Vietnam\",\n    \"Cambodia\",\n    \"Myanmar\",\n]\n\ngapminder = px.data.gapminder().query(\"country.isin(@selected_countries)\")\n\n\n@capture(\"graph\")\ndef bar_with_highlight(data_frame, highlight_country=None):  # (1)!\n    country_is_highlighted = data_frame[\"country\"] == highlight_country  # (2)!\n    fig = px.bar(\n        data_frame,\n        x=\"lifeExp\",\n        y=\"country\",\n        labels={\"lifeExp\": \"lifeExp in 2007\"},\n        color=country_is_highlighted,\n        category_orders={\"country\": sorted(data_frame[\"country\"]), \"color\": [False, True]},  # (3)!\n    )\n    fig.update_layout(showlegend=False)\n    return fig\n\n\npage = vm.Page(\n    title=\"Self-highlight a graph and cross-filter\",\n    components=[\n        vm.Graph(\n            id=\"bar_chart\",   # (4)!\n            figure=bar_with_highlight(gapminder.query(\"year == 2007\")),\n            header=\"💡 Click on a bar to highlight the selected country and filter the table below\",\n            actions=[\n                va.set_control(control=\"highlight_parameter\", value=\"y\"),   # (5)!\n                va.set_control(control=\"country_filter\", value=\"y\"),   # (6)!\n            ],\n        ),\n        vm.AgGrid(id=\"gapminder_table\", figure=dash_ag_grid(data_frame=gapminder)),   # (7)!\n    ],\n    controls=[\n        vm.Parameter(\n            id=\"highlight_parameter\",  # (8)!\n            targets=[\"bar_chart.highlight_country\"],  # (9)!\n            selector=vm.RadioItems(options=[\"NONE\", *gapminder[\"country\"]]),  # (10)!\n            visible=False,  # (11)!\n        ),\n        vm.Filter(id=\"country_filter\", column=\"country\", targets=[\"gapminder_table\"], visible=False),  # (12)!\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>The <code>highlight_country</code> argument receives the selected country name from <code>highlight_parameter</code>.</li> <li><code>country_is_highlighted</code> is a pandas Series that contains <code>True</code> for the highlighted country and <code>False</code> for all others. We use this to change the color of the highlighted bar.</li> <li>Order the bars according to the country alphabetically. We also make sure that the colors are always ordered the same way to ensure that the highlighted bar always has the same color.</li> <li>We give the <code>vm.Graph</code> an <code>id</code> so that it can be targeted by <code>highlight_parameter</code>.</li> <li>This <code>va.set_control</code> sets <code>higlight_parameter</code> to the country from the clicked bar.</li> <li>This <code>va.set_control</code> sets <code>country_filter</code> to the country from the clicked bar.</li> <li>We give the <code>vm.AgGrid</code> an <code>id</code> so that it can be targeted by <code>country_filter</code>.</li> <li>We give the parameter an <code>id</code> so that it can be set explicitly by <code>va.set_control</code>.</li> <li>The parameter targets the argument <code>highlight_country</code> of <code>vm.Graph(id=\"bar_chart\")</code>.</li> <li>We add <code>\"NONE\"</code> as an option, corresponding to a parameter value <code>highlight_country=None</code>. This is used so the bar chart is initially unhighlighted.</li> <li>We set <code>visible=False</code> to hide the parameter selector from the user interface while keeping the functionality active.</li> <li>Filter <code>gapminder_table</code> to show rows for only the selected country.</li> </ol> <pre><code># Still requires a .py to add data to the data manager, define CapturedCallables, and parse YAML configuration\n# More explanation in the docs on `Dashboard` and extensions.\npages:\n  - components:\n      - type: graph\n        id: bar_chart\n        figure:\n          _target_: __main__.bar_with_highlight\n          data_frame: gapminder_2007\n        header: 💡 Click on a bar to highlight the selected country and filter the table below\n        actions:\n          - type: set_control\n            control: highlight_parameter\n            value: y\n          - type: set_control\n            control: country_filter\n            value: y\n      - type: ag_grid\n        id: gapminder_table\n        figure:\n          _target_: dash_ag_grid\n          data_frame: gapminder\n    controls:\n      - id: highlight_parameter\n        selector:\n          options:\n            - NONE\n            - Cambodia\n            - Indonesia\n            - Malaysia\n            - Myanmar\n            - Philippines\n            - Singapore\n            - Thailand\n            - Vietnam\n          type: radio_items\n        targets:\n          - bar_chart.highlight_country\n        type: parameter\n        visible: false\n      - column: country\n        id: country_filter\n        targets:\n          - gapminder_table\n        type: filter\n        visible: false\n    title: Self-highlight a graph and cross-filter\n</code></pre> <p></p> <p>When you click on a bar in the chart, that bar is highlighted in orange and the table below is filtered to show only data for the selected country. Clicking the \"Reset controls\" button resets the parameter and the filter to their original values and hence clears the highlighting and filtering.</p> Behind the scenes mechanism <p>In full, what happens is as follows:</p> <ol> <li>Clicking on a bar triggers the <code>va.set_control</code> action. This uses the value of <code>y</code> (in other words, the country) taken from the source graph to set the value of the <code>vm.Parameter(id=\"highlight_parameter\")</code>.</li> <li>When the <code>highlight_parameter</code> has been set, the second <code>va.set_control</code> action runs. This also uses the value of <code>y</code> (in other words, the country) to set the selector underlying <code>vm.Filter(id=\"country_filter\")</code>.</li> <li>The change in value of <code>vm.Parameter(id=\"highlight_parameter\")</code> triggers the parameter to update the <code>highlight_country</code> argument of the target component <code>bar_chart</code> so that a highlighted graph is shown.</li> <li>The change in value of <code>vm.Filter(id=\"country_filter\")</code> triggers the filter on its <code>targets=[\"gapminder_table\"]</code> so that a filtered table is shown.</li> </ol> <p>The mechanism for triggering the parameter and filter when their values are set by <code>va.set_control</code> is an implicit actions chain, while the sequence of applying the two <code>va.set_control</code> is an explicit actions chain. In general, steps 2 and 3 above will execute in parallel.</p> <p>When performing multiple filters with dynamic data, you should consider configuring a cache so that steps 3 and 4 above do not repeatedly perform a slow data load.</p>","path":["Graph and table interactions"],"tags":[]},{"location":"user-guides/graph/","level":1,"title":"How to use graphs","text":"<p>This guide shows you how to use graphs to visualize your data in the dashboard.</p> <p>The [<code>Graph</code>][vizro.models.Graph] model is the most used component in many dashboards, allowing you to visualize data in a variety of ways. It is based on <code>dcc.Graph</code>.</p> <p>To add a [<code>Graph</code>][vizro.models.Graph] model to your page, do the following:</p> <ol> <li>insert a [<code>Graph</code>][vizro.models.Graph] model into the <code>components</code> argument of the [<code>Page</code>][vizro.models.Page] model</li> <li>enter any of the currently available charts of the open source library <code>plotly.express</code> into the <code>figure</code> argument</li> </ol> <p>Note</p> <p>To use the <code>plotly.express</code> chart in a Vizro dashboard, you need to import it as <code>import vizro.plotly.express as px</code>. This leaves any of the <code>plotly.express</code> functionality untouched yet enables direct insertion into the [<code>Graph</code>][vizro.models.Graph] model as is.</p> <p>Note also that the <code>plotly.express</code> chart needs to have a <code>data_frame</code> argument. In case you require a chart without a <code>data_frame</code> argument (for example, the <code>imshow</code> chart), refer to our guide on custom charts.</p>","path":["How to use graphs"],"tags":[]},{"location":"user-guides/graph/#insert-plotly-chart","level":2,"title":"Insert Plotly chart","text":"<p>Graph</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\ndf = px.data.iris()\n\npage = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Graph(\n            figure=px.scatter_matrix(\n                df, dimensions=[\"sepal_length\", \"sepal_width\", \"petal_length\", \"petal_width\"], color=\"species\"\n            ),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: scatter_matrix\n          color: species\n          data_frame: iris\n          dimensions: [sepal_length, sepal_width, petal_length, petal_width]\n        type: graph\n    title: My first page\n</code></pre> <p></p> <p>In the Python example we directly inserted the pandas DataFrame <code>df</code> into <code>figure=px.scatter_matrix(df, ...)</code>. This is one way to supply data to a chart. For the YAML version, we refer to the data source by name as <code>data_frame: iris</code>. For a full explanation of the different methods you can use to send data to your dashboard, see our guide to using data in Vizro.</p>","path":["How to use graphs"],"tags":[]},{"location":"user-guides/graph/#customize-plotly-chart","level":2,"title":"Customize Plotly chart","text":"<p>You will need to create a custom chart if you want to customize the Plotly chart beyond a function call, for example by:</p> <ul> <li>using post-update methods like <code>update_layout</code>, <code>update_xaxes</code>, <code>update_traces</code>, or</li> <li>by creating a custom <code>plotly.graph_objects.Figure()</code> object and manually adding traces with <code>add_trace</code>.</li> </ul> <p>For more details, refer to our user guide on custom chart and the Plotly documentation on updating figures.</p>","path":["How to use graphs"],"tags":[]},{"location":"user-guides/graph/#control-height-and-width-of-the-plotly-chart","level":3,"title":"Control height and width of the Plotly chart","text":"<p>By default, graphs in a flex-row layout have a width of 450px, regardless of available space.</p> <p>You can increase the width by providing a <code>width</code> argument in the <code>px</code> chart, but decreasing it below 450px requires specifying both <code>width</code> and <code>height</code>.</p> <p>Limitations of fixed dimensions</p> <p>Setting both <code>width</code> and <code>height</code> makes the chart use fixed, non-responsive dimensions. This can reduce flexibility in responsive layouts, may cause overflow on smaller screens, and can limit Plotly’s ability to automatically adjust the plot area or aspect ratio.</p>","path":["How to use graphs"],"tags":[]},{"location":"user-guides/graph/#interact-with-other-graphs-and-tables","level":2,"title":"Interact with other graphs and tables","text":"<p>A graph can act as a source for interactions with other components, for example to cross-filter another graph or table when the user clicks on a point.</p>","path":["How to use graphs"],"tags":[]},{"location":"user-guides/graph/#add-additional-text","level":2,"title":"Add additional text","text":"<p>The [<code>Graph</code>][vizro.models.Graph] model accepts <code>title</code>, <code>header</code>, <code>footer</code> and <code>description</code> arguments. These are useful for providing additional context on the chart.</p> <ul> <li>title: Displayed as an H3 header, useful for summarizing the main topic or insight of the component.</li> <li>header: Accepts Markdown text, ideal for extra descriptions, subtitles, or detailed data insights.</li> <li>footer: Accepts Markdown text, commonly used for citing data sources, providing information on the last update, or adding disclaimers.</li> <li>description: Displayed as an icon that opens a tooltip containing Markdown text when hovered over. You can provide a string to use the default info icon or a [<code>Tooltip</code>][vizro.models.Tooltip] model to use any icon from the Google Material Icons library.</li> </ul> <p>Use <code>Graph.title</code> instead of the Plotly Express chart title</p> <p>Although you can directly give a <code>title</code> to the Plotly Express chart, we recommend using <code>Graph.title</code> for proper alignment with other components on the screen.</p> <p>Formatted Graph</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"Formatted Graph\",\n    components=[\n        vm.Graph(\n            figure=px.scatter(iris, x=\"sepal_width\", y=\"sepal_length\", color=\"species\"),\n            title=\"Relationships between Sepal Width and Sepal Length\",\n            header=\"\"\"\n                Each point in the scatter plot represents one of the 150 iris flowers, with colors indicating their\n                types. The Setosa type is easily identifiable by its short and wide sepals.\n\n                However, there is still overlap between the Versicolor and Virginica types when considering only sepal\n                width and length.\n                \"\"\",\n            footer=\"\"\"SOURCE: **Plotly iris data set, 2024**\"\"\",\n            description=\"\"\"\n                The Iris dataset includes measurements of 150 iris flowers across three types: Setosa, Versicolor, and Virginica.\n\n                While all samples are labeled by type, they can appear similar when looking at just some features. It's a useful dataset for exploring patterns and challenges in classification.\n            \"\"\",\n        ),\n    ],\n)\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: scatter\n          x: sepal_width\n          y: sepal_length\n          color: species\n          data_frame: iris\n        title: Relationships between Sepal Width and Sepal Length\n        header: |\n          Each point in the scatter plot represents one of the 150 iris flowers, with colors indicating their\n          types. The Setosa type is easily identifiable by its short and wide sepals.\n\n          However, there is still overlap between the Versicolor and Virginica types when considering only sepal\n          width and length.\n        footer: |\n          SOURCE: **Plotly iris data set, 2024**\n        description: |\n          The Iris dataset includes measurements of 150 iris flowers across three types: Setosa, Versicolor, and Virginica.\n\n          While all samples are labeled by type, they can appear similar when looking at just some features. It's a useful dataset for exploring patterns and challenges in classification.\n        type: graph\n    title: Formatted Graph\n</code></pre> <p></p>","path":["How to use graphs"],"tags":[]},{"location":"user-guides/graph/#the-extra-argument","level":2,"title":"The <code>extra</code> argument","text":"<p>The <code>Graph</code> is based on the underlying Dash component <code>dcc.Graph</code>. Using the <code>extra</code> argument you can pass extra arguments to <code>dcc.Graph</code> in order to alter it beyond the chosen defaults.</p> <p>Note</p> <p>Using <code>extra</code> is a quick and flexible way to alter a component beyond what Vizro offers. However, it is not a part of the official Vizro schema and the underlying implementation details may change. If you want to guarantee that your apps keep running, we recommend that you pin your Vizro version.</p> <p>An example use would be to remove the plotly mode bar. For this, you can use <code>extra={\"config\": {\"displayModeBar\": False}}</code>.</p> <p>Graph with extra</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"Graph without ModeBar\",\n    components=[\n        vm.Graph(\n            figure=px.scatter(iris, x=\"sepal_width\", y=\"sepal_length\", color=\"species\"),\n            title=\"Relationships between Sepal Width and Sepal Length\",\n            extra={\"config\": {\"displayModeBar\": False}},\n        ),\n    ],\n)\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: scatter\n          x: sepal_width\n          y: sepal_length\n          color: species\n          data_frame: iris\n        title: Relationships between Sepal Width and Sepal Length\n        extra:\n          config:\n            displayModeBar: false\n        type: graph\n    title: Graph without ModeBar\n</code></pre> <p></p>","path":["How to use graphs"],"tags":[]},{"location":"user-guides/install/","level":1,"title":"Installation Guide for Vizro","text":"","path":["Installation Guide for Vizro"],"tags":[]},{"location":"user-guides/install/#overview","level":2,"title":"Overview","text":"<p>Welcome to Vizro! 👋 This guide will help you get started with installing and setting up Vizro for building interactive dashboards.</p> <p>You can use PyCafe to work with Vizro without installing it, as demonstrated in the first dashboard tutorial. Using PyCafe is a great way to try out Vizro quickly. For more information, see the PyCafe documentation.</p> <p>If you prefer to work locally, this guide will walk you through installing Vizro onto your machine. We'll also cover how to verify your installation and keep Vizro up to date.</p>","path":["Installation Guide for Vizro"],"tags":[]},{"location":"user-guides/install/#prerequisites","level":2,"title":"Prerequisites","text":"<p>Before installing Vizro, you'll need:</p> <ul> <li>Python 3.10 or later</li> <li>A virtual environment (recommended)</li> </ul> <p>For Python installation and virtual environment setup, refer to:</p> <ul> <li>Official Python Installation Guide - The best place to start if you're new to Python.</li> <li>Python Packaging Guide - Comprehensive guide on Python package management.</li> <li>Anaconda - A popular choice for Python installation and virtual environment management.</li> <li>uv - A modern, fast Python package installer and resolver.</li> </ul> <p>Use a virtual environment</p> <p>We strongly recommend using a virtual environment when working with Python packages to avoid dependency conflicts and keep your system Python clean. See the Python Packaging Guide for more information about creating virtual environments.</p>","path":["Installation Guide for Vizro"],"tags":[]},{"location":"user-guides/install/#installing-vizro","level":2,"title":"Installing Vizro","text":"","path":["Installation Guide for Vizro"],"tags":[]},{"location":"user-guides/install/#using-pip","level":3,"title":"Using pip","text":"<pre><code>pip install vizro\n</code></pre>","path":["Installation Guide for Vizro"],"tags":[]},{"location":"user-guides/install/#using-uv","level":3,"title":"Using uv","text":"<pre><code>uv pip install vizro\n</code></pre>","path":["Installation Guide for Vizro"],"tags":[]},{"location":"user-guides/install/#verifying-the-installation","level":2,"title":"Verifying the Installation","text":"<p>To make sure everything is working correctly, you can verify your installation and check the installed version:</p> <pre><code>import vizro\n\nprint(vizro.__version__)\n</code></pre> <p>You should see the version number displayed (e.g., <code>0.1.0</code>).</p>","path":["Installation Guide for Vizro"],"tags":[]},{"location":"user-guides/install/#upgrading","level":2,"title":"Upgrading","text":"<p>When new versions of Vizro are released, you can upgrade to use them with:</p> <pre><code>pip install -U vizro\n</code></pre> <p>Check Release Notes</p> <p>Before upgrading, we recommend checking the release notes for any breaking changes that might affect your existing dashboards.</p>","path":["Installation Guide for Vizro"],"tags":[]},{"location":"user-guides/install/#ide-support","level":2,"title":"IDE Support","text":"<p>Enable IDE autocompletion</p> <p>Vizro uses pydantic for configuration, which means you can get IDE support. To enable autocompletion and type hints, install:</p> <ul> <li>VS Code plugin</li> <li>PyCharm plugin</li> </ul> <p></p>","path":["Installation Guide for Vizro"],"tags":[]},{"location":"user-guides/kedro-data-catalog/","level":1,"title":"How to integrate Vizro with the Kedro Data Catalog","text":"<p>This page describes how to integrate Vizro with Kedro, an open-source Python framework to create reproducible, maintainable, and modular data science code. Vizro provides a convenient way to visualize Pandas datasets registered in a Kedro Data Catalog.</p> <p>Even if you do not have a Kedro project, you can still use a Kedro Data Catalog to manage your dashboard's data sources. This separates configuration of your data from your app's code and is particularly useful for dashboards with many data sources or more complex data loading configuration.</p>","path":["How to integrate Vizro with the Kedro Data Catalog"],"tags":[]},{"location":"user-guides/kedro-data-catalog/#installation","level":2,"title":"Installation","text":"<p>If you already have Kedro installed then you do not need to install any extra dependencies. If you do not have Kedro installed then you should run:</p> <pre><code>pip install vizro[kedro]\n</code></pre> <p>Vizro is currently compatible with <code>kedro&gt;=0.19.9</code> (including <code>kedro&gt;=1.0.0</code>).</p>","path":["How to integrate Vizro with the Kedro Data Catalog"],"tags":[]},{"location":"user-guides/kedro-data-catalog/#create-a-kedro-data-catalog","level":2,"title":"Create a Kedro Data Catalog","text":"<p>You can create a Kedro Data Catalog to be a YAML registry of your dashboard's data sources. To do so, create a new file called <code>catalog.yaml</code> file in the same directory as your <code>app.py</code>. Below is an example <code>catalog.yaml</code> file that illustrates some of the key features of the Kedro Data Catalog.</p> <pre><code>cars:  # (1)!\n  type: pandas.CSVDataset  # (2)!\n  filepath: cars.csv\n\nmotorbikes:\n  type: pandas.CSVDataset\n  filepath: s3://your_bucket/data/motorbikes.csv   # (3)!\n  load_args:   # (4)!\n    sep: ','\n    na_values: [NA]\n  credentials: s3_credentials  # (5)!\n\ntrains:\n  type: pandas.ExcelDataset\n  filepath: trains.xlsx\n  load_args:\n    sheet_name: [Sheet1, Sheet2, Sheet3]\n\ntrucks:\n  type: pandas.ParquetDataset\n  filepath: trucks.parquet\n  load_args:\n    columns: [name, gear, disp, wt]\n    categories: list\n    index: name\n</code></pre> <ol> <li>The minimum details needed for a Kedro Data Catalog entry are the data source name (<code>cars</code>), the type of data (<code>type</code>), and the file's location (<code>filepath</code>).</li> <li>Vizro supports all <code>kedro_datasets.pandas</code> datasets. This includes, for example, CSV, Excel and Parquet files.</li> <li>Kedro supports a variety of data stores including local file systems, network file systems and cloud object stores.</li> <li>You can pass data loading arguments to specify how to load the data source.</li> <li>You can securely inject credentials into data loading functions using a <code>credentials.yaml</code> file or environment variables.</li> </ol> <p>As shown below, the best way to use the <code>catalog.yaml</code> is with the Kedro configuration loader <code>OmegaConfigLoader</code>. For simple cases, this functions much like <code>yaml.safe_load</code>. However, the Kedro configuration loader also enables more advanced functionality.</p> Kedro configuration loader features <p>Here are a few features of the Kedro configuration loader which are not possible with a <code>yaml.safe_load</code> alone. For more details, refer to Kedro's documentation on advanced configuration.</p> <ul> <li>Configuration environments to organize settings that might be different between your different development and production environments. For example, you might have different s3 buckets for development and production data.</li> <li>Recursive scanning for configuration files to merge complex configuration that is split across multiple files and folders.</li> <li>Templating (variable interpolation) and dynamically computed values (resolvers).</li> </ul>","path":["How to integrate Vizro with the Kedro Data Catalog"],"tags":[]},{"location":"user-guides/kedro-data-catalog/#use-datasets-from-the-kedro-data-catalog","level":2,"title":"Use datasets from the Kedro Data Catalog","text":"<p>Vizro provides functions to help generate and process a Kedro Data Catalog in the module <code>vizro.integrations.kedro</code>. Given a Kedro <code>catalog</code>, the general pattern to add datasets to the Vizro data manager is:</p> <pre><code>from vizro.integrations import kedro as kedro_integration\nfrom vizro.managers import data_manager\n\n\nfor dataset_name, dataset_loader in kedro_integration.datasets_from_catalog(catalog).items():\n    data_manager[dataset_name] = dataset_loader\n</code></pre> <p>The code above registers all data sources of type <code>kedro_datasets.pandas</code> in the Kedro <code>catalog</code> with Vizro's <code>data_manager</code> . You can now reference the data source by name. For example, given the above <code>catalog.yaml</code> file, you could use the data source names <code>\"cars\"</code>, <code>\"motorbikes\"</code>, <code>\"trains\"</code>, and <code>\"trucks\"</code> with <code>px.scatter(\"cars\", ...)</code>.</p> <p>Note</p> <p>Data sources imported from Kedro in this way are dynamic data. This means that the data can be refreshed while your dashboard is running. For example, if you run a Kedro pipeline, the latest data is shown in the Vizro dashboard without restarting it.</p> <p>The <code>catalog</code> variable may have been created in a number of different ways:</p> <ol> <li>Data Catalog configuration file (<code>catalog.yaml</code>), created as described above. This generates a <code>catalog</code> variable independently of a Kedro project using <code>DataCatalog.from_config</code>.</li> <li>Kedro project path. Vizro exposes a helper function <code>catalog_from_project</code> to generate a <code>catalog</code> given the path to a Kedro project.</li> <li>Kedro Jupyter session. This automatically exposes <code>catalog</code>.</li> </ol> <p>The full code for these different cases is given below. If you have a full Kedro project then it is recommended to put your <code>app.py</code> file somewhere inside the Kedro project so that your <code>catalog</code> is automatically discovered. However, it is also possible to run a Vizro app that uses a Kedro project at an arbitrary path.</p> <p>Import a Kedro Data Catalog into the Vizro data manager</p> app.py (Data Catalog configuration file)app.py (Kedro project path)app.ipynb (Kedro Jupyter session) <pre><code>from kedro.config import OmegaConfigLoader\nfrom kedro.io import DataCatalog  # (1)!\n\nfrom vizro.integrations import kedro as kedro_integration\nfrom vizro.managers import data_manager\n\nconf_loader = OmegaConfigLoader(conf_source=\".\")  # (2)!\ncatalog = DataCatalog.from_config(conf_loader[\"catalog\"])  # (3)!\n\nfor dataset_name, dataset_loader in kedro_integration.datasets_from_catalog(catalog).items():\n    data_manager[dataset_name] = dataset_loader\n</code></pre> <ol> <li>For <code>kedro&lt;1.0.0</code>, Kedro's experimental <code>KedroDataCatalog</code> would also work.</li> <li>This loads and parses configuration in <code>catalog.yaml</code>. The argument <code>conf_source=\".\"</code> specifies that <code>catalog.yaml</code> is found in the same directory as <code>app.py</code> or a subdirectory beneath this level. In a more complex setup, this could include configuration environments, for example to organize configuration for development and production data sources.</li> <li>If you have credentials then these can be injected with <code>DataCatalog.from_config(conf_loader[\"catalog\"], conf_loader[\"credentials\"])</code>.</li> </ol> <pre><code>from vizro.integrations import kedro as kedro_integration\nfrom vizro.managers import data_manager\n\nproject_path = \"/path/to/kedro/project\"  # (1)!\ncatalog = kedro_integration.catalog_from_project(project_path)\n\n\nfor dataset_name, dataset_loader in kedro_integration.datasets_from_catalog(catalog).items():\n    data_manager[dataset_name] = dataset_loader\n</code></pre> <ol> <li><code>project_path</code> is an optional argument. If it is not specified then <code>catalog_from_project</code> attempts to find a Kedro project in the current directory or above. Hence if your <code>app.py</code> file lives somewhere inside the Kedro project, you do not need to specify <code>project_path</code>.</li> </ol> <pre><code>from vizro.managers import data_manager\n\n\nfor dataset_name, dataset_loader in kedro_integration.datasets_from_catalog(catalog).items():\n    data_manager[dataset_name] = dataset_loader\n</code></pre>","path":["How to integrate Vizro with the Kedro Data Catalog"],"tags":[]},{"location":"user-guides/kedro-data-catalog/#use-dataset-factories","level":3,"title":"Use dataset factories","text":"<p>To add datasets that are defined using a Kedro dataset factory, <code>datasets_from_catalog</code> needs to resolve dataset patterns against explicit datasets. Given a Kedro <code>pipelines</code> dictionary, you should specify a <code>pipeline</code> argument as follows:</p> <pre><code>kedro_integration.datasets_from_catalog(catalog, pipeline=pipelines[\"__default__\"])  # (1)!\n</code></pre> <ol> <li>You can specify the name of your pipeline, for example <code>pipelines[\"my_pipeline\"]</code>, or even combine multiple pipelines with <code>pipelines[\"a\"] + pipelines[\"b\"]</code>. The Kedro <code>__default__</code> pipeline is what runs by default with the <code>kedro run</code> command.</li> </ol> <p>The <code>pipelines</code> variable may have been created the following ways:</p> <ol> <li>Kedro project path. Vizro exposes a helper function <code>pipelines_from_project</code> to generate a <code>pipelines</code> given the path to a Kedro project.</li> <li>Kedro Jupyter session. This automatically exposes <code>pipelines</code>.</li> </ol> <p>The full code for these different cases is given below.</p> <p>Import a Kedro Data Catalog with dataset factories into the Vizro data manager</p> app.py (Kedro project path)app.ipynb (Kedro Jupyter session) <pre><code>from vizro.integrations import kedro as kedro_integration\nfrom vizro.managers import data_manager\n\n\nproject_path = \"/path/to/kedro/project\"  # (1)!\ncatalog = kedro_integration.catalog_from_project(project_path)\npipelines = kedro_integration.pipelines_from_project(project_path)\n\nfor dataset_name, dataset_loader in kedro_integration.datasets_from_catalog(\n    catalog, pipeline=pipelines[\"__default__\"]\n).items():\n    data_manager[dataset_name] = dataset_loader\n</code></pre> <ol> <li><code>project_path</code> is an optional argument. If it is not specified then <code>catalog_from_project</code> and <code>pipelines_from_project</code> attempt to find a Kedro project in the current directory or above. Hence if your <code>app.py</code> file lives somewhere inside the Kedro project, you do not need to specify <code>project_path</code>.</li> </ol> <pre><code>from vizro.managers import data_manager\n\n\nfor dataset_name, dataset_loader in kedro_integration.datasets_from_catalog(\n    catalog, pipeline=pipelines[\"__default__\"]\n).items():\n    data_manager[dataset_name] = dataset_loader\n</code></pre>","path":["How to integrate Vizro with the Kedro Data Catalog"],"tags":[]},{"location":"user-guides/layouts/","level":1,"title":"How to change the layout of your page","text":"<p>The [<code>Page</code>][vizro.models.Page] and [<code>Container</code>][vizro.models.Container] models accept a <code>layout</code> argument that enables custom arrangement of charts and components on the screen. This guide shows how to customize the <code>layout</code> with:</p> <ul> <li>a grid layout using the [<code>Grid</code>][vizro.models.Grid] model (the default if no <code>layout</code> is specified)</li> <li>a flexible box layout using the [<code>Flex</code>][vizro.models.Flex] model</li> </ul> <p>Note</p> <p>The <code>Grid</code> model used to be called <code>Layout</code>, and the name <code>Layout</code> will no longer exist in Vizro 0.2.0. See our full list of deprecations and breaking changes.</p>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#layout-options-grid-and-flex","level":2,"title":"Layout options: Grid and Flex","text":"<p>The <code>layout</code> argument enables you to choose between two layout models: [<code>Grid</code>][vizro.models.Grid] (default) and [<code>Flex</code>][vizro.models.Flex]. These models provide different ways to arrange components on the page.</p> <ul> <li>Grid layout: The <code>Grid</code> layout arranges components in a structured grid where rows and columns are explicitly defined. This layout is ideal for precise control over the placement of components.</li> <li>Flex layout: The <code>Flex</code> layout arranges components using a flexible box model, where items can grow, shrink, and wrap dynamically based on available space. This layout is ideal for responsive designs where components need to adapt to different screen sizes.</li> </ul> <p>The default layout</p> <p>The <code>layout</code> argument of a [<code>Page</code>][vizro.models.Page] model is optional. If no layout is specified, it will default to a grid layout - all charts/components are then automatically stacked vertically on the page in one column.</p> app.pyapp.yamlResult <pre><code>from vizro import Vizro\nimport vizro.models as vm\n\npage = vm.Page(\n    title=\"two_left\",\n    components=[vm.Card(text=\"\"\"# Component 0\"\"\"),\n                vm.Card(text=\"\"\"# Component 1\"\"\")]\n\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          # Component 0\n        type: card\n      - text: |\n          # Component 1\n        type: card\n    title: two_left\n</code></pre> <p></p>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#grid-layout","level":2,"title":"Grid Layout","text":"","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#configure-the-grid","level":3,"title":"Configure the grid","text":"<p>To customize the grid arrangement, configure the <code>grid</code> parameter of the [<code>Grid</code>][vizro.models.Grid] model.</p> <p>The example below shows an example of a valid <code>grid</code>:</p> Basic example<pre><code>grid = [[0, 1], [0, 2]]\n</code></pre> <ul> <li>The <code>grid</code> must be provided as <code>list[list[int]]</code> (for example, <code>grid = [[0, 1], [0, 2]]</code>).</li> <li>The integers in the <code>grid</code> must be consecutive integers starting with 0 (for example, <code>0</code>, <code>1</code>, <code>2</code>).<ul> <li>The integers correspond to the index of the chart/component inside the list of <code>components</code> provided to [<code>Page</code>][vizro.models.Page].</li> <li>The number of integers in the <code>grid</code> needs to match the number of chart/components provided.</li> </ul> </li> <li>Each sub-list corresponds to a grid row (in the example above, row 1 = <code>[0, 1]</code> and row 2 = <code>[0, 2]</code>)</li> <li>Each element inside the sub-list corresponds to a grid column (for example, column 1 = <code>[0, 0]</code> and column 2 = <code>[1, 2]</code>)</li> <li>Each chart/component will take the entire space of its grid area but you can use empty sections for extra separation.</li> <li>The area spanned by a chart/component in the grid must be rectangular.</li> <li>The grid can be arbitrarily large, allowing arbitrarily granular control of the grid.</li> </ul>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#understand-stacking-direction","level":3,"title":"Understand stacking direction","text":"<p>As described above, when no <code>layout</code> is specified, components are presented vertically as a single-column stack using the [<code>Grid</code>][vizro.models.Grid] model. If you have three components, the default <code>grid</code> will be as follows, with three equally sized rows, each containing a component spanning the entire width:</p> Vertical stacking<pre><code>grid = [[0], [1], [2]]\n</code></pre> <p>To present components horizontally in one row:</p> Horizontal stacking<pre><code>grid = [[0, 1, 2]]\n</code></pre> <p>This defines a single row that occupies the entire width and height, divided into three equal columns.</p> <p></p>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#grid-basic-example","level":3,"title":"Grid - basic example","text":"<p>Grid Arrangement - Basic Example</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"one_left_two_right\",\n    layout=vm.Grid(grid=[[0, 1],\n                         [0, 2]]),\n    components=[vm.Card(text=\"\"\"# Component 0\"\"\"),\n                vm.Card(text=\"\"\"# Component 1\"\"\"),\n                vm.Card(text=\"\"\"# Component 2\"\"\"),\n                ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          # Component 0\n        type: card\n      - text: |\n          # Component 1\n        type: card\n      - text: |\n          # Component 2\n        type: card\n    layout:\n      grid: [[0, 1], [0, 2]]\n      type: grid\n    title: one_left_two_right\n</code></pre> <p></p>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#grid-advanced-example","level":3,"title":"Grid - advanced example","text":"<p>If you need to divide the grid into subgrids for finer control or want to visually distinguish your subgrids, you can use <code>Containers</code>. See our section on when to use <code>Containers</code> vs. <code>Page.layout</code> for more information.</p> <p>The <code>Grid</code> provides full control over the arrangement of top-level components within a page, allowing arbitrarily granular control of the grid by creating larger grids.</p> <p>Grid Arrangement - Advanced Example</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\ngapminder = px.data.gapminder()\n\npage = vm.Page(\n    title=\"Custom Grid - Advanced Example\",\n    layout=vm.Grid(grid=[[0, 1, 3, 4],\n                         [2, 2, 3, 4]]),\n    components=[\n        vm.Graph(\n            figure=px.line(\n                gapminder,\n                title=\"Graph 1\",\n                x=\"year\",\n                y=\"lifeExp\",\n                color=\"continent\",\n            ),\n        ),\n        vm.Graph(\n            figure=px.scatter(\n                gapminder,\n                title=\"Graph 2\",\n                x=\"gdpPercap\",\n                y=\"lifeExp\",\n                size=\"pop\",\n                color=\"continent\",\n            ),\n        ),\n        vm.Graph(\n            figure=px.box(\n                gapminder,\n                title=\"Graph 3\",\n                x=\"continent\",\n                y=\"lifeExp\",\n                color=\"continent\",\n            ),\n        ),\n        vm.Graph(\n            figure=px.line(\n                gapminder,\n                title=\"Graph 4\",\n                x=\"year\",\n                y=\"lifeExp\",\n                color=\"continent\",\n            ),\n        ),\n        vm.Graph(\n            figure=px.scatter(\n                gapminder,\n                title=\"Graph 5\",\n                x=\"gdpPercap\",\n                y=\"lifeExp\",\n                size=\"pop\",\n                color=\"continent\",\n            ),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: line\n          data_frame: gapminder\n          x: year\n          y: lifeExp\n          color: continent\n          title: Graph 1\n        type: graph\n      - figure:\n          _target_: scatter\n          data_frame: gapminder\n          x: gdpPercap\n          y: lifeExp\n          size: pop\n          color: continent\n          title: Graph 2\n        type: graph\n      - figure:\n          _target_: box\n          data_frame: gapminder\n          x: continent\n          y: lifeExp\n          color: continent\n          title: Graph 3\n        type: graph\n      - figure:\n          _target_: line\n          data_frame: gapminder\n          x: year\n          y: lifeExp\n          color: continent\n          title: Graph 4\n        type: graph\n      - figure:\n          _target_: scatter\n          data_frame: gapminder\n          x: gdpPercap\n          y: lifeExp\n          size: pop\n          color: continent\n          title: Graph 5\n        type: graph\n    layout:\n      grid: [[0, 1, 3, 4], [2, 2, 3, 4]]\n      type: grid\n    title: Custom Grid - Advanced Example\n</code></pre> <p></p>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#cheatsheet-grid-examples","level":3,"title":"Cheatsheet - grid examples","text":"<p>Here is a reference table of example layouts:</p> <p>one row with one component, second row with two components stacked horizontally</p> Grid needed Grid Code <code>layout=vm.Grid(grid=[[0]])</code> <code>layout=vm.Grid(grid=[[0],[1]])</code> <code>layout=vm.Grid(grid=[[0,1]])</code> <code>layout=vm.Grid(grid=[[0],[1],[2]])</code> or  <code>layout=None</code> <code>layout=vm.Grid(grid=[[0,1],[0,2]])</code> <code>layout=vm.Grid(grid=[[0,0],[1,2]])</code> <code>layout=vm.Grid(grid=[[0,1],[2,2]])</code> <code>layout=vm.Grid(grid=[[0,1],[0,2],[0,3]])</code> <code>layout=vm.Grid(grid=[[0,1],[2,3]])</code> <code>layout=vm.Grid(grid=[[0,3],[1,3],[2,3]])</code> <code>layout=vm.Grid(grid=[[0,0,0],[1,2,3]])</code> <code>layout=vm.Grid(grid=[[0,1,2],[3,3,3]])</code>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#add-empty-sections","level":3,"title":"Add empty sections","text":"<p>One approach to organize the dashboard's layout involves integrating empty sections by specifying <code>-1</code> within the grid layout.</p> Example<pre><code>grid = [[0, 1, -1], [0, 2, -1]]\n</code></pre> <p>Adding Empty Spaces</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"Adding empty spaces\",\n    layout=vm.Grid(grid=[[0, 1, -1],\n                         [0, 2, -1]]),\n    components=[vm.Card(text=\"\"\"# Component 0\"\"\"),\n                vm.Card(text=\"\"\"# Component 1\"\"\"),\n                vm.Card(text=\"\"\"# Component 2\"\"\"),\n                ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          # Component 0\n        type: card\n      - text: |\n          # Component 1\n        type: card\n      - text: |\n          # Component 2\n        type: card\n    layout:\n      grid: [[0, 1, -1], [0, 2, -1]]\n      type: grid\n    title: Adding empty spaces\n</code></pre> <p></p>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#control-the-scroll-behavior","level":3,"title":"Control the scroll behavior","text":"<p>By default, the grid fits all charts/components on the screen. This can lead to distortions such that the chart/component looks squashed. To control the scroll behavior, you can specify the following:</p> <ul> <li><code>row_min_height</code>: Sets a chart/component's minimum height. Defaults to 0px.</li> <li><code>col_min_width</code>: Sets a chart/component's minimum width. Defaults to 0px.</li> </ul> <p>Activate Scrolling</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"Activate scrolling\",\n    layout=vm.Grid(\n        grid=[[i] for i in range(8)],\n        row_min_height=\"240px\"\n    ),\n    components=[vm.Card(text=\"\"\"# Component 0\"\"\"),\n                vm.Card(text=\"\"\"# Component 1\"\"\"),\n                vm.Card(text=\"\"\"# Component 2\"\"\"),\n                vm.Card(text=\"\"\"# Component 3\"\"\"),\n                vm.Card(text=\"\"\"# Component 4\"\"\"),\n                vm.Card(text=\"\"\"# Component 5\"\"\"),\n                vm.Card(text=\"\"\"# Component 6\"\"\"),\n                vm.Card(text=\"\"\"# Component 7\"\"\"),\n                ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          # Component 0\n        type: card\n      - text: |\n          # Component 1\n        type: card\n      - text: |\n          # Component 2\n        type: card\n      - text: |\n          # Component 2\n        type: card\n      - text: |\n          # Component 4\n        type: card\n      - text: |\n          # Component 5\n        type: card\n      - text: |\n          # Component 6\n        type: card\n      - text: |\n          # Component 7\n        type: card\n    layout:\n      grid: [[0], [1], [2], [3], [4], [5], [6], [7]]\n      row_min_height: 240px\n      type: grid\n    title: Activate scrolling\n</code></pre> <p></p>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#further-customization","level":3,"title":"Further customization","text":"<p>For further customization, such as changing the gap between row and column, refer to the documentation of the [<code>Grid</code>][vizro.models.Grid] model.</p>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#flex-layout","level":2,"title":"Flex Layout","text":"<p>The [Flex][vizro.models.Flex] layout offers a dynamic and flexible way to organize components within a page. Built on the CSS Flexbox (flexible box) concept, it is designed to create responsive layouts that adjust to varying screen sizes and available space.</p> <p>Unlike the Grid[vizro.models.Grid] layout, which uses a predefined row-and-column structure, the <code>Flex</code> layout provides greater flexibility by enabling components to resize, align, and position themselves dynamically based on the layout configuration.</p> <p>If you're new to Flexbox, we strongly recommend exploring An Interactive Guide to Flexbox.</p>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#flex-basic-example","level":3,"title":"Flex - basic example","text":"<p>To switch to a <code>Flex</code> layout, simply pass <code>vm.Flex()</code> to the <code>layout</code> argument of the [Page][vizro.models.Page] model. This replaces the default <code>Grid</code> layout with a <code>Flex</code> layout, where components (flex items) are arranged vertically (<code>direction=\"column\"</code>), remain on a single line (<code>wrap=False</code>), and have a default spacing (<code>gap=24px</code>) between them.</p> <p>Open the PyCafe link below to see how the <code>Flex</code> layout behaves. Unlike the <code>Grid</code> layout, the charts retain their original height and width and won’t be squeezed to fit on one page—a scrollbar appears instead. You can clearly see the difference by removing <code>layout=vm.Flex()</code> in your example or toggling between the two result screenshots below.</p> <p>Flex - basic example</p> app.pyapp.yamlResult - FlexResult - Grid <pre><code>import vizro.models as vm\nfrom vizro import Vizro\nimport vizro.plotly.express as px\n\ntips = px.data.tips()\n\npage = vm.Page(\n    title=\"Flex - basic example\",\n    layout=vm.Flex(),\n    components=[vm.Graph(figure=px.violin(tips, y=\"tip\", x=\"day\", color=\"day\")) for i in range(5)],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: violin\n          x: day\n          y: tip\n          color: day\n          data_frame: tips\n        type: graph\n      - figure:\n          _target_: violin\n          x: day\n          y: tip\n          color: day\n          data_frame: tips\n        type: graph\n      - figure:\n          _target_: violin\n          x: day\n          y: tip\n          color: day\n          data_frame: tips\n        type: graph\n      - figure:\n          _target_: violin\n          x: day\n          y: tip\n          color: day\n          data_frame: tips\n        type: graph\n      - figure:\n          _target_: violin\n          x: day\n          y: tip\n          color: day\n          data_frame: tips\n        type: graph\n    layout:\n      type: flex\n    title: Flex - basic example\n</code></pre> <p></p> <p></p>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#flex-advanced-example","level":3,"title":"Flex - advanced example","text":"<p>If you want to customize the default behavior, the [<code>Flex</code>][vizro.models.Flex] model enables you to configure three optional arguments:</p> <ul> <li><code>direction</code>: Defines the layout direction of the components within the flex container, determining whether they are arranged in rows or columns.</li> <li><code>gap</code>: Controls the spacing between components in the flex container, enabling you to set consistent horizontal and vertical spacing between items.</li> <li><code>wrap</code>: Determines whether components should wrap onto multiple lines or remain on a single line when there isn't enough space in the container.</li> </ul> <p>In this example, there isn’t enough space to fit all three graphs in a single row while preserving their original height and width. Since <code>wrap=True</code>, the layout automatically wraps the graphs onto a new row. If <code>wrap=False</code>, a horizontal scrollbar would appear instead. We've also set <code>direction=\"row\"</code> and <code>gap=\"40px\"</code>, so the items are laid out in a horizontal row with <code>40px</code> spacing between them.</p> <p>Flex - advanced example</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\nimport vizro.plotly.express as px\n\ntips = px.data.tips()\n\npage = vm.Page(\n    title=\"Flex - advanced example\",\n    layout=vm.Flex(direction=\"row\", gap=\"40px\", wrap=True),\n    components=[vm.Graph(figure=px.violin(tips, y=\"tip\", x=\"day\", color=\"day\")) for i in range(3)],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: violin\n          x: day\n          y: tip\n          color: day\n          data_frame: tips\n        type: graph\n      - figure:\n          _target_: violin\n          x: day\n          y: tip\n          color: day\n          data_frame: tips\n        type: graph\n      - figure:\n          _target_: violin\n          x: day\n          y: tip\n          color: day\n          data_frame: tips\n        type: graph\n    layout:\n      type: flex\n      direction: row\n      gap: 40px\n      wrap: true\n    title: Flex - advanced example\n</code></pre> <p></p>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#change-the-size-of-flex-items","level":3,"title":"Change the size of flex items","text":"<p>There may be times when resizing your flex items is necessary, such as when designing for different screen sizes or combining elements with diverse content types (e.g. charts, text, or images).</p> <p>You can achieve this by:</p> <ul> <li>either specifying the <code>width</code> and <code>height</code> directly on the components</li> <li>or by applying custom CSS</li> </ul>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#change-size-via-arguments","level":4,"title":"Change size via arguments","text":"<p>The syntax for setting <code>width</code> and <code>height</code> varies between components. Refer to the component's documentation for the correct syntax and usage, such as:</p> <ul> <li><code>Graph</code>: See the documentation on Plotly - Adjust Graph Size in Python. For example, <code>vm.Graph(figure=px.violin(..., width=300))</code>.</li> <li><code>AgGrid</code>: See the documentation on Dash - Change Grid Size. For example, <code>vm.AgGrid(figure=dash_ag_grid(tips, style={\"width\": 1000}))</code>.</li> <li><code>DataTable</code>: See the documentation on Dash - Setting Table Height. For example, <code>vm.Table(figure=dash_data_table(tips, style_table={\"width\": \"1000px\"}))</code>.</li> <li><code>Card</code>: See our documentation on Card - The extra argument. For example, <code>vm.Card(..., extra={\"style\": {\"height\": \"200px\"}})</code>.</li> </ul> <p>We will reuse the example from the previous section, but this time we set <code>width=400</code> within the Plotly function to control the graph width. This changes how many graphs can fit on a single row, as reducing the width allows more graphs to fit before wrapping to the next line. To see the difference in results, compare the screenshots from this section with those in the previous one.</p> <p>Change the width for Graph</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\nimport vizro.plotly.express as px\n\ntips = px.data.tips()\n\npage = vm.Page(\n    title=\"Change the width for Graph\",\n    layout=vm.Flex(direction=\"row\", gap=\"40px\", wrap=True),\n    components=[vm.Graph(figure=px.violin(tips, y=\"tip\", x=\"day\", color=\"day\", width=400)) for i in range(5)],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: violin\n          x: day\n          y: tip\n          color: day\n          data_frame: tips\n          width: 400\n        type: graph\n      - figure:\n          _target_: violin\n          x: day\n          y: tip\n          color: day\n          data_frame: tips\n          width: 400\n        type: graph\n      - figure:\n          _target_: violin\n          x: day\n          y: tip\n          color: day\n          data_frame: tips\n          width: 400\n        type: graph\n      - figure:\n          _target_: violin\n          x: day\n          y: tip\n          color: day\n          data_frame: tips\n          width: 400\n        type: graph\n      - figure:\n          _target_: violin\n          x: day\n          y: tip\n          color: day\n          data_frame: tips\n          width: 400\n        type: graph\n    layout:\n      type: flex\n      direction: row\n      gap: 40px\n      wrap: true\n    title: Change the width for Graph\n</code></pre> <p></p>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#change-size-via-css","level":4,"title":"Change size via CSS","text":"<p>Custom CSS is often a preferred choice over using component arguments for setting sizes when you need to apply a consistent <code>height</code> and/or <code>width</code> across multiple elements, as it doesn't require repeating code. This is especially helpful for ensuring uniform sizing of all flex items.</p> <p>Each item within the <code>Flex</code> layout is wrapped in a <code>&lt;div class=\"flex-item\"&gt;</code>, which can be targeted with CSS. To learn how to identify the correct selectors, refer to our user guide on custom CSS.</p> <p>Change the width of all flex items with CSS</p> my_css_file.cssapp.pyResult <pre><code>/* Apply styling to all flex items */\n#page-with-uniform-flex-items .flex-item {\n    width: 260px;\n}\n</code></pre> <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    id=\"page-with-uniform-flex-items\",\n    title=\"Change the width via CSS\",\n    layout=vm.Flex(direction=\"row\", wrap=True),\n    components=[\n        vm.Card(\n            text=\"\"\"\n               # Lorem Ipsum\n\n               Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam sed elementum ligula.\n               In ultricies est ac mauris vehicula fermentum. Curabitur faucibus elementum lectus.\n               Name ut ipsum tortor. Praesent ut nulla risus. Praesent in dignissim nulla.\n           \"\"\"\n        )\n        for i in range(12)\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\n</code></pre> <p>Run and edit this code in PyCafe</p> <p></p>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#combine-flex-and-grid","level":3,"title":"Combine Flex and Grid","text":"<p>You can also combine the <code>Flex</code> and <code>Grid</code> layout to benefit from both. The <code>Grid</code> layout is ideal for defining the overall page structure, while the <code>Flex</code> layout enables flexibility within individual sections.</p> <p>For example, in the layout below, we use the <code>Grid</code> layout to arrange two charts at the top and a [<code>Container</code>][vizro.models.Container] at the bottom with multiple cards. Within the [<code>Container</code>][vizro.models.Container], we apply the <code>Flex</code> layout so that the cards automatically adjust their positioning based on the available space. If you have not worked with a <code>Container</code> before, refer to our user guide on how to use <code>Container</code>.</p> <p>Grid with Flex container</p> app.pyResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\ntips = px.data.tips()\n\npage = vm.Page(\n    title=\"Combine Flex and Grid\",\n    layout=vm.Grid(grid=[[0, 1], [2, 2]]),\n    components=[\n        vm.Graph(figure=px.violin(tips, y=\"tip\", x=\"day\", color=\"day\", box=True)),\n        vm.Graph(figure=px.histogram(tips, x=\"total_bill\")),\n        vm.Container(\n            title=\"Flexbox with Cards\",\n            layout=vm.Flex(direction=\"row\", wrap=True),\n            components=[\n                vm.Card(\n                    text=\"\"\"\n                            # Lorem Ipsum\n\n                            Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam sed elementum ligula, in pharetra velit.\n                            In ultricies est ac mauris vehicula fermentum. Curabitur faucibus elementum lectus, vitae luctus libero fermentum.\n                            Name ut ipsum tortor. Praesent ut nulla risus. Praesent in dignissim nulla. In quis blandit ipsum.\n                        \"\"\",\n                    extra={\"style\": {\"width\": \"240px\"}},\n                )\n                for i in range(6)\n            ],\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <p></p>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/layouts/#alternative-layout-approaches","level":2,"title":"Alternative layout approaches","text":"<p>In general, any arbitrarily granular layout can already be achieved using either the [<code>Grid</code>][vizro.models.Grid] (default) and/or the [<code>Flex</code>][vizro.models.Flex] model and is our recommended approach if you want to arrange components on a page with consistent row and column spacing.</p> <p>Alternative layout approaches: <code>Tabs</code> and <code>Containers</code></p> <p>Tabs and Containers provide alternative methods for customizing your page layout. For instance, if you need more granular control, want to break the overall page grid into subgrids, or wish to visually distinguish your subgrid, you may want to use one of these components.</p> <p></p>","path":["How to change the layout of your page"],"tags":[]},{"location":"user-guides/navigation/","level":1,"title":"How to configure dashboard navigation","text":"<p>This guide shows you how to use and customize the navigation that appears on the left of your dashboard.</p> <p>The [<code>Dashboard</code>][vizro.models.Dashboard] model accepts a <code>navigation</code> argument, where you can enter a [<code>Navigation</code>][vizro.models.Navigation] model. This enables you to group pages together and customize how they appear in your navigation. The dashboard includes a collapsible side panel that users can minimize or expand by a button click. The collapse button, located in the top right corner of the side panel, is visible by default for user convenience.</p>","path":["How to configure dashboard navigation"],"tags":[]},{"location":"user-guides/navigation/#use-the-default-navigation","level":2,"title":"Use the default navigation","text":"<p>By default, if the <code>navigation</code> argument is not specified, Vizro creates a navigation panel which lists all the pages in your dashboard into a collapsible accordion menu with title <code>Select Page</code>.</p> <p>Default navigation</p> app.pyapp.yamlResult <pre><code>from vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\niris = px.data.iris()\n\npage_1 = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\npage_2 = vm.Page(\n    title=\"My second page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\npage_3 = vm.Page(\n    title=\"My third page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page_1, page_2, page_3])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: My text here\n        type: card\n    title: My first page\n  - components:\n      - text: My text here\n        type: card\n    title: My second page\n  - components:\n      - text: My text here\n        type: card\n    title: My third page\n</code></pre> <p></p>","path":["How to configure dashboard navigation"],"tags":[]},{"location":"user-guides/navigation/#include-a-subset-of-pages","level":2,"title":"Include a subset of pages","text":"<p>To include only some of the dashboard pages in the navigation, list them in the <code>pages</code> argument of the <code>Navigation</code> model. To refer to a page inside the <code>Navigation</code> model, you should always use the page's <code>id</code> or <code>title</code>. If you have duplicate titles, use the <code>id</code> to refer to the page.</p> <p>Navigation with only some pages</p> app.pyapp.yamlResult <pre><code>from vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\niris = px.data.iris()\n\npage_1 = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\npage_2 = vm.Page(\n    title=\"My second page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\npage_3 = vm.Page(\n    title=\"My third page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\n\ndashboard = vm.Dashboard(\n    pages=[page_1, page_2, page_3],\n    navigation=vm.Navigation(pages=[\"My first page\", \"My second page\"])\n)\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\n# pages defined as in default example\nnavigation:\n  pages:\n    - My first page\n    - My second page\n</code></pre> <p></p>","path":["How to configure dashboard navigation"],"tags":[]},{"location":"user-guides/navigation/#group-pages","level":2,"title":"Group pages","text":"<p>You can also group your pages together by specifying <code>pages</code> as a dictionary:</p> <p>Grouping pages</p> app.pyapp.yamlResult <pre><code>from vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\niris = px.data.iris()\n\npage_1 = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\npage_2 = vm.Page(\n    title=\"My second page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\npage_3 = vm.Page(\n    title=\"My third page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\n\ndashboard = vm.Dashboard(\n    pages=[page_1, page_2, page_3],\n    navigation=vm.Navigation(\n        pages={\n            \"Group A\": [\"My first page\", \"My second page\"],\n            \"Group B\": [\"My third page\"]\n        }\n    ),\n)\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\n# pages defined as in default example\nnavigation:\n  pages:\n    Group A:\n      - My first page\n      - My second page\n    Group B:\n      - My third page\n</code></pre> <p></p>","path":["How to configure dashboard navigation"],"tags":[]},{"location":"user-guides/navigation/#use-a-navigation-bar-with-icons","level":2,"title":"Use a navigation bar with icons","text":"<p>Another way to group together pages in the navigation is to use a [<code>NavBar</code>][vizro.models.NavBar] model with icons. The simplest way to use this is to change the <code>nav_selector</code> specified in the [<code>Navigation</code>][vizro.models.Navigation] model:</p> <p>Using <code>NavBar</code></p> app.pyapp.yamlResult <pre><code>from vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\niris = px.data.iris()\n\npage_1 = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\npage_2 = vm.Page(\n    title=\"My second page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\npage_3 = vm.Page(\n    title=\"My third page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\n\ndashboard = vm.Dashboard(\n    pages=[page_1, page_2, page_3],\n    navigation=vm.Navigation(\n        pages={\n            \"Group A\": [\"My first page\", \"My second page\"],\n            \"Group B\": [\"My third page\"]\n        },\n        nav_selector=vm.NavBar()\n    ),\n)\n\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\n# pages defined as in default example\nnavigation:\n  pages:\n    Group A:\n      - My first page\n      - My second page\n    Group B:\n      - My third page\n  nav_selector:\n    type: nav_bar\n</code></pre> <p></p> <p>Here, the first level of the navigation hierarchy (\"Group A\" and \"Group B\") is represented by an icon in a navigation bar, and the second level of the navigation (the pages) is represented by an accordion. By default, the set of icons used are the <code>filter</code> icons from the Google Material icons library. The icon label (\"Group A\" and \"Group B\") appears as a tooltip on hovering over the icon.</p>","path":["How to configure dashboard navigation"],"tags":[]},{"location":"user-guides/navigation/#customize-the-navigation-bar","level":2,"title":"Customize the navigation bar","text":"<p>Under the hood, the [<code>NavBar</code>][vizro.models.NavBar] model uses a [<code>NavLink</code>][vizro.models.NavLink] to build the icons in the navigation bar. It is possible to customize the navigation further by providing the <code>NavLink</code> models yourself.</p>","path":["How to configure dashboard navigation"],"tags":[]},{"location":"user-guides/navigation/#customize-navlinks","level":3,"title":"Customize NavLinks","text":"<p>The same configuration for grouping pages applies inside a <code>NavLink</code>:</p> <p>Accordions inside a <code>Navlink</code></p> app.pyapp.yamlResult <pre><code>from vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\niris = px.data.iris()\n\npage_1 = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Graph(figure=px.scatter(iris, x=\"sepal_length\", y=\"petal_width\", color=\"species\")),\n    ],\n)\npage_2 = vm.Page(\n    title=\"My second page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\npage_3 = vm.Page(\n    title=\"My third page\",\n    components=[\n        vm.Graph(figure=px.scatter(iris, x=\"sepal_length\", y=\"sepal_width\", color=\"species\")),\n    ],\n)\n\ndashboard = vm.Dashboard(\n    pages=[page_1, page_2, page_3],\n    navigation=vm.Navigation(\n        nav_selector=vm.NavBar(\n            items=[\n                vm.NavLink(\n                    label=\"Section 1\",\n                    pages={\n                        \"Group A\": [\"My first page\", \"My second page\"],\n                        \"Group B\": [\"My third page\"]\n                    },\n                )\n            ]\n        )\n    ),\n)\n\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\n# pages defined as in default example\nnavigation:\n  nav_selector:\n    type: nav_bar\n    items:\n      - label: Section 1\n        pages:\n          Group A:\n            - My first page\n            - My second page\n          Group B:\n            - My third page\n</code></pre> <p></p>","path":["How to configure dashboard navigation"],"tags":[]},{"location":"user-guides/navigation/#change-icons","level":3,"title":"Change icons","text":"<p>You can alter the icons used by specifying the name of the icon in the Google Material icons library:</p> <p>Custom icon</p> app.pyapp.yamlResult <pre><code>from vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\niris = px.data.iris()\n\npage_1 = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\npage_2 = vm.Page(\n    title=\"My second page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\npage_3 = vm.Page(\n    title=\"My third page\",\n    components=[\n        vm.Card(text=\"My text here\"),\n    ],\n)\n\ndashboard = vm.Dashboard(\n    pages=[page_1, page_2, page_3],\n    navigation=vm.Navigation(\n        nav_selector=vm.NavBar(\n            items=[\n                vm.NavLink(\n                    label=\"Section 1\",\n                    icon=\"Bar Chart\",\n                    pages=[\"My first page\", \"My second page\"],\n                ),\n                vm.NavLink(\n                    label=\"Section 2\",\n                    icon=\"Pie Chart\",\n                    pages=[\"My third page\"]\n                ),\n            ]\n        )\n    ),\n)\n\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\n# pages defined as in default example\nnavigation:\n  nav_selector:\n    type: nav_bar\n    items:\n      - label: Section 1\n        icon: Bar Chart\n        pages:\n          - My first page\n          - My second page\n      - label: Section 1\n        icon: Pie Chart\n        pages:\n          - My third page\n</code></pre> <p></p>","path":["How to configure dashboard navigation"],"tags":[]},{"location":"user-guides/pages/","level":1,"title":"How to make dashboard pages","text":"<p>This guide shows you how to add pages to your dashboard and customize the URL paths if needed. A [<code>Page</code>][vizro.models.Page] model enables you to:</p> <ul> <li>place and arrange your dashboard content (for example, chart/components, tables, and text), and</li> <li>configure your dashboard interactions (such as filters and parameters).</li> </ul> <p>The [<code>Dashboard</code>][vizro.models.Dashboard] model accepts the <code>pages</code> argument, where you can insert your [<code>Page</code>][vizro.models.Page] model.</p>","path":["How to make dashboard pages"],"tags":[]},{"location":"user-guides/pages/#create-a-page","level":2,"title":"Create a page","text":"<p>A [<code>Page</code>][vizro.models.Page] splits into four main containers:</p> <ol> <li>The navigation container where you can customize your <code>navigation</code> (see Dashboard and Navigation for more information). Note that the navigation container needs to be configured via the Dashboard.</li> <li>The control container where you can add your <code>controls</code> (see Filters or Parameters) to interact with the dashboard</li> <li>The page header that contains the page title and the theme toggle switch button</li> <li>The component container where you can add your components to visualize your data</li> </ol> <p></p> <p>To create and add a page to your dashboard, do the following steps:</p> <ol> <li>Set a <code>title</code> for your [<code>Page</code>][vizro.models.Page] model (which does not have to be unique)</li> <li>Configure your <code>components</code>, see our guide on the various options</li> <li>(optional) Configure your <code>controls</code> , see our guides on Filters and Parameters</li> <li>(optional) Configure your <code>layout</code> , see our guide on Layouts</li> <li>(optional) Set a <code>description</code> for your page to add a tooltip and set meta tags</li> </ol> <p>Page</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\ngapminder = px.data.gapminder().query(\"year == 2007\")\n\npage = vm.Page(\n    title=\"Page Title\",\n    description=\"Longer description of the page content\",\n    components=[\n        vm.Graph(\n            id=\"sunburst\", figure=px.sunburst(gapminder, path=[\"continent\", \"country\"], values=\"pop\", color=\"lifeExp\")\n        )\n    ],\n    controls=[\n        vm.Filter(column=\"continent\"),\n        vm.Parameter(targets=[\"sunburst.color\"], selector=vm.RadioItems(options=[\"lifeExp\", \"pop\"], title=\"Color\")),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: sunburst\n          path: [continent, country]\n          values: pop\n          color: lifeExp\n          data_frame: gapminder\n        id: sunburst\n        type: graph\n    controls:\n      - column: continent\n        type: filter\n      - selector:\n          options: [lifeExp, pop]\n          title: Color\n          type: radio_items\n        targets: [sunburst.color]\n        type: parameter\n    title: Page Title\n    description: Longer description of the page content\n</code></pre> <p></p> <p>An accordion page selector is automatically added to your dashboard in the top-left of the control container for through the different pages. It will not be added if your dashboard consists of only one page.</p> <p>You can also navigate through the different pages by going directly to the relevant page URL (more details in next section).</p>","path":["How to make dashboard pages"],"tags":[]},{"location":"user-guides/pages/#customize-the-page-url","level":2,"title":"Customize the page URL","text":"<p>The page URL is generated based on the following order of preference:</p> <ol> <li><code>path</code> argument</li> <li><code>id</code> of the page (if explicitly set by the user)</li> <li><code>title</code> argument</li> </ol> <p>For example, if <code>title=\"This is my first page\"</code> (and neither <code>path</code> nor <code>id</code> is explicitly set) the generated page URL will be <code>path=this-is-my-first-page</code>. You can then access the page via <code>localhost:&lt;port_number&gt;/this-is-my-first-page</code>.</p> <p>You cannot have duplicate <code>path</code> values, whether explicitly set or generated.</p> <p>The first page always has the URL prefix <code>/</code> assigned. A custom URL can, therefore, not be created for the first page.</p> <p>To customize the page URL, pass a valid URL name to the <code>path</code> argument of [<code>Page</code>][vizro.models.Page] model:</p> <p>Page</p> app.pyapp.yaml <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\ngapminder = px.data.gapminder().query(\"year == 2007\")\n\npage1 = vm.Page(\n    title=\"Page 1\",\n    components=[\n        vm.Card(\n            text=\"\"\"Commodi repudiandae consequuntur voluptatum.\"\"\",\n        ),\n    ],\n)\n\npage2 = vm.Page(\n    title=\"Page 2\",\n    path=\"my-custom-url\",\n    components=[\n        vm.Graph(\n            id=\"sunburst\", figure=px.sunburst(gapminder, path=[\"continent\", \"country\"], values=\"pop\", color=\"lifeExp\")\n        )\n    ],\n    controls=[\n        vm.Filter(column=\"continent\"),\n        vm.Parameter(targets=[\"sunburst.color\"], selector=vm.RadioItems(options=[\"lifeExp\", \"pop\"], title=\"Color\")),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page1, page2])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          Commodi repudiandae consequuntur voluptatum.\n        type: card\n    title: Page 1\n  - components:\n      - figure:\n          _target_: sunburst\n          path: [continent, country]\n          values: pop\n          color: lifeExp\n          data_frame: gapminder\n        id: sunburst\n        type: graph\n    controls:\n      - column: continent\n        type: filter\n      - selector:\n          options: [lifeExp, pop]\n          title: Color\n          type: radio_items\n        targets: [sunburst.color]\n        type: parameter\n    title: Page 2\n    path: my-custom-url\n</code></pre> <p>You can now access the first page via <code>localhost:&lt;port_number&gt;/</code> and the second page via <code>localhost:&lt;port_number&gt;/my-custom-url</code>.</p>","path":["How to make dashboard pages"],"tags":[]},{"location":"user-guides/parameters/","level":1,"title":"How to use parameters","text":"<p>This guide shows you how to add parameters to your dashboard. A parameter sets any argument other than <code>data_frame</code> in the <code>figure</code> function of a component. For example, a user could select using a dropdown which variable is plotted on the x-axis of a graph. Parameters can also be used to set dynamic data parameters. The following components are reactive to parameters:</p> <ul> <li>built-in graphs and custom graphs</li> <li>built-in tables and custom tables</li> <li>built-in figures and custom figures</li> </ul> <p>It is possible to add parameters to a page or container. Both the [<code>Page</code> model][vizro.models.Page] and the [<code>Container</code> model][vizro.models.Container] have an optional <code>controls</code> argument where you can give any number of controls including parameters.</p> <p>When the dashboard is running there are two ways for a user to set a parameter:</p> <ul> <li>Direct user interaction with the underlying selector. For example, the user selects values from a checklist.</li> <li>User interaction with a graph or table via the [<code>set_control</code> action][vizro.actions.set_control]. This enables functionality such as cross-highlighting. To achieve a visually cleaner dashboard you might like to hide the parameter's underlying selector with <code>visible=False</code>.</li> </ul>","path":["How to use parameters"],"tags":[]},{"location":"user-guides/parameters/#basic-parameters","level":2,"title":"Basic parameters","text":"<p>To add a parameter to your page, do the following:</p> <ol> <li>add the [<code>Parameter</code>][vizro.models.Parameter] model into the <code>controls</code> argument of the [<code>Page</code>][vizro.models.Page] model.</li> <li>add the <code>targets</code> argument</li> <li>add a selector model to the <code>selector</code> argument.</li> </ol> <p>In the <code>targets</code> argument, you can specify the component and function argument that the parameter should be applied to in the form of <code>&lt;target_component_id&gt;.&lt;target_argument&gt;</code> (for example, <code>scatter_chart.title</code>).</p> <p>Unlike for the [<code>Filter</code>][vizro.models.Filter] model, you also have to configure the <code>selector</code> argument, by providing it with an appropriate model and the desired options/numeric ranges.</p> <p>Basic Parameter</p> app.pyapp.yamlResult <pre><code>from vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Graph(\n            id=\"scatter_chart\",\n            figure=px.scatter(iris, title=\"My scatter chart\", x=\"sepal_length\", y=\"petal_width\", color=\"species\"),\n        ),\n    ],\n    controls=[\n        vm.Parameter(\n            targets=[\"scatter_chart.title\"],\n            selector=vm.Dropdown(\n                options=[\"My scatter chart\", \"A better title!\", \"Another title...\"],\n                multi=False,\n            ),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: scatter\n          data_frame: iris\n          x: sepal_length\n          y: petal_width\n          color: species\n        id: scatter_chart\n        type: graph\n    controls:\n      - selector:\n          options: [My scatter chart, A better title!, Another title...]\n          multi: false\n          type: dropdown\n        targets:\n          - scatter_chart.title\n        type: parameter\n    title: My first page\n</code></pre> <p></p> <p>If you would like to pass <code>None</code> as a parameter and make a parameter optional, you can specify the string <code>\"NONE\"</code> in the <code>options</code> or <code>value</code> field.</p>","path":["How to use parameters"],"tags":[]},{"location":"user-guides/parameters/#nested-parameters","level":2,"title":"Nested parameters","text":"<p>If you want to change nested parameters, you can specify the <code>targets</code> argument with a dot separated string like <code>&lt;target_component_id&gt;.&lt;target_argument&gt;.&lt;first_hierarchy&gt;</code>.</p> <p>Nested Parameters for multiple targets</p> app.pyapp.yamlResult <pre><code>from vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Graph(\n            id=\"scatter_chart\",\n            figure=px.scatter(\n                iris,\n                x=\"sepal_width\",\n                y=\"sepal_length\",\n                color=\"species\",\n                size=\"petal_length\",\n                color_discrete_map={\"setosa\": \"#00b4ff\", \"versicolor\": \"#ff9222\"},\n            ),\n        ),\n        vm.Graph(\n            id=\"bar_chart\",\n            figure=px.bar(\n                iris,\n                x=\"sepal_width\",\n                y=\"sepal_length\",\n                color=\"species\",\n                color_discrete_map={\"setosa\": \"#00b4ff\", \"versicolor\": \"#ff9222\"},\n            ),\n        ),\n    ],\n    controls=[\n        vm.Parameter(\n            targets=[\"scatter_chart.color_discrete_map.virginica\", \"bar_chart.color_discrete_map.virginica\"],\n            selector=vm.Dropdown(\n                options=[\"#ff5267\", \"#3949ab\"],\n                multi=False,\n                value=\"#3949ab\",\n            ),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: scatter\n          data_frame: iris\n          x: sepal_width\n          y: sepal_length\n          size: petal_length\n          color: species\n          color_discrete_map: {setosa: '#00b4ff', versicolor: '#ff9222'}\n        id: scatter_chart\n        type: graph\n      - figure:\n          _target_: bar\n          data_frame: iris\n          x: sepal_width\n          y: sepal_length\n          color: species\n          color_discrete_map: {setosa: '#00b4ff', versicolor: '#ff9222'}\n        id: bar_chart\n        type: graph\n    controls:\n      - selector:\n          options: ['#ff5267', '#3949ab']\n          value: #3949ab\n          multi: false\n          type: dropdown\n        targets:\n          - scatter_chart.color_discrete_map.virginica\n          - bar_chart.color_discrete_map.virginica\n        type: parameter\n    title: My first page\n</code></pre> <p></p> <p>In the above example, the object passed to the function argument <code>color_discrete_map</code> is a dictionary which maps the different flower species to fixed colors (for example, <code>{\"virginica\":\"blue\"}</code>). In this case, only the value <code>blue</code> should be changed instead of the entire dictionary. This can be achieved by specifying a target as <code>scatter.color_discrete_map.virginica</code>.</p> <p>Note that in the above example, one parameter affects multiple targets.</p>","path":["How to use parameters"],"tags":[]},{"location":"user-guides/parameters/#dynamic-data-parameters","level":2,"title":"Dynamic data parameters","text":"<p>If you use dynamic data that can be updated while the dashboard is running then you can pass parameters to the dynamic data function to alter the data loaded into your dashboard. For detailed instructions, refer to the section on parametrized data loading.</p>","path":["How to use parameters"],"tags":[]},{"location":"user-guides/parameters/#further-customization","level":2,"title":"Further customization","text":"<p>For further customizations, refer to the guide to selectors and the [<code>Parameter</code> model][vizro.models.Parameter]. Some popular choices are:</p> <ul> <li>Customize the <code>selector</code>. For example: <code>multi</code>, to switch between a multi-option and single-option selector; <code>options</code> for a categorical parameter; or <code>min</code> and <code>max</code> for a numerical parameter.</li> <li>Make the parameter's selector invisible by setting <code>visible=False</code>. This is particularly useful for graph interactions to hide the selector from the user interface while keeping the functionality active. Cross-highlighting is a common example of this pattern. For a complete code example, see the cross-highlighting section in the graph and table interactions guide.</li> </ul>","path":["How to use parameters"],"tags":[]},{"location":"user-guides/run-deploy/","level":1,"title":"How to run and/or deploy your dashboard","text":"<p>Typically when you create a dashboard, there are two distinct stages:</p> <ol> <li>Development. This is when you build your dashboard. You make frequent changes to your code and want a simple way to see how it looks after each change. At this point, you may, or may not, want to make it possible for other people to access your dashboard.</li> <li>Production. When you complete development, you deploy it to production to make it accessible to other people.</li> </ol> <p>This guide describes methods to run your dashboard in development and in production. Follow either section based on your current need.</p> <p>If your data sources in development and production are different (for example, you have different s3 buckets for development and production data) then you might like to use the Kedro Data Catalog to manage your data source configuration.</p> <p>Vizro is built on top of Dash, which itself uses Flask. Most of our guidance on how to run a Vizro app in development or production is very similar to guidance on Dash and Flask.</p> <p>Note</p> <p>There are many possible workflows depending on your requirements. We are considering a simple workflow that applies to many people but is not suitable for everyone. For example:</p> <ul> <li>If you are the only user of your app then the process is often simpler since you might never want to deploy to production.</li> <li>If there are multiple people involved with development then you will need some way to coordinate code changes, such as a GitHub repository or Hugging Face Space.</li> <li>You might want to use authentication to restrict access to your app.</li> <li>You might want to update your dashboard after it has been put into production. There is then a cycle of repeated development and deployment.</li> <li>There might be more stages or environments for Quality Assurance (QA) to test that the app works correctly before it is deployed.</li> </ul>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#development","level":2,"title":"Development","text":"<p>When developing a dashboard, you have several options on how to get started as the table below describes. Clicking the links will lead you to the relevant docs section explaining more. The fastest way to run a dashboard is to use PyCafe, as shown in our First Dashboard tutorial.</p> Method Description Requires Python script Run a local Python script using a Flask development server Local Python Jupyter Run a cell in a Notebook using a Flask development server Local Python, Jupyter/JupyterLab PyCafe Run code in your browser using WebAssembly No requirements","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#develop-in-python-script","level":3,"title":"Develop in Python script","text":"<p>The most common way to run your dashboard in development is to run it locally (on your own computer) using the Flask development server.</p> <ol> <li>Create a Python file named <code>app.py</code> that ends with the line <code>Vizro().build(dashboard).run()</code>.</li> <li>Run the command <code>python app.py</code> in your terminal.</li> <li>Go to http://127.0.0.1:8050/ to see your app.</li> </ol> <pre><code>from vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Graph(figure=px.scatter(iris, x=\"sepal_length\", y=\"petal_width\", color=\"species\")),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <p>The <code>run</code> method wraps Dash's run method, and all arguments are passed through to Dash. Particularly useful ones are:</p> <ul> <li><code>port</code>. If not specified, this defaults to <code>8050</code>. If you run multiple dashboards on your computer then you may need to avoid a clash by specifying a different port with, for example, <code>run(port=8051)</code>.</li> <li><code>debug</code>. This is described more below in the section on debugging.</li> <li><code>jupyter_mode</code>. This is described more below in the section on Jupyter.</li> </ul> <p>Use only for local development</p> <p>The Flask development server is intended for local development only and should not be used when deploying a Vizro dashboard to production. See our section on deployment for information on how to deploy.</p>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#develop-in-a-notebook","level":3,"title":"Develop in a Notebook","text":"<p>If you develop in a Jupyter Notebook or JupyterLab then you should use exactly the same code as above:</p> <pre><code>from vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Graph(figure=px.scatter(iris, x=\"sepal_length\", y=\"petal_width\", color=\"species\")),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <p>The code runs Vizro using a Flask development server and shows the resulting dashboard inline in your Notebook. You can change where the dashboard appears with the <code>jupyter_mode</code> argument. For example, <code>run(jupyter_mode=\"external\")</code> provides a link to open the dashboard in a new window.</p> <p>Reloading and debugging</p> <p>Code reloading and hot reloading do not work in Jupyter. See the section on reloading for alternatives when using Jupyter.</p>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#develop-in-pycafe","level":3,"title":"Develop in PyCafe","text":"<p>The easiest way to run a dashboard is to work on the code live on PyCafe.</p> <p>Most of the Vizro documentation examples have a link below the code that reads Run and edit this code in Py.Cafe. Follow the link to open the code in PyCafe within an editor, such as the one below, which displays the dashboard and the code side by side.</p> Enter your dashboard code on the left, and see the results immediately reflected in the app on the right. <p>You can use PyCafe snippet mode to experiment with your own Vizro dashboards by dropping code into a new project.</p> <p>Note</p> <p>Note that when you save your code as a project, the dashboard and the code will be visible to the public. PyCafe is planning to implement a paid tier that allows private dashboards.</p> <p>As long as you remain in snippet mode - not having clicked \"Push\" - your code is only local to your machine and is not visible to others.</p>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#automatic-reloading-and-debugging","level":3,"title":"Automatic reloading and debugging","text":"<p>While developing, you often make frequent changes to your code and want to see how the dashboard looks after each change. It can be slow and tedious to manually restart your dashboard every time you want to see your changes. Depending on your chosen development method, there are ways to automatically refresh whenever code changes.</p> <p>... in Python scripts</p> <p>Turn on Dash Dev Tools by setting <code>debug=True</code> in the <code>run()</code> method: <code>Vizro().build(dashboard).run(debug=True)</code>. This switches on code reloading and hot reloading as well as several other features that are useful during development, such as detailed in-app error reporting. Some errors generated at run time can also be viewed via the browser console (for example, in Chrome, see <code>View &gt; Developer &gt; Developer Tools &gt; Console</code>).</p> <p>Dash Dev Tools can also be configured using environment variables. For example, setting the environment variable <code>DASH_DEBUG=true</code> is equivalent to setting <code>debug=True</code> in the <code>run()</code> method.</p> <p>... in a Notebook</p> <p>Vizro code reloading and hot reloading do not work in Jupyter Notebooks. There are two alternative methods to reload the dashboard after you change your code:</p> <ul> <li>Restart the Jupyter kernel and re-run your Notebook.</li> <li>Add a cell containing <code>from vizro import Vizro; Vizro._reset()</code> to the top of your Notebook and re-run it before you re-run your code. With this method, there is no need to restart the Jupyter kernel.</li> </ul> <p>... in PyCafe</p> <p>In PyCafe there is no need to set anything as your dashboard will automatically reload and update when you make code changes. You can change in the settings whether this should happen automatically or on file save.</p>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#production","level":2,"title":"Production","text":"<p>When developing your dashboard you typically run it locally (on your own computer) using the Flask development server. When you deploy to production, this is no longer suitable. Instead, you need a solution that can handle multiple users in a stable, secure and efficient way.</p> <p>The below table is a TLDR that provides an overview of the most common options. Clicking the links will lead you to the relevant section below.</p> Method Free Tier Some key features (not exhaustive) Requires Hugging Face Easy cloning of apps, Gallery features, easy access to HF model hub Hugging Face account Dash Enterprise Enterprise deployment solution with many more features going above and beyond Dash Enterprise subscription PyCafe No deployment in traditional sense (with backend server) as it uses WASM technology to run python in the Browser, but very scalable and easy alternative in some cases No requirements (in snippet mode), otherwise a PyCafe account","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#overview","level":3,"title":"Overview","text":"<p>Vizro is a production-ready framework, which means that the dashboard created during development is immediately suitable for deployment to production with minimal changes. Under the hood, Vizro uses Dash's stateless architecture, designed for scaling to thousands of concurrent users.</p> <p>In general, there is only one code change that is required for deployment. During development, the last line of your <code>app.py</code> file should be <code>Vizro().build(dashboard).run()</code>.</p> <p>For deployment, this should be replaced with:</p> <pre><code>app = Vizro().build(dashboard)  # (1)!\n\nif __name__ == \"__main__\":  # (2)!\n    app.run()\n</code></pre> <ol> <li>The Vizro <code>app</code> object needs to be exposed so that the app can be started in production.</li> <li>This code is only executed when you run <code>python app.py</code> and does not run in production. It's there to enable you to run the same app in development using the Flask development server.</li> </ol> <p>That's it! Your app is now suitable for deployment to production.</p> <p>Extra step if you use dynamic data cache</p> <p>If your dashboard uses dynamic data that can be refreshed while the dashboard is running then you should configure your data manager cache to use a backend that supports multiple processes.</p> <p>Now that your <code>app.py</code> file is ready, you need to choose a hosting provider. There are many services out there with different offerings, but for most users we recommend Hugging Face. It has a free tier with the possibility of paying more for extras, and is quick and easy to get started with. We give step-by-step instructions on how to use it below.</p> <p>Enterprise users should look at our guidance for deploying Vizro dashboards on Dash Enterprise. We also discuss the general principles for deploying a Vizro app that apply to all hosting providers.</p>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#deploy-to-hugging-face","level":3,"title":"Deploy to Hugging Face","text":"<p>Hugging Face is a platform for machine learning models, datasets and demos. Within Hugging Face, the Spaces feature offers a one click experience to deploy a Vizro dashboard for free. This is the easiest way to deploy a Vizro app if you do not mind your app's code being public or shared within your Hugging Face organization. Paid plans include features such as authentication, developer mode for debugging, user analytics and more powerful computing resources.</p> <p>The best way to get started with Vizro on Hugging Face is to copy an existing Vizro dashboard and then modify it to add your own app. Vizro maintains an official gallery of example dashboards and a gallery of example dashboards made by the community. Any of these example dashboards can be used as a template for your app. In Hugging Face terminology, a Vizro dashboard lives in a Space, and you can copy a dashboard by duplicating the Space.</p> <p>If this is your first Vizro deployment, we recommend using our first dashboard example. This is a minimal example that is designed to make it as simple as possible to get started on Hugging Face. You can create your own Vizro deployment based on this template as follows:</p> <ol> <li>Sign up for a Hugging Face account.</li> <li>Copy our example Hugging Face dashboard by duplicating our first dashboard example Space. To do so, click the following button: . This should open a window with the following form: </li> <li>You do not need to alter any of the default options but the Hugging Face documentation gives an explanation of each.</li> <li>Click \"Duplicate Space\" to build your Hugging Face Space. This takes around 10 seconds, and when complete you should see the following dashboard running. </li> </ol> <p>To turn the example app into your own, you will need to edit the code in the <code>app.py</code> file. Click on the Files tab at the top of your app and select <code>app.py</code>. Click the Edit button highlighted in the below screenshot to enter an editor view of the file. </p> <p>You can now copy and paste your app code into the editor. When you've finished editing, click \"Commit changes to <code>main</code>\". This immediately triggers a rebuild of your Space. As with the initial build this takes around 10 seconds, and when complete you should be able to view your own app deployed on Hugging Face!</p> <p>Note</p> <p>Remember that a deployed <code>app.py</code> file must contain a line that exposes the Vizro <code>app</code> object as <code>app = Vizro().build(dashboard)</code>.</p> <p>Under the hood, your Space is a Git repository. Instead of editing files through your browser, you can use <code>git</code> from the command line and the Hugging Face CLI. Every time you make a commit to your repository, your app is automatically rebuilt and restarted.</p> <p>In addition to <code>app.py</code>, your Space contains a few other files:</p> <ul> <li><code>.gitattributes</code> is used by Git Large File Storage (LFS) and is only relevant if you have files larger than 10MB. See the Hugging Face documentation for more information.</li> <li><code>Dockerfile</code> gives instructions to configure your app's environment and start the app. See our section on Dockerfiles for more information.</li> <li><code>README.md</code> configures your Space, for example its title, description and license. See the Hugging Face documentation for more information.</li> <li><code>requirements.txt</code> gives your Python package dependencies. See our section on dependencies for more information.</li> </ul> <p>Tip</p> <p>If you'd like to show your Vizro app off to the community then you can add it to our Vizro dashboard community gallery. Notify us on GitHub in case you are interested.</p>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#deploy-via-dash-enterprise","level":3,"title":"Deploy via Dash Enterprise","text":"<p>Since a Vizro app is a Dash app under the hood, they can be deployed to Dash Enterprise and accessed in the same way as other Dash apps.</p> <p>Dash Enterprise helps to deploy and scale production-grade data apps and integrate them with IT infrastructure such as authentication and VPC services. Vizro users may find it suitable for deployment, rapid development environments, and authentication.</p> <p>Vizro is compatible with the following functionality within Dash Enterprise:</p> <ul> <li>App Portal</li> <li>App Manager</li> <li>Dash App Workspaces</li> <li>App logs and viewer statistics</li> <li>Centralized data app management</li> <li>CI/CD</li> <li>Redis</li> <li>Dash Enterprise Authentication</li> </ul> <p>Vizro is not currently compatible with the Dashboard Engine or Dash Design Kit, and cannot produce static reports accessed via the Snapshot Engine.</p>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#deploy-via-pycafe","level":3,"title":"Deploy via PyCafe","text":"<p>You can also share your Vizro application using PyCafe - which we introduced in the development section. This is not a traditional deployment (using a backend server), but uses WebAssembly and Pyodide to run Python in your browser. If you are happy with the constraints and advantages of this technology, then this is likely the easiest and fastest way to share your application.</p> <p>The two menu options of interest are highlighted in red below. \"Push\" let's you save a snippet to your account, so you can come back to edit it, and \"Share\" shows you how to share your code and dashboard.</p> Highlighted in red are the options that help you share your dashboard. <p>Since this solution runs the dashboard in every visitors Browser, scalability to many viewers is not an issue.</p>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#general-principles-when-deploying-vizro-dashboards","level":3,"title":"General principles when deploying Vizro dashboards","text":"<p>There are many other hosting providers, such as Render, Heroku, and Fly. Some of these, such as Render, offer a free tier.</p> <p>Although these services work in slightly different ways, there are some general principles that usually apply across all hosting providers. In general, the procedure is:</p> <ol> <li>Modify the last line of your <code>app.py</code> to expose the Vizro <code>app</code> object as <code>app = Vizro().build(dashboard)</code>.</li> <li>Create a <code>requirements.txt</code> file to give your Python package dependencies. This should include <code>vizro</code> and <code>gunicorn</code>. See the section on dependencies for more information.</li> <li>Upload your <code>app.py</code> and <code>requirements.txt</code> files, for example by drag and drop, your hosting provider's CLI, or <code>git push</code>.</li> <li>Specify on your hosting provider how to handle your app:<ul> <li>Before the app is started, the environment needs to be built. Python dependencies should be installed with <code>pip install -r requirements.txt</code>.</li> <li>To start the app, you should use the command <code>gunicorn app:app --workers 4</code>. See the section on Gunicorn for more information.</li> <li>Optional: set advanced configuration, for example to serve assets using a Content Delivery Network (CDN).</li> </ul> </li> <li>Optional: configure further settings on your hosting provider, for example to make your dashboard private or to configure computing resources.</li> </ol> <p>The method for providing instructions on how to handle your app varies between hosting providers. For example, on Render there are build and deploy commands; on Heroku and Dash Enterprise there is a Procfile. One common cross-platform way to configure an environment is using a Dockerfile. This is used by many hosting providers, including Hugging Face; see the section on Dockerfile for more information.</p>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#dependencies","level":4,"title":"Dependencies","text":"<p>The <code>requirements.txt</code> file specifies your app's Python dependencies. At a minimum, the file must include <code>vizro</code> (used to run the app in development and production) and <code>gunicorn</code> (used only in production). Our simple dashboard demo has exactly this minimal example <code>requirements.txt</code>. These dependencies should then be installed on your host server using <code>pip install</code> with the command <code>pip install -r requirements.txt</code> (or the <code>uv</code> equivalent <code>uv pip install -r requirements.txt</code>).</p> <p>Although this process for handling dependencies is sufficient to get started with deployment, it is best practice to pin your dependencies to exact versions. This ensures that your app does not break when your dependencies are updated. Ideally, pinned versions should include both your direct dependencies and their dependencies (your transitive dependencies). There are two alternative methods we recommend for this:</p> <ul> <li>Run <code>pip freeze</code> in your development environment to create the <code>requirements.txt</code> file with <code>pip freeze &gt; requirements.txt</code>. On your host server, these dependencies are installed with <code>pip install -r requirements.txt</code>.</li> <li>Create a new file <code>requirements.in</code> for your unpinned requirements and run <code>uv pip compile</code> to generate the <code>requirements.txt</code> file from this with <code>uv pip compile requirements.in -o requirements.txt</code>. On the host server, these dependencies should be installed with <code>uv pip sync requirements.txt</code>. This is the method followed in our KPI dashboard demo.</li> </ul>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#gunicorn","level":4,"title":"Gunicorn","text":"<p>Gunicorn is a production-ready Python server for deploying an app over multiple worker processes. The standard way to write a Vizro app is to have a file called <code>app.py</code> that contains the Vizro app in a variable called <code>app</code>. Given this setup, the command to start Gunicorn with four worker processes is:</p> <pre><code>gunicorn app:app --workers 4\n</code></pre> <p>The Gunicorn documentation gives commonly used arguments and advice for setting them. Other than <code>workers</code>, the most common argument to specify is <code>bind</code>, which makes your app accessible. This is often set as <code>--bind 0.0.0.0:&lt;port&gt;</code>. Your hosting provider needs to tell you what the correct port to use is. For example, on Hugging Face it is 7860.</p>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#dockerfile","level":4,"title":"Dockerfile","text":"<p>A Dockerfile contains instructions to build a container image. You can think of it as a way to give in a single file all the instructions that your hosting provider needs to deploy your app. This includes both the installation of dependencies and starting the app with Gunicorn. A Dockerfile is used by many hosting providers, including Hugging Face.</p> <p>Here is an annotated example Dockerfile that we use in our simple Hugging Face demo. It demonstrates the key Dockerfile instructions needed to deploy Vizro and should serve as a good starting point for your own Dockerfile.</p> <pre><code>FROM ghcr.io/astral-sh/uv:python3.12-bookworm-slim  # (1)!\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN uv pip install --system -r requirements.txt\nCOPY . .\n# (2)!\n\nENTRYPOINT [\"gunicorn\", \"app:app\", \"--workers\", \"4\", \"--bind\", \"0.0.0.0:7860\"]\n# (3)!\n</code></pre> <ol> <li>Use a Docker image that includes <code>uv</code> pre-installed.</li> <li>Install the Python dependencies as described in the <code>uv</code> documentation. The app files are copied into the container after installing dependencies to optimize Docker's build cache.</li> <li>Run the Vizro app using Gunicorn.</li> </ol>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#advanced-dockerfile-configuration","level":4,"title":"Advanced Dockerfile configuration","text":"<p>Vizro is built on top of Dash, which itself uses Flask. Deployment of Vizro is essentially the same as deployment of the underlying frameworks, and more guidance can be found in Flask's deployment documentation and Dash's deployment documentation.</p> <p>[<code>Vizro</code>][vizro.Vizro] accepts <code>**kwargs</code> that are passed through to <code>Dash</code>. This enables you to configure the underlying Dash app using the same arguments that are available in <code>Dash</code>. For example, in a deployment context, these arguments may be useful:</p> <ul> <li><code>url_base_pathname</code>: serve your Vizro app at a specific path rather than at the domain root. For example, if you host your dashboard at <code>http://www.example.com/my_dashboard/</code> then you would set <code>url_base_pathname=\"/my_dashboard/\"</code> or an environment variable <code>DASH_URL_BASE_PATHNAME=\"/my_dashboard/\"</code>.</li> <li><code>serve_locally</code>: set to <code>False</code> to serve Dash component libraries from a Content Delivery Network (CDN), which reduces load on the server and can improve performance. Vizro uses jsDeliver as a CDN for CSS and JavaScript sources.</li> <li><code>assets_external_path</code>: when <code>serve_locally=False</code>, you can also set <code>assets_external_path</code> or an environment variable <code>DASH_ASSETS_EXTERNAL_PATH</code> to serve your own assets from a CDN.</li> </ul> <p>In fact, the only difference between deploying a Vizro app and deploying a Dash app is that Vizro implements a small simplification that makes it unnecessary for you to add a line like <code>server = app.server</code>, as you would do with Dash. Internally, <code>app = Vizro()</code> contains a Flask app in <code>app.dash.server</code>. As a convenience, the Vizro <code>app</code> itself implements the WSGI application interface as a shortcut to the underlying Flask app. This means that the Vizro <code>app</code> object can be directly supplied to the WSGI server in the command <code>gunicorn app:app</code>.</p>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#webassembly-wasm-and-pyodide","level":4,"title":"WebAssembly (WASM) and Pyodide","text":"<p>Vizro applications traditionally run on a Python backend, serving dynamic content to a web-based frontend. However, advancements in WASM and Pyodide as used by PyCafe now enable Vizro to run entirely in the browser without a dedicated server.</p> <p>WASM</p> <p>WASM is a low-level binary instruction format that enables high-performance execution of code on web browsers. Unlike JavaScript, which is typically interpreted, WASM code is compiled and executed at near-native speed. This enables languages like C, Rust, and even Python (via Pyodide) to run efficiently in the browser.</p> <p>Pyodide</p> <p>Pyodide is a Python distribution compiled to WebAssembly, enabling Python execution in a browser’s JavaScript runtime. It includes a standard Python interpreter, common scientific libraries (NumPy, Pandas, Matplotlib, etc.), and interoperability with JavaScript within the browser environment. In the context of Vizro, Pyodide enables the execution of Dash callbacks, component updates, and external Python libraries directly in the client’s browser, without a persistent backend.</p> <p>While potential advantages include serverless execution, reduced latency and easier \"deployment\", the disadvantages include limited performance compared to a native server, limited library support, and memory constraints.</p>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/run-deploy/#shareable-url","level":3,"title":"Shareable URL","text":"<p>When sharing your dashboard, it can be useful to share or bookmark a link to a page on which you have already set the controls. Any controls that have <code>show_in_url=True</code> are included in the URL of the page.</p> <p>Shareable URL that includes filter</p> app.pyapp.yamlResult <pre><code>from vizro import Vizro\nimport vizro.plotly.express as px\nimport vizro.models as vm\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"My first page\",\n    components=[\n        vm.Graph(figure=px.scatter(iris, x=\"sepal_length\", y=\"petal_width\", color=\"species\")),\n    ],\n    controls=[\n        vm.Filter(\n            column=\"species\",\n            id=\"filter-id\",  # (1)!\n            show_in_url=True,\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <ol> <li>Setting <code>id</code> is not compulsory, but it is recommended. If you do not set the <code>id</code> explicitly then a random <code>id</code> is set for you. If you later change your dashboard configuration and re-deploy then a different random <code>id</code> would be generated, and old shareable URLs would not work correctly.</li> </ol> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: scatter\n          data_frame: iris\n          x: sepal_length\n          y: petal_width\n          color: species\n        type: graph\n    controls:\n      - column: species\n        id: filter-id\n        show_in_url: true\n        type: filter\n    title: My first page\n</code></pre> <p></p> <p>Page state rather than dashboard state</p> <p>Only controls on the currently opened page are reflected in the URL. It is not yet possible to share or bookmark the global state of a multi-page dashboard.</p>","path":["How to run and/or deploy your dashboard"],"tags":[]},{"location":"user-guides/selectors/","level":1,"title":"How to use selectors","text":"<p>This guide highlights different selectors that can be used in a dashboard. Selectors do not serve a purpose on their own, but they enable you to change how the input is given to other models, for example, the [<code>Filter</code>][vizro.models.Filter] or the [<code>Parameter</code>][vizro.models.Parameter] model.</p> <p>The [<code>Filter</code>][vizro.models.Filter] or the [<code>Parameter</code>][vizro.models.Parameter] model accept the <code>selector</code> argument, where a selector model can be entered to choose how the user should input their choices for the respective models.</p>","path":["How to use selectors"],"tags":[]},{"location":"user-guides/selectors/#categorical-selectors","level":2,"title":"Categorical selectors","text":"<p>Within the categorical selectors, a clear distinction exists between multi-option and single-option selectors. For instance, the [<code>Checklist</code>][vizro.models.Checklist] functions as a multi-option selector by default while the [<code>RadioItem</code>][vizro.models.RadioItems] serves as a single-option selector by default. However, the [<code>Dropdown</code>][vizro.models.Dropdown] can function as both a multi-option or single-option selector.</p> <p>For more information, refer to the API reference of the selector, or the documentation of its underlying Dash component:</p> <ul> <li>[<code>Dropdown</code>][vizro.models.Dropdown] based on <code>dcc.Dropdown</code></li> <li>[<code>Checklist</code>][vizro.models.Checklist] based on <code>dcc.Checklist</code></li> <li>[<code>RadioItems</code>][vizro.models.RadioItems] based on <code>dcc.RadioItems</code></li> </ul> <p>If you have binary data (such as <code>False</code>/<code>True</code> or <code>0</code>/<code>1</code>), you might prefer to use a dedicated boolean selector instead.</p> <p>Configuring <code>options</code></p> <p>When configuring the <code>options</code> of the categorical selectors, you can either give:</p> <ul> <li>a list of values <code>options = ['Value A', 'Value B', 'Value C']</code></li> <li>or a dictionary of label-value mappings <code>options=[{'label': 'True', 'value': True}, {'label': 'False', 'value': False}]</code></li> </ul> <p>The later is required if you want to provide different display labels to your option values or in case you want to provide boolean values as options. In this case, you need to provide a string label for your boolean values as boolean values cannot be displayed properly as labels in the underlying Dash components.</p>","path":["How to use selectors"],"tags":[]},{"location":"user-guides/selectors/#numerical-selectors","level":2,"title":"Numerical selectors","text":"<p>For more information, refer to the API reference of the selector, or the documentation of its underlying Dash component:</p> <ul> <li>[<code>Slider</code>][vizro.models.Slider] based on <code>dcc.Slider</code></li> <li>[<code>RangeSlider</code>][vizro.models.RangeSlider] based on <code>dcc.RangeSlider</code></li> </ul> <p>Using float values and <code>step</code> with an integer value</p> <p>When configuring the [<code>Slider</code>][vizro.models.Slider] and the [<code>RangeSlider</code>][vizro.models.RangeSlider] with float values, and using <code>step</code> with an integer value, you may notice unexpected behavior, such as the drag value being outside its indicated marks. To our knowledge, this is a current bug in the underlying <code>dcc.Slider</code> and <code>dcc.RangeSlider</code> component, which you can circumvent by adapting the <code>step</code> size as needed.</p>","path":["How to use selectors"],"tags":[]},{"location":"user-guides/selectors/#temporal-selectors","level":2,"title":"Temporal selectors","text":"<p>For more information, refer to the API reference of the selector, or the documentation of its underlying Dash component:</p> <ul> <li>[<code>DatePicker</code>][vizro.models.DatePicker] based on <code>dmc.DatePickerInput</code></li> </ul> <p>Note</p> <p>When configuring the [<code>DatePicker</code>][vizro.models.DatePicker] make sure to provide your dates for <code>min</code>, <code>max</code> and <code>value</code> arguments in <code>\"yyyy-mm-dd\"</code> format or as <code>datetime</code> type (for example, <code>datetime.datetime(2024, 01, 01)</code>).</p>","path":["How to use selectors"],"tags":[]},{"location":"user-guides/selectors/#boolean-selectors","level":2,"title":"Boolean selectors","text":"<p>For more information, refer to the API reference of the selector, or the documentation of its underlying Dash component:</p> <ul> <li>[<code>Switch</code>][vizro.models.Switch] based on <code>dbc.Switch</code></li> </ul>","path":["How to use selectors"],"tags":[]},{"location":"user-guides/selectors/#add-a-tooltip","level":2,"title":"Add a tooltip","text":"<p>The <code>description</code> argument enables you to add helpful context to your selector by displaying an info icon next to its title. Hovering over the icon shows a tooltip with your provided text.</p> <p>You can provide Markdown text as a string to use the default info icon or a [<code>Tooltip</code>][vizro.models.Tooltip] model to use any icon from the Google Material Icons library.</p> <p>Selectors with tooltip</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"Selectors with icons\",\n    components=[\n        vm.Graph(\n            figure=px.scatter(iris, x=\"sepal_length\", y=\"sepal_width\")\n        ),\n    ],\n    controls=[\n        vm.Filter(\n            column=\"species\",\n            selector=vm.Checklist(\n                title=\"Select Species\",\n                description=\"\"\"\n                    Select which species of iris you like.\n\n                    [Click here](https://en.wikipedia.org/wiki/Iris_flower_data_set)\n                    to learn more about flowers.\"\"\",\n            )\n        ),\n    ]\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code>pages:\n  - title: Selectors with icons\n    components:\n      - type: graph\n        figure:\n          _target_: scatter\n          data_frame: iris\n          x: sepal_length\n          y: sepal_width\n    controls:\n      - column: species\n        type: filter\n        selector:\n          type: checklist\n          title: Select Species\n          description: |\n                Select which species of iris you like.\n\n                [Click here](https://en.wikipedia.org/wiki/Iris_flower_data_set) to learn more about flowers.\n</code></pre> <p></p>","path":["How to use selectors"],"tags":[]},{"location":"user-guides/selectors/#the-extra-argument","level":2,"title":"The <code>extra</code> argument","text":"<p>Currently each selector is based on an underlying Dash component as mentioned in the sections above. Using the <code>extra</code> argument you can pass extra arguments to the underlying object in order to alter it beyond the chosen defaults. The available arguments can be found in the documentation of each underlying component that was linked in the respective sections above.</p> <p>Note</p> <p>Using <code>extra</code> is a quick and flexible way to alter a component beyond what Vizro offers. However, it is not a part of the official Vizro schema and the underlying implementation details may change. If you want to guarantee that your apps keep running, we recommend that you pin your Vizro version.</p> <p>An example would be to make the [<code>RadioItem</code>][vizro.models.RadioItems] display inline instead of stacked vertically. For this you can use <code>extra={\"inline\": True}</code> argument:</p> <p>Inline Radio Items</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\niris = px.data.iris()\n\npage = vm.Page(\n    title=\"Inline Radio Items\",\n    components=[\n        vm.Graph(\n            figure=px.scatter(iris, x=\"sepal_length\", y=\"sepal_width\")\n        ),\n    ],\n    controls=[\n        vm.Filter(\n            column=\"species\",\n            selector=vm.RadioItems(\n                title=\"Select Species\",\n                extra={\"inline\": True}\n            )\n        )\n    ]\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code>pages:\n  - title: Inline Radio Items\n    components:\n      - type: graph\n        figure:\n          _target_: scatter\n          data_frame: iris\n          x: sepal_length\n          y: sepal_width\n    controls:\n      - column: species\n        type: filter\n        selector:\n          type: radio_items\n          title: Select Species\n          extra:\n            inline: true\n</code></pre> <p></p>","path":["How to use selectors"],"tags":[]},{"location":"user-guides/table/","level":1,"title":"How to use tables","text":"<p>This guide shows you how to visualize tables in Vizro.</p> <p>There are two ways to visualize tables in Vizro, using either AG Grid or Dash DataTable. In general, AG Grid is Vizro's recommended table implementation, but sometimes it may make sense to use the Dash DataTable instead.</p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#choose-between-ag-grid-and-dash-datatable","level":2,"title":"Choose between AG Grid and Dash DataTable","text":"<p>Vizro offers two models - the [<code>AgGrid</code>][vizro.models.AgGrid] model and the [<code>Table</code>][vizro.models.Table] model - for the above two approaches respectively. They both visualize tabular data in similar ways.</p> <p>The main difference between the two is that the [<code>AgGrid</code>][vizro.models.AgGrid] model is based on Plotly's Dash AG Grid component, while the [<code>Table</code>][vizro.models.Table] model is based on the Dash DataTable component.</p> <p>Both approaches have similar base features, and are configurable in similar ways. However, the AG Grid offers more advanced features out-of-the-box, is more customizable and also ships a powerful enterprise version. This is why it is Vizro's recommended table implementation. At the same time, the Dash DataTable can be used if developers are already familiar with it, or if some custom functionality is easier to implement using the Dash DataTable.</p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#ag-grid","level":2,"title":"AG Grid","text":"<p>AG Grid is an interactive table/grid component designed for viewing, editing, and exploring large datasets. It is Vizro's recommended table implementation.</p> <p>The Vizro [<code>AgGrid</code>][vizro.models.AgGrid] model is based on the Dash AG Grid, which is in turn based the original Javascript implementation.</p> <p>More examples of AG Grid</p> <p>If you would like to see more examples on what can be done with AG Grid, head to the Dash AG Grid documentation. Almost anything you see there is possible in Vizro by creating a custom AG Grid callable.</p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#basic-usage","level":3,"title":"Basic usage","text":"<p>To add a [<code>AgGrid</code>][vizro.models.AgGrid] to your page, do the following:</p> <ol> <li>Insert the [<code>AgGrid</code>][vizro.models.AgGrid] model into the <code>components</code> argument of the [<code>Page</code>][vizro.models.Page] model.</li> <li>Enter the <code>dash_ag_grid</code> function under the <code>figure</code> argument (imported via <code>from vizro.tables import dash_ag_grid</code>).</li> </ol> <p>The Vizro version of this AG Grid differs in one way from the original Dash AG Grid: it requires the user to pass a pandas DataFrame as the source of data. As explained in our guide to using data in Vizro, this must be entered under the argument <code>data_frame</code>. Most other parameters of the Dash AG Grid can be entered as keyword arguments. Note that some defaults are set for some arguments (for example, for <code>columnDefs</code>) to help with styling and usability. Sometimes a parameter may not work because it requires a callback to function. In that case you can try creating a custom AG Grid callable.</p> <p>Basic Dash AG Grid</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\n\ndf = px.data.gapminder()\n\npage = vm.Page(\n    title=\"Default Dash AG Grid\",\n    components=[vm.AgGrid(figure=dash_ag_grid(data_frame=df))]\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: dash_ag_grid\n          data_frame: gapminder\n        type: ag_grid\n    title: Default Dash AG Grid\n</code></pre> <p></p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#interact-with-other-graphs-and-tables","level":2,"title":"Interact with other graphs and tables","text":"<p>An AG Grid can act as a source for interactions with other components, for example to cross-filter another graph or table when the user clicks on a point.</p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#disable-pagination","level":3,"title":"Disable pagination","text":"<p>By default, pagination is enabled in AG Grid to improve performance and usability with large datasets. If you prefer to show all rows in a single scrollable table (for example, to allow users to scroll vertically through all data), you can disable pagination by setting <code>dashGridOptions={\"pagination\": False}</code>.</p> <p>Dash AG Grid without pagination</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\n\ndf = px.data.gapminder()\n\npage = vm.Page(\n    title=\"Dash AG Grid with pagination\",\n    components=[vm.AgGrid(figure=dash_ag_grid(data_frame=df, dashGridOptions={\"pagination\": False}))]\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: dash_ag_grid\n          data_frame: gapminder\n          dashGridOptions:\n            pagination: false\n        type: ag_grid\n    title: Dash AG Grid with pagination\n</code></pre> <p></p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#formatting-columns","level":3,"title":"Formatting columns","text":"","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#numbers","level":4,"title":"Numbers","text":"<p>One of the most common tasks when working with tables is to format the columns so that displayed numbers are more readable. To do this, you can use the native functionality of value formatters or the Vizro custom cell data types as shown below.</p> <p>The available custom cell types for Vizro are <code>dollar</code>, <code>euro</code>, <code>percent</code> and <code>numeric</code>.</p> <p>To use these, define your desired <code>&lt;COLUMN&gt;</code> alongside the chosen <code>cellDataType</code> in the <code>columnDefs</code> argument of your <code>dash_ag_grid</code> function:</p> <pre><code>columnDefs = [{\"field\": \"&lt;COLUMN&gt;\", \"cellDataType\": \"euro\"}]\n</code></pre> <p>In the example below we select and format some columns of the gapminder data.</p> <p>AG Grid with formatted columns</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\n\ndf = px.data.gapminder()\n\ncolumnDefs = [{\"field\": \"country\"}, {\"field\": \"year\"}, {\"field\": \"lifeExp\", \"cellDataType\": \"numeric\"},\n              {\"field\": \"gdpPercap\", \"cellDataType\": \"dollar\"}, {\"field\": \"pop\", \"cellDataType\": \"numeric\"}]\n\npage = vm.Page(\n    title=\"Example of AG Grid with formatted columns\",\n    components=[\n        vm.AgGrid(\n            title=\"AG Grid with formatted columns\",\n            figure=dash_ag_grid(\n                data_frame=df,\n                columnDefs=columnDefs,\n            ),\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: dash_ag_grid\n          data_frame: gapminder\n          columnDefs:\n            - field: country\n            - field: year\n            - field: lifeExp\n              cellDataType: numeric\n            - field: gdpPercap\n              cellDataType: dollar\n            - field: pop\n              cellDataType: numeric\n        title: AG Grid with formatted columns\n        type: ag_grid\n    title: Example of AG Grid with formatted columns\n</code></pre> <p></p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#dates","level":4,"title":"Dates","text":"<p>For the [<code>AgGrid</code>][vizro.models.AgGrid] model to sort and filter dates correctly, the date must either be of string format <code>yyyy-mm-dd</code> (see Dash AG Grid docs) or a pandas datetime object. Any pandas datetime column will be transformed into the <code>yyyy-mm-dd</code> format automatically.</p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#objects-and-strings","level":4,"title":"Objects and strings","text":"<p>No specific formatting is available for custom objects and strings, however you can make use of Value Formatters to format displayed strings automatically.</p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#resizing-columns","level":3,"title":"Resizing columns","text":"<p>The [<code>AgGrid</code>][vizro.models.AgGrid] provides automatic column sizing options through the <code>columnSize</code> property. This feature allows you to control how columns are sized within the grid to optimize the display of your data.</p> <p>You can configure column sizing by setting the <code>columnSize</code> parameter in your <code>dash_ag_grid</code> function call. By default, the <code>columnSize</code> is set to <code>responsiveSizeToFit</code> within the <code>vm.AgGrid</code>. The available options are:</p> <ul> <li> <p><code>autoSize</code>: Automatically adjusts column widths to fit their content. This is particularly useful when you have varying content lengths and want each column to be sized appropriately for readability.</p> </li> <li> <p><code>sizeToFit</code>: Resizes all columns proportionally to fill the entire width of the grid container. This ensures no horizontal scrolling is needed and the AgGrid uses all available space.</p> </li> <li> <p><code>responsiveSizeToFit</code>: Combines <code>sizeToFit</code> with automatic readjustment of the columns' widths when the grid container or columns change (such as when the browser window is resized or when filters are applied).</p> </li> <li> <p><code>None</code>: Maintains the default column widths without automatic resizing.</p> </li> </ul> <p>For more advanced column sizing configurations, you can use the <code>columnSizeOptions</code> parameter in combination with <code>columnSize</code>.</p> <p>AG Grid with column sizing</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\n\ndf = px.data.gapminder()\n\npage = vm.Page(\n    title=\"AG Grid with Column Sizing\",\n    components=[vm.AgGrid(id=\"ag-grid\", figure=dash_ag_grid(data_frame=df, columnSize=\"responsiveSizeToFit\"))],\n    controls=[\n        vm.Parameter(\n            targets=[\"ag-grid.columnSize\"],\n            selector=vm.RadioItems(\n                title=\"Select ColumnSize\",\n                options=[\n                    {\"value\": \"autoSize\", \"label\": \"autoSize\"},\n                    {\"value\": \"responsiveSizeToFit\", \"label\": \"responsiveSizeToFit\"},\n                    {\"value\": \"sizeToFit\", \"label\": \"sizeToFit\"},\n                    {\"value\": \"NONE\", \"label\": \"None\"},\n                ],\n                value=\"responsiveSizeToFit\"\n            ),\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: dash_ag_grid\n          data_frame: gapminder\n          columnSize: responsiveSizeToFit\n        id: ag-grid\n        type: ag_grid\n    controls:\n      - selector:\n            # Automatically adjusts column widths\n          options: [{value: autoSize, label: autoSize},\n            # Resizes all columns proportionally\n             {value:responsiveSizeToFit: null, label: responsiveSizeToFit},\n            # Combines `sizeToFit` with automatic readjustment of the columns' widths\n             {value:sizeToFit: null, label: sizeToFit},\n            # Maintains the default column widths\n             {value: NONE, label:None: null}]\n          value: responsiveSizeToFit\n          title: Select ColumnSize\n          type: radio_items\n        targets:\n          - ag-grid.columnSize\n        type: parameter\n    title: AG Grid with Column Sizing\n</code></pre> <p></p> <p>For detailed information about column sizing options and advanced configurations, refer to the Dash AG Grid column sizing documentation.</p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#styling-and-changing-the-ag-grid","level":3,"title":"Styling and changing the AG Grid","text":"<p>As mentioned above, all parameters of the Dash AG Grid can be entered as keyword arguments. Below you can find an example of a styled AG Grid where some conditional formatting is applied, and where the columns are editable, but not filterable or resizable. There are more ways to alter the grid beyond this showcase. AG Grid, like any other Vizro component, can be customized using custom CSS. You can find information in the guide to overwriting CSS properties.</p> <p>Styled and modified Dash AG Grid</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\n\ndf = px.data.gapminder()\n\ncellStyle = {\n    \"styleConditions\": [\n        {\n            \"condition\": \"params.value &lt; 1045\",\n            \"style\": {\"backgroundColor\": \"#ff9222\"},\n        },\n        {\n            \"condition\": \"params.value &gt;= 1045 &amp;&amp; params.value &lt;= 4095\",\n            \"style\": {\"backgroundColor\": \"#de9e75\"},\n        },\n        {\n            \"condition\": \"params.value &gt; 4095 &amp;&amp; params.value &lt;= 12695\",\n            \"style\": {\"backgroundColor\": \"#aaa9ba\"},\n        },\n        {\n            \"condition\": \"params.value &gt; 12695\",\n            \"style\": {\"backgroundColor\": \"#00b4ff\"},\n        },\n    ]\n}\n\ncolumnDefs = [\n    {\"field\": \"country\"},\n    {\"field\": \"continent\"},\n    {\"field\": \"year\"},\n    {\n        \"field\": \"lifeExp\",\n        \"valueFormatter\": {\"function\": \"d3.format('.1f')(params.value)\"},\n    },\n    {\n        \"field\": \"gdpPercap\",\n        \"valueFormatter\": {\"function\": \"d3.format('$,.1f')(params.value)\"},\n        \"cellStyle\": cellStyle,\n    },\n    {\n        \"field\": \"pop\",\n        \"valueFormatter\": {\"function\": \"d3.format(',.0f')(params.value)\"},\n    },\n]\n\npage = vm.Page(\n    title=\"Example of Modified Dash AG Grid\",\n    components=[\n        vm.AgGrid(\n            title=\"Modified Dash AG Grid\",\n            figure=dash_ag_grid(\n                data_frame=df,\n                columnDefs=columnDefs,\n                defaultColDef={\"resizable\": False, \"filter\": False, \"editable\": True},\n            ),\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: dash_ag_grid\n          data_frame: gapminder\n          columnDefs:\n            - field: country\n            - field: continent\n            - field: year\n            - field: lifeExp\n              valueFormatter:\n                function: d3.format('.1f')(params.value)\n            - field: gdpPercap\n              valueFormatter:\n                function: d3.format('$,.1f')(params.value)\n              cellStyle:\n                styleConditions:\n                  - condition: params.value &lt; 1045\n                    style:\n                      backgroundColor: '#ff9222'\n                  - condition: params.value &gt;= 1045 &amp;&amp; params.value &lt;= 4095\n                    style:\n                      backgroundColor: '#de9e75'\n                  - condition: params.value &gt; 4095 &amp;&amp; params.value &lt;= 12695\n                    style:\n                      backgroundColor: '#aaa9ba'\n                  - condition: params.value &gt; 12695\n                    style:\n                      backgroundColor: '#00b4ff'\n            - field: pop\n              type: rightAligned\n              valueFormatter:\n                function: d3.format(',.0f')(params.value)\n          defaultColDef:\n            resizable: false\n            filter: false\n            editable: true\n        title: Dash AG Grid\n        type: ag_grid\n    title: Example of a Dash AG Grid\n</code></pre> <p></p> <p>If the available arguments are not sufficient, there is always the option to create a custom AG Grid callable.</p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#dash-datatable","level":2,"title":"Dash DataTable","text":"<p>Similar to AG Grid, the Dash DataTable is an interactive table/grid component designed for viewing, editing, and exploring large datasets.</p> <p>In general, we recommend using AG Grid for tables unless you have a particular reason to prefer Dash DataTable.</p> <p>The Vizro [<code>Table</code>][vizro.models.Table] model is based on the Dash DataTable.</p> <p>More examples of Dash DataTable</p> <p>If you would like to see more examples on what can be done with Dash DataTable, head to the Dash DataTable documentation. Almost anything you see there is possible in Vizro by creating a custom Dash DataTable callable.</p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#basic-usage_1","level":3,"title":"Basic usage","text":"<p>To add a [<code>Table</code>][vizro.models.Table] model to your page, do the following:</p> <ol> <li>Insert the [<code>Table</code>][vizro.models.Table] model into the <code>components</code> argument of the [<code>Page</code>][vizro.models.Page] model.</li> <li>Enter the <code>dash_data_table</code> function under the <code>figure</code> argument (imported via <code>from vizro.tables import dash_data_table</code>).</li> </ol> <p>The Vizro version of this table differs in one way from the original table: it requires the user to pass a pandas DataFrame as the source of data. As explained in our guide to using data in Vizro, this must be entered under the argument <code>data_frame</code>.</p> <p>All other parameters of the Dash DataTable can be entered as keyword arguments. Note that we are setting some defaults for some arguments to help with styling.</p> <p>Dash DataTable</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_data_table\n\ndf = px.data.gapminder().query(\"year == 2007\")\n\npage = vm.Page(\n    title=\"Example of a Dash DataTable\",\n    components=[\n        vm.Table(title=\"Dash DataTable\", figure=dash_data_table(data_frame=df)),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: dash_data_table\n          data_frame: gapminder_2007\n        title: Dash DataTable\n        type: table\n    title: Example of a Dash DataTable\n</code></pre> <p></p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#styling-and-changing-the-dash-datatable","level":3,"title":"Styling and changing the Dash DataTable","text":"<p>As mentioned above, all parameters of the Dash DataTable can be entered as keyword arguments. Below you can find an example of a styled table where some conditional formatting is applied. There are many more ways to alter the table beyond this showcase.</p> <p>Styled Dash DataTable</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_data_table\n\ndf = px.data.gapminder().query(\"year == 2007\")\n\ncolumn_definitions = [\n    {\"name\": \"country\", \"id\": \"country\", \"type\": \"text\", \"editable\": False},\n    {\"name\": \"continent\", \"id\": \"continent\", \"type\": \"text\"},\n    {\"name\": \"year\", \"id\": \"year\", \"type\": \"datetime\"},\n    {\"name\": \"lifeExp\", \"id\": \"lifeExp\", \"type\": \"numeric\"},\n    {\"name\": \"pop\", \"id\": \"pop\", \"type\": \"numeric\"},\n    {\"name\": \"gdpPercap\", \"id\": \"gdpPercap\", \"type\": \"numeric\"},\n]\n\nstyle_data_conditional = [\n    {\n        \"if\": {\n            \"column_id\": \"year\",\n        },\n        \"backgroundColor\": \"dodgerblue\",\n        \"color\": \"white\",\n    },\n    {\"if\": {\"filter_query\": \"{lifeExp} &lt; 55\", \"column_id\": \"lifeExp\"}, \"backgroundColor\": \"#85144b\", \"color\": \"white\"},\n    {\n        \"if\": {\"filter_query\": \"{gdpPercap} &gt; 10000\", \"column_id\": \"gdpPercap\"},\n        \"backgroundColor\": \"green\",\n        \"color\": \"white\",\n    },\n    {\"if\": {\"column_type\": \"text\"}, \"textAlign\": \"left\"},\n    {\n        \"if\": {\"state\": \"active\"},\n        \"backgroundColor\": \"rgba(0, 116, 217, 0.3)\",\n        \"border\": \"1px solid rgb(0, 116, 217)\",\n    },\n]\n\nstyle_header_conditional = [{\"if\": {\"column_type\": \"text\"}, \"textAlign\": \"left\"}]\n\npage = vm.Page(\n    title=\"Example of a styled Dash DataTable\",\n    components=[\n        vm.Table(\n            title=\"Styled table\",\n            figure=dash_data_table(\n                data_frame=df,\n                columns=column_definitions,\n                sort_action=\"native\",\n                editable=True,\n                style_data_conditional=style_data_conditional,\n                style_header_conditional=style_header_conditional,\n            ),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: dash_data_table\n          data_frame: gapminder_2007\n          sort_action: native\n          editable: true\n          columns:\n            - name: country\n              id: country\n              type: text\n              editable: false\n            - name: continent\n              id: continent\n              type: text\n            - name: year\n              id: year\n              type: datetime\n            - name: lifeExp\n              id: lifeExp\n              type: numeric\n            - name: pop\n              id: pop\n              type: numeric\n            - name: gdpPercap\n              id: gdpPercap\n              type: numeric\n          style_data_conditional:\n            - if:\n                column_id: year\n              backgroundColor: dodgerblue\n              color: white\n            - if:\n                filter_query: '{lifeExp} &lt; 55'\n                column_id: lifeExp\n              backgroundColor: '#85144b'\n              color: white\n            - if:\n                filter_query: '{gdpPercap} &gt; 10000'\n                column_id: gdpPercap\n              backgroundColor: green\n              color: white\n            - if:\n                column_type: text\n              textAlign: left\n            - if:\n                state: active\n              backgroundColor: rgba(0, 116, 217, 0.3)\n              border: 1px solid rgb(0, 116, 217)\n        type: table\n    title: Dash DataTable\n</code></pre> <p></p> <p>If the available arguments are not sufficient, there is always the option to create a custom Dash DataTable.</p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#add-additional-text","level":2,"title":"Add additional text","text":"<p>The [<code>Table</code>][vizro.models.Table] and the [<code>AgGrid</code>][vizro.models.AgGrid] models accept <code>title</code>, <code>header</code>, <code>footer</code> and <code>description</code> arguments. These are useful for providing additional context on the table.</p> <ul> <li>title: Displayed as an H3 header, useful for summarizing the main topic or insight of the component.</li> <li>header: Accepts Markdown text, ideal for extra descriptions, subtitles, or detailed data insights.</li> <li>footer: Accepts Markdown text, commonly used for citing data sources, providing information on the last update, or adding disclaimers.</li> <li>description: Displayed as an icon that opens a tooltip containing Markdown text when hovered over. You can provide a string to use the default info icon or a [<code>Tooltip</code>][vizro.models.Tooltip] model to use any icon from the Google Material Icons library.</li> </ul>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#formatted-aggrid","level":3,"title":"Formatted AgGrid","text":"<p>Formatted AgGrid</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_ag_grid\n\ngapminder_2007 = px.data.gapminder().query(\"year == 2007\")\n\npage = vm.Page(\n    title=\"Formatted AgGrid\",\n    components=[\n        vm.AgGrid(\n            figure=dash_ag_grid(data_frame=gapminder_2007, dashGridOptions={\"pagination\": True}),\n            title=\"Gapminder Data Insights\",\n            header=\"\"\"#### An Interactive Exploration of Global Health, Wealth, and Population\"\"\",\n            footer=\"\"\"SOURCE: **Plotly gapminder data set, 2024**\"\"\",\n            description=\"\"\"\n                The Gapminder dataset tracks the development of countries over time using indicators like life expectancy, income per person, and population size.\n\n                It helps reveal broad global trends, such as how health and wealth have improved in many regions, although progress hasn’t been even across all countries.\n            \"\"\",\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: dash_ag_grid\n          data_frame: gapminder_2007\n          dashGridOptions:\n            pagination: true\n        title: Gapminder Data Insights\n        header: |\n          #### An Interactive Exploration of Global Health, Wealth, and Population\n        footer: |\n          SOURCE: **Plotly gapminder data set, 2024**\n        description: |\n          The Gapminder dataset tracks the development of countries over time using indicators like life expectancy, income per person, and population size.\n\n          It helps reveal broad global trends, such as how health and wealth have improved in many regions, although progress hasn’t been even across all countries.\n        type: ag_grid\n    title: Formatted AgGrid\n</code></pre> <p></p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/table/#formatted-datatable","level":3,"title":"Formatted DataTable","text":"<p>Formatted DataTable</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nfrom vizro.tables import dash_data_table\n\ngapminder_2007 = px.data.gapminder().query(\"year == 2007\")\n\npage = vm.Page(\n    title=\"Formatted DataTable\",\n    components=[\n        vm.Table(\n            figure=dash_data_table(data_frame=gapminder_2007),\n            title=\"Gapminder Data Insights\",\n            header=\"\"\"#### An Interactive Exploration of Global Health, Wealth, and Population\"\"\",\n            footer=\"\"\"SOURCE: **Plotly gapminder data set, 2024**\"\"\",\n            description=\"\"\"\n                The Gapminder dataset tracks the development of countries over time using indicators like life expectancy, income per person, and population size.\n\n                It helps reveal broad global trends, such as how health and wealth have improved in many regions, although progress hasn’t been even across all countries.\n            \"\"\",\n        )\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: dash_data_table\n          data_frame: gapminder_2007\n        title: Gapminder Data Insights\n        header: |\n          #### An Interactive Exploration of Global Health, Wealth, and Population\n        footer: |\n          SOURCE: **Plotly gapminder data set, 2024**\n        description: |\n          The Gapminder dataset tracks the development of countries over time using indicators like life expectancy, income per person, and population size.\n\n          It helps reveal broad global trends, such as how health and wealth have improved in many regions, although progress hasn’t been even across all countries.\n        type: table\n    title: Formatted DataTable\n</code></pre> <p></p>","path":["How to use tables"],"tags":[]},{"location":"user-guides/tabs/","level":1,"title":"How to use tabs","text":"<p>This guide shows you how to use the [<code>Tabs</code>][vizro.models.Tabs] model, which organize and separate groups of related content in a dashboard, letting users switch between different sections or views.</p> <p>They are essentially a way of putting multiple [<code>Container</code>][vizro.models.Container] models in the same screen space, and letting the user switch between them. A <code>Container</code> enables the grouping of page components into sections and subsections. The [<code>Tabs</code>][vizro.models.Tabs] model is based on the underlying Dash component <code>dbc.Tabs</code>.</p> <p> </p> Displaying multiple containers in Tabs <p>Both <code>Tabs</code> and <code>Containers</code> are a more advanced technique for customizing your page layout. If you want to arrange components on a page, we recommend reading our user guide on layouts first.</p> <p>This guide shows you how to use tabs to organize your <code>Containers</code> into subsections inside the dashboard.</p> <p>By using the [<code>Tabs</code>][vizro.models.Tabs] model, the following applies:</p> <ul> <li>Filters affect all components on all tabs (opened and closed) of the page if not specified otherwise inside <code>Filter.targets</code></li> <li>The <code>title</code> of the [<code>Container</code>][vizro.models.Container] inserted into <code>Tabs.tabs</code> will be displayed as a tab label, and the title will be removed from the <code>Container</code></li> </ul>","path":["How to use tabs"],"tags":[]},{"location":"user-guides/tabs/#add-tabs","level":2,"title":"Add tabs","text":"<p>To add a [<code>Tabs</code>][vizro.models.Tabs] model to your page, do the following:</p> <ol> <li>Insert the [<code>Tabs</code>][vizro.models.Tabs] model into the <code>components</code> argument of the [<code>Page</code>][vizro.models.Page] model</li> <li>Insert your [<code>Container</code>][vizro.models.Container] models into the <code>tabs</code> argument of the <code>Tabs</code> model</li> <li>Add a <code>title</code> to the <code>Container</code>, which will be used as the <code>label</code> for the corresponding <code>Tab</code>.</li> <li>(optional) Add a <code>title</code> to the <code>Tabs</code> model to display a heading above your <code>Tabs</code>.</li> </ol> <p>Tabs</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\ngapminder_2007 = px.data.gapminder().query(\"year == 2007\")\n\npage = vm.Page(\n    title=\"Tabs\",\n    components=[\n        vm.Tabs(\n            title=\"Tabs Title\",\n            tabs=[\n                vm.Container(\n                    title=\"Tab I\",\n                    components=[\n                        vm.Graph(\n                            figure=px.bar(\n                                gapminder_2007,\n                                title=\"Graph 1\",\n                                x=\"continent\",\n                                y=\"lifeExp\",\n                                color=\"continent\",\n                            ),\n                        ),\n                        vm.Graph(\n                            figure=px.box(\n                                gapminder_2007,\n                                title=\"Graph 2\",\n                                x=\"continent\",\n                                y=\"lifeExp\",\n                                color=\"continent\",\n                            ),\n                        ),\n                    ],\n                ),\n                vm.Container(\n                    title=\"Tab II\",\n                    components=[\n                        vm.Graph(\n                            figure=px.scatter(\n                                gapminder_2007,\n                                title=\"Graph 3\",\n                                x=\"gdpPercap\",\n                                y=\"lifeExp\",\n                                size=\"pop\",\n                                color=\"continent\",\n                            ),\n                        ),\n                    ],\n                ),\n            ],\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  components:\n    - type: tabs\n      title: Tabs Title\n      tabs:\n        - title: Tab I\n          type: container\n          components:\n            - type: graph\n              figure:\n                _target_: bar\n                data_frame: gapminder_2007\n                title: Graph 1\n                x: continent\n                y: lifeExp\n                color: continent\n            - type: graph\n              figure:\n                _target_: box\n                data_frame: gapminder_2007\n                title: Graph 2\n                x: continent\n                y: lifeExp\n                color: continent\n        - title: Tab II\n          type: container\n          components:\n            - type: graph\n              figure:\n                _target_: scatter\n                data_frame: gapminder_2007\n                title: Graph 3\n                x: gdpPercap\n                y: lifeExp\n                size: pop\n                color: continent\n  title: Tabs\n</code></pre> <p></p>","path":["How to use tabs"],"tags":[]},{"location":"user-guides/tabs/#add-a-tooltip","level":2,"title":"Add a tooltip","text":"<p>The <code>description</code> argument enables you to add helpful context to your tabs by displaying an info icon next to its title. Hovering over the icon shows a tooltip with your chosen text.</p> <p>You can provide Markdown text as a string to use the default info icon or a [<code>Tooltip</code>][vizro.models.Tooltip] model to use any icon from the Google Material Icons library.</p> <p>Tabs with tooltip</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\ngapminder_2007 = px.data.gapminder().query(\"year == 2007\")\n\npage = vm.Page(\n    title=\"Tabs\",\n    components=[\n        vm.Tabs(\n            title=\"Tabs Title\",\n            description=\"\"\"\n                The Iris dataset includes measurements of 150 iris flowers across three types: Setosa, Versicolor, and Virginica.\n\n                While all samples are labeled by type, they can appear similar when looking at just some features—making it a useful dataset for exploring patterns and challenges in classification.\n            \"\"\",\n            tabs=[\n                vm.Container(\n                    title=\"Tab I\",\n                    components=[\n                        vm.Graph(\n                            figure=px.bar(\n                                gapminder_2007,\n                                title=\"Graph 1\",\n                                x=\"continent\",\n                                y=\"lifeExp\",\n                                color=\"continent\",\n                            ),\n                        ),\n                        vm.Graph(\n                            figure=px.box(\n                                gapminder_2007,\n                                title=\"Graph 2\",\n                                x=\"continent\",\n                                y=\"lifeExp\",\n                                color=\"continent\",\n                            ),\n                        ),\n                    ],\n                ),\n                vm.Container(\n                    title=\"Tab II\",\n                    components=[\n                        vm.Graph(\n                            figure=px.scatter(\n                                gapminder_2007,\n                                title=\"Graph 3\",\n                                x=\"gdpPercap\",\n                                y=\"lifeExp\",\n                                size=\"pop\",\n                                color=\"continent\",\n                            ),\n                        ),\n                    ],\n                ),\n            ],\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  components:\n    - type: tabs\n      title: Tabs Title\n      description: |\n            The Iris dataset includes measurements of 150 iris flowers across three types: Setosa, Versicolor, and Virginica.\n\n            While all samples are labeled by type, they can appear similar when looking at just some features—making it a useful dataset for exploring patterns and challenges in classification.\n      tabs:\n        - title: Tab I\n          type: container\n          components:\n            - type: graph\n              figure:\n                _target_: bar\n                data_frame: gapminder_2007\n                title: Graph 1\n                x: continent\n                y: lifeExp\n                color: continent\n            - type: graph\n              figure:\n                _target_: box\n                data_frame: gapminder_2007\n                title: Graph 2\n                x: continent\n                y: lifeExp\n                color: continent\n        - title: Tab II\n          type: container\n          components:\n            - type: graph\n              figure:\n                _target_: scatter\n                data_frame: gapminder_2007\n                title: Graph 3\n                x: gdpPercap\n                y: lifeExp\n                size: pop\n                color: continent\n  title: Tabs\n</code></pre> <p></p>","path":["How to use tabs"],"tags":[]},{"location":"user-guides/text/","level":1,"title":"How to add text to your page","text":"<p>This guide shows you how to display text in your dashboard with the [<code>Text</code> component][vizro.models.Text] model.</p> <p>Card and Text components</p> <p>The <code>Card</code> component and <code>Text</code> component both enable you to add text to your page using Markdown syntax through the underlying Dash component <code>dcc.Markdown</code>.</p> <p>You should use <code>Text</code> to display plain Markdown text without any extra styling like borders or background, for example to add an introductory paragraph to your page.</p> <p>You should use <code>Card</code> to display Markdown text that needs attention drawn to it. Generally, this would be relatively short portions of text. Unlike <code>Text</code>, a <code>Card</code> can also be used for navigation.</p> <p>You can add a [<code>Text</code>][vizro.models.Text] model to your dashboard by inserting [<code>Text</code>][vizro.models.Text] into the <code>components</code> argument of the [<code>Page</code>][vizro.models.Page] or [<code>Container</code>][vizro.models.Container] models.</p> <p>Text</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"Text example\",\n    components=[\n        vm.Text(\n            text=\"Commodi repudiandae consequuntur voluptatum.\"\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: Commodi repudiandae consequuntur voluptatum.\n        type: text\n    title: Text example\n</code></pre> <p></p>","path":["How to add text to your page"],"tags":[]},{"location":"user-guides/text/#customize-text","level":2,"title":"Customize text","text":"<p>The [<code>Text</code>][vizro.models.Text] model uses the <code>dcc.Markdown</code> component from Dash as its underlying text component. For more details on customizing the Markdown text, refer to the <code>dcc.Markdown</code> component documentation. Based on examples from Dash, the [<code>Text</code>][vizro.models.Text] model supports the following:</p> <ul> <li>Headers</li> <li>Emphasis</li> <li>Lists</li> <li>Block Quotes</li> <li>Images</li> <li>Links</li> </ul> <p>Text using markdown</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"Customizing Text\",\n    components=[\n        vm.Text(\n            text=\"\"\"\n                # Header level 1 &lt;h1&gt;\n\n                ## Header level 2 &lt;h2&gt;\n\n                ### Header level 3 &lt;h3&gt;\n\n                #### Header level 4 &lt;h4&gt;\n\n                Commodi repudiandae consequuntur voluptatum laborum numquam blanditiis harum quisquam eius sed odit.\n\n                Fugiat iusto fuga praesentium option, eaque rerum! Provident similique accusantium nemo autem.\n\n                Obcaecati tenetur iure eius earum ut molestias architecto voluptate aliquam nihil, eveniet aliquid.\n\n                Culpa officia aut! Impedit sit sunt quaerat, odit, tenetur error, harum nesciunt ipsum debitis quas.\n\n                ### Block Quotes\n\n                &gt;\n                &gt; A block quote is a long quotation, indented to create a separate block of text.\n                &gt;\n\n                ### Lists\n\n                * Item A\n                    * Sub Item 1\n                    * Sub Item 2\n                * Item B\n\n                ### Emphasis\n\n                This word will be *italic*\n\n                This word will be **bold**\n\n                This word will be _**bold and italic**_\n            \"\"\",\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - title: Customizing Text\n        text: |\n          # Header level 1 &lt;h1&gt;\n\n          ## Header level 2 &lt;h2&gt;\n\n          ### Header level 3 &lt;h3&gt;\n\n          #### Header level 4 &lt;h4&gt;\n\n          Commodi repudiandae consequuntur voluptatum laborum numquam blanditiis harum quisquam eius sed odit.\n\n          Fugiat iusto fuga praesentium option, eaque rerum! Provident similique accusantium nemo autem.\n\n          Obcaecati tenetur iure eius earum ut molestias architecto voluptate aliquam nihil, eveniet aliquid.\n\n          Culpa officia aut! Impedit sit sunt quaerat, odit, tenetur error, harum nesciunt ipsum debitis quas.\n\n          ### Block Quotes\n\n          &gt;\n          &gt; A block quote is a long quotation, indented to create a separate block of text.\n          &gt;\n\n          ### Lists\n\n          * Item A\n              * Sub Item 1\n              * Sub Item 2\n          * Item B\n\n          ### Emphasis\n\n          This word will be *italic*\n\n          This word will be **bold**\n\n          This word will be _**bold and italic**_\n</code></pre> <p></p>","path":["How to add text to your page"],"tags":[]},{"location":"user-guides/text/#the-extra-argument","level":2,"title":"The <code>extra</code> argument","text":"<p>The <code>Text</code> is based on the underlying Dash component <code>dcc.Markdown</code>. Using the <code>extra</code> argument you can pass extra arguments to <code>dcc.Markdown</code> in order to alter it beyond the chosen defaults.</p> <p>Note</p> <p>Using <code>extra</code> is a quick and flexible way to alter a component beyond what Vizro offers. However, it is not a part of the official Vizro schema and the underlying implementation details may change. If you want to guarantee that your apps keep running, we recommend that you pin your Vizro version.</p> <p>An example use would be to set <code>mathjax=True</code> (defaults to <code>False</code>) to display mathematical equations. For this, you can use <code>extra={\"mathjax\": True}</code>.</p> <p>Text with extra argument</p> app.pyapp.yamlResult <pre><code>import vizro.models as vm\nfrom vizro import Vizro\n\npage = vm.Page(\n    title=\"Text with extra argument\",\n    components=[\n        vm.Text(\n            text=\"\"\"\n              This example uses the block delimiter:\n              $$\n              \\\\int_0^\\\\infty e^{-x^2} dx = \\\\frac{\\\\sqrt{\\\\pi}}{2}\n              $$\n\n              This example uses the inline delimiter:\n              $x = \\\\frac{-b \\\\pm \\\\sqrt{b^2 - 4ac}}{2a}$\n            \"\"\",\n            extra={\"mathjax\": True}\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - text: |\n          This example uses the block delimiter:\n          $$\n          \\\\int_0^\\\\infty e^{-x^2} dx = \\\\frac{\\\\sqrt{\\\\pi}}{2}\n          $$\n\n          This example uses the inline delimiter:\n          $x = \\\\frac{-b \\\\pm \\\\sqrt{b^2 - 4ac}}{2a}$\n        type: text\n    title: Text with extra argument\n</code></pre> <p></p>","path":["How to add text to your page"],"tags":[]},{"location":"user-guides/themes/","level":1,"title":"How to use themes","text":"<p>This guide shows you how to use themes. Themes are pre-designed collections of stylings that are applied to entire charts and dashboards. The themes provided by Vizro are infused with our design best practices that make charts and dashboards look visually consistent and professional.</p>","path":["How to use themes"],"tags":[]},{"location":"user-guides/themes/#built-in-vizro-themes-darklight","level":2,"title":"Built-in Vizro themes (dark/light)","text":"<p>The [<code>Dashboard</code>][vizro.models.Dashboard] model accepts an optional <code>theme</code> argument, where you can choose between a <code>vizro_dark</code> and a <code>vizro_light</code> theme. If not specified then <code>theme</code> defaults to <code>vizro_dark</code>. The theme is applied to the entire dashboard and its charts/components when a user first loads your dashboard. Regardless of the theme applied on first load, users can always switch between light and dark themes via the toggle button in the upper-right corner of the dashboard.</p> <p>Change theme</p> app.pyapp.yamlResult - vizro_lightResult - vizro_dark <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\n\ndf = px.data.iris()\n\npage = vm.Page(\n    title=\"Changing themes\",\n    components=[\n        vm.Graph(\n            figure=px.scatter_matrix(\n                df, dimensions=[\"sepal_length\", \"sepal_width\", \"petal_length\", \"petal_width\"], color=\"species\"\n            ),\n        ),\n    ],\n)\n\ndashboard = vm.Dashboard(pages=[page], theme=\"vizro_light\")\nVizro().build(dashboard).run()\n</code></pre> <pre><code># Still requires a .py to add data to the data manager and parse YAML configuration\n# See yaml_version example\npages:\n  - components:\n      - figure:\n          _target_: scatter_matrix\n          color: species\n          data_frame: iris\n          dimensions: [sepal_length, sepal_width, petal_length, petal_width]\n        type: graph\n    title: Changing themes\ntheme: vizro_light\n</code></pre> <p></p> <p></p>","path":["How to use themes"],"tags":[]},{"location":"user-guides/themes/#custom-bootstrap-themes","level":2,"title":"Custom Bootstrap themes","text":"<p>If you would like to change the default Vizro styling, you have two options:</p> <ul> <li>Apply custom CSS to override specific properties. See our guide on customizing CSS for full details.</li> <li>Load a completely different Bootstrap theme.</li> </ul> <p>Vizro is primarily built out of Dash Bootstrap components, which means you can customize the appearance by providing your own Bootstrap theme via the <code>Vizro(external_stylesheets=...)</code>. When you specify an external Bootstrap stylesheet, Vizro will use your custom theme instead of its default styling. You can explore available Bootstrap themes in the Dash Bootstrap Components theme gallery.</p> <p>Use bootstrap theme</p> app.pyResult - Bootstrap lightResult - Bootstrap dark <pre><code>import vizro.models as vm\nimport vizro.plotly.express as px\nfrom vizro import Vizro\nimport dash_bootstrap_components as dbc\n\ndf = px.data.iris()\n\npage = vm.Page(\n    title=\"Bootstrap theme inside Vizro app\",\n    layout=vm.Grid(grid=[[0, 1], [2, 2], [2, 2], [3, 3], [3, 3]]),\n    components=[\n        vm.Card(\n            text=\"\"\"\n                ### What is Vizro?\n                An open-source toolkit for creating modular data visualization applications.\n\n                Rapidly self-serve the assembly of customized dashboards in minutes - without the need for advanced coding or design experience - to create flexible and scalable, Python-enabled data visualization applications.\"\"\"\n        ),\n        vm.Card(\n            text=\"\"\"\n                ### Github\n\n                Checkout Vizro's GitHub page for further information and release notes. Contributions are always welcome!\"\"\",\n            href=\"https://github.com/mckinsey/vizro\",\n        ),\n        vm.Graph(id=\"scatter_chart\", figure=px.scatter(df, x=\"sepal_length\", y=\"petal_width\", color=\"species\")),\n        vm.Graph(id=\"hist_chart\", figure=px.histogram(df, x=\"sepal_width\", color=\"species\")),\n    ],\n    controls=[vm.Filter(column=\"species\"), vm.Filter(column=\"petal_length\"), vm.Filter(column=\"sepal_width\")],\n)\n\ndashboard = vm.Dashboard(pages=[page])\nVizro(external_stylesheets=[dbc.themes.BOOTSTRAP]).build(dashboard).run()\n</code></pre> <p></p> <p></p>","path":["How to use themes"],"tags":[]},{"location":"user-guides/themes/#vizro-themes-in-plotly-charts","level":2,"title":"Vizro themes in plotly charts","text":"<p>You can also use our templates for plotly charts outside the dashboard. This is useful in a few contexts:</p> <ul> <li>Creation of standalone charts to be used independently of a Vizro dashboard.</li> <li>Rapid development of charts for eventual use in a Vizro dashboard, for example in a Jupyter Notebook.</li> </ul> <p>Note</p> <p>Using <code>import vizro.plotly.express as px</code> is equal to using <code>import plotly.express as px</code>, but with the added benefit of being able to integrate the resulting chart code into a Vizro dashboard. Vizro offers a minimal layer on top of Plotly's existing charting library, allowing you to seamlessly use all the existing charts and functionalities provided by plotly.express without any modifications.</p> <p>Our <code>vizro_dark</code> and <code>vizro_light</code> themes are automatically registered to <code>plotly.io.templates</code> when importing Vizro. Consult the plotly documentation for more details on how templates work in plotly.</p> <p>By default, plots imported from <code>vizro.plotly.express</code> have the <code>vizro_dark</code> theme applied. This can be altered either globally or for individual plots.</p>","path":["How to use themes"],"tags":[]},{"location":"user-guides/themes/#set-themes-for-all-charts","level":3,"title":"Set themes for all charts","text":"<p>To change the theme to <code>vizro_light</code> for all charts, run:</p> <pre><code>import plotly.io as pio\nimport vizro.plotly.express as px\n\npio.templates.default = \"vizro_light\"\n\ndf = px.data.iris()\npx.scatter_matrix(\n    df,\n    dimensions=[\"sepal_length\", \"sepal_width\", \"petal_length\", \"petal_width\"],\n    color=\"species\",\n)\n</code></pre>","path":["How to use themes"],"tags":[]},{"location":"user-guides/themes/#set-themes-for-selected-charts","level":3,"title":"Set themes for selected charts","text":"<p>To change the template for a selected chart only, use the <code>template</code> parameter and run:</p> <pre><code>import vizro.plotly.express as px\n\ndf = px.data.iris()\npx.scatter_matrix(\n    df,\n    dimensions=[\"sepal_length\", \"sepal_width\", \"petal_length\", \"petal_width\"],\n    color=\"species\",\n    template=\"vizro_light\",\n)\n</code></pre>","path":["How to use themes"],"tags":[]},{"location":"user-guides/themes/#vizro-bootstrap-for-pure-dash-app","level":2,"title":"Vizro Bootstrap for pure Dash app","text":"<p>Vizro apps use the Dash Bootstrap Components library of Bootstrap components for Dash. If you have a pure Dash app and want to use Vizro's themes, you can apply Vizro's Bootstrap stylesheet in a similar way to other Dash Bootstrap themes through the <code>vizro.bootstrap</code> variable:</p> <pre><code>import vizro\nfrom dash import Dash\n\napp = Dash(external_stylesheets=[vizro.bootstrap])\n</code></pre> <p>Vizro uses some extra CSS in addition to the Bootstrap stylesheet to style some Dash components that are used in Vizro but are not part of Bootstrap (for example, [<code>DatePicker</code>][vizro.models.DatePicker] is based on Dash Mantine Components). If you would like your pure Dash app to look as close to Vizro as possible then you will also need this extra CSS.</p> Apply Vizro Bootstrap theme to charts and other components <p>To apply the Vizro theme to plotly charts, refer to the above section Vizro themes in plotly charts. This is possible with or without Vizro Bootstrap.</p> <p>If you want to style your entire Dash app with Vizro Bootstrap and have your plotly figures automatically match then we recommend <code>dash-bootstrap-templates</code>. You can find examples of how to do this in their documentation on styling plotly figures with a Bootstrap theme.</p>","path":["How to use themes"],"tags":[]},{"location":"user-guides/visual-formatting/","level":1,"title":"How to customize the style of Vizro dashboards","text":"<p>Vizro has a default styling to help users with no design experience get started. There are several options if you want to customize the style:</p> <ul> <li> <p>Configure the layout: Customize the arrangement of your components inside your Vizro dashboard.</p> </li> <li> <p>Apply a theme: Choose between a dark or light theme.</p> </li> <li> <p>Manage assets: Enhance your dashboard by adding images, scripts, and stylesheets to your assets folder.</p> </li> <li> <p>Customize CSS: Incorporate custom CSS to deviate from the default styling and create a unique appearance for your Vizro dashboard.</p> </li> <li> <p>Customize your <code>component</code>: Change the appearance of components like the Graph, the Table and the AgGrid, by passing extra arguments. Refer to the relevant user guide for more details.</p> </li> </ul>","path":["How to customize the style of Vizro dashboards"],"tags":[]}]}